// biome-ignore-all lint: generated file
/* eslint-disable */

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports2, module2) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    __name(parse5, "parse");
    function fmtShort(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d2) {
        return Math.round(ms3 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms3 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms3 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms3 / s2) + "s";
      }
      return ms3 + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d2) {
        return plural(ms3, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural(ms3, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms3, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms3, msAbs, s2, "second");
      }
      return ms3 + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms3, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms3 / n2) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/headers.js
var require_headers = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/headers.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var headers_exports = {};
    __export2(headers_exports, {
      CITY_HEADER_NAME: /* @__PURE__ */ __name(() => CITY_HEADER_NAME, "CITY_HEADER_NAME"),
      COUNTRY_HEADER_NAME: /* @__PURE__ */ __name(() => COUNTRY_HEADER_NAME, "COUNTRY_HEADER_NAME"),
      EMOJI_FLAG_UNICODE_STARTING_POSITION: /* @__PURE__ */ __name(() => EMOJI_FLAG_UNICODE_STARTING_POSITION, "EMOJI_FLAG_UNICODE_STARTING_POSITION"),
      IP_HEADER_NAME: /* @__PURE__ */ __name(() => IP_HEADER_NAME, "IP_HEADER_NAME"),
      LATITUDE_HEADER_NAME: /* @__PURE__ */ __name(() => LATITUDE_HEADER_NAME, "LATITUDE_HEADER_NAME"),
      LONGITUDE_HEADER_NAME: /* @__PURE__ */ __name(() => LONGITUDE_HEADER_NAME, "LONGITUDE_HEADER_NAME"),
      POSTAL_CODE_HEADER_NAME: /* @__PURE__ */ __name(() => POSTAL_CODE_HEADER_NAME, "POSTAL_CODE_HEADER_NAME"),
      REGION_HEADER_NAME: /* @__PURE__ */ __name(() => REGION_HEADER_NAME, "REGION_HEADER_NAME"),
      REQUEST_ID_HEADER_NAME: /* @__PURE__ */ __name(() => REQUEST_ID_HEADER_NAME, "REQUEST_ID_HEADER_NAME"),
      geolocation: /* @__PURE__ */ __name(() => geolocation2, "geolocation"),
      ipAddress: /* @__PURE__ */ __name(() => ipAddress2, "ipAddress")
    });
    module2.exports = __toCommonJS2(headers_exports);
    var CITY_HEADER_NAME = "x-vercel-ip-city";
    var COUNTRY_HEADER_NAME = "x-vercel-ip-country";
    var IP_HEADER_NAME = "x-real-ip";
    var LATITUDE_HEADER_NAME = "x-vercel-ip-latitude";
    var LONGITUDE_HEADER_NAME = "x-vercel-ip-longitude";
    var REGION_HEADER_NAME = "x-vercel-ip-country-region";
    var POSTAL_CODE_HEADER_NAME = "x-vercel-ip-postal-code";
    var REQUEST_ID_HEADER_NAME = "x-vercel-id";
    var EMOJI_FLAG_UNICODE_STARTING_POSITION = 127397;
    function getHeader(headers, key) {
      return headers.get(key) ?? void 0;
    }
    __name(getHeader, "getHeader");
    function getHeaderWithDecode(request2, key) {
      const header = getHeader(request2.headers, key);
      return header ? decodeURIComponent(header) : void 0;
    }
    __name(getHeaderWithDecode, "getHeaderWithDecode");
    function getFlag(countryCode) {
      const regex = new RegExp("^[A-Z]{2}$").test(countryCode);
      if (!countryCode || !regex) return void 0;
      return String.fromCodePoint(...countryCode.split("").map((char) => EMOJI_FLAG_UNICODE_STARTING_POSITION + char.charCodeAt(0)));
    }
    __name(getFlag, "getFlag");
    function ipAddress2(input) {
      const headers = "headers" in input ? input.headers : input;
      return getHeader(headers, IP_HEADER_NAME);
    }
    __name(ipAddress2, "ipAddress");
    function getRegionFromRequestId(requestId) {
      if (!requestId) {
        return "dev1";
      }
      return requestId.split(":")[0];
    }
    __name(getRegionFromRequestId, "getRegionFromRequestId");
    function geolocation2(request2) {
      return {
        // city name may be encoded to support multi-byte characters
        city: getHeaderWithDecode(request2, CITY_HEADER_NAME),
        country: getHeader(request2.headers, COUNTRY_HEADER_NAME),
        flag: getFlag(getHeader(request2.headers, COUNTRY_HEADER_NAME)),
        countryRegion: getHeader(request2.headers, REGION_HEADER_NAME),
        region: getRegionFromRequestId(getHeader(request2.headers, REQUEST_ID_HEADER_NAME)),
        latitude: getHeader(request2.headers, LATITUDE_HEADER_NAME),
        longitude: getHeader(request2.headers, LONGITUDE_HEADER_NAME),
        postalCode: getHeader(request2.headers, POSTAL_CODE_HEADER_NAME)
      };
    }
    __name(geolocation2, "geolocation");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/get-env.js
var require_get_env = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/get-env.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var get_env_exports = {};
    __export2(get_env_exports, {
      getEnv: /* @__PURE__ */ __name(() => getEnv2, "getEnv")
    });
    module2.exports = __toCommonJS2(get_env_exports);
    var getEnv2 = /* @__PURE__ */ __name((env = process.env) => ({
      /**
      * An indicator to show that System Environment Variables have been exposed to your project's Deployments.
      * @example "1"
      */
      VERCEL: get(env, "VERCEL"),
      /**
      * An indicator that the code is running in a Continuous Integration environment.
      * @example "1"
      */
      CI: get(env, "CI"),
      /**
      * The Environment that the app is deployed and running on.
      * @example "production"
      */
      VERCEL_ENV: get(env, "VERCEL_ENV"),
      /**
      * The domain name of the generated deployment URL. The value does not include the protocol scheme https://.
      * NOTE: This Variable cannot be used in conjunction with Standard Deployment Protection.
      * @example "*.vercel.app"
      */
      VERCEL_URL: get(env, "VERCEL_URL"),
      /**
      * The domain name of the generated Git branch URL. The value does not include the protocol scheme https://.
      * @example "*-git-*.vercel.app"
      */
      VERCEL_BRANCH_URL: get(env, "VERCEL_BRANCH_URL"),
      /**
      * A production domain name of the project. This is useful to reliably generate links that point to production such as OG-image URLs.
      * The value does not include the protocol scheme https://.
      * @example "myproject.vercel.app"
      */
      VERCEL_PROJECT_PRODUCTION_URL: get(env, "VERCEL_PROJECT_PRODUCTION_URL"),
      /**
      * The ID of the Region where the app is running.
      *
      * Possible values:
      * - arn1 (Stockholm, Sweden)
      * - bom1 (Mumbai, India)
      * - cdg1 (Paris, France)
      * - cle1 (Cleveland, USA)
      * - cpt1 (Cape Town, South Africa)
      * - dub1 (Dublin, Ireland)
      * - fra1 (Frankfurt, Germany)
      * - gru1 (SÃ£o Paulo, Brazil)
      * - hkg1 (Hong Kong)
      * - hnd1 (Tokyo, Japan)
      * - iad1 (Washington, D.C., USA)
      * - icn1 (Seoul, South Korea)
      * - kix1 (Osaka, Japan)
      * - lhr1 (London, United Kingdom)
      * - pdx1 (Portland, USA)
      * - sfo1 (San Francisco, USA)
      * - sin1 (Singapore)
      * - syd1 (Sydney, Australia)
      * - dev1 (Development Region)
      *
      * @example "iad1"
      */
      VERCEL_REGION: get(env, "VERCEL_REGION"),
      /**
      * The unique identifier for the deployment, which can be used to implement Skew Protection.
      * @example "dpl_7Gw5ZMBpQA8h9GF832KGp7nwbuh3"
      */
      VERCEL_DEPLOYMENT_ID: get(env, "VERCEL_DEPLOYMENT_ID"),
      /**
      * When Skew Protection is enabled in Project Settings, this value is set to 1.
      * @example "1"
      */
      VERCEL_SKEW_PROTECTION_ENABLED: get(env, "VERCEL_SKEW_PROTECTION_ENABLED"),
      /**
      * The Protection Bypass for Automation value, if the secret has been generated in the project's Deployment Protection settings.
      */
      VERCEL_AUTOMATION_BYPASS_SECRET: get(env, "VERCEL_AUTOMATION_BYPASS_SECRET"),
      /**
      * The Git Provider the deployment is triggered from.
      * @example "github"
      */
      VERCEL_GIT_PROVIDER: get(env, "VERCEL_GIT_PROVIDER"),
      /**
      * The origin repository the deployment is triggered from.
      * @example "my-site"
      */
      VERCEL_GIT_REPO_SLUG: get(env, "VERCEL_GIT_REPO_SLUG"),
      /**
      * The account that owns the repository the deployment is triggered from.
      * @example "acme"
      */
      VERCEL_GIT_REPO_OWNER: get(env, "VERCEL_GIT_REPO_OWNER"),
      /**
      * The ID of the repository the deployment is triggered from.
      * @example "117716146"
      */
      VERCEL_GIT_REPO_ID: get(env, "VERCEL_GIT_REPO_ID"),
      /**
      * The git branch of the commit the deployment was triggered by.
      * @example "improve-about-page"
      */
      VERCEL_GIT_COMMIT_REF: get(env, "VERCEL_GIT_COMMIT_REF"),
      /**
      * The git SHA of the commit the deployment was triggered by.
      * @example "fa1eade47b73733d6312d5abfad33ce9e4068081"
      */
      VERCEL_GIT_COMMIT_SHA: get(env, "VERCEL_GIT_COMMIT_SHA"),
      /**
      * The message attached to the commit the deployment was triggered by.
      * @example "Update about page"
      */
      VERCEL_GIT_COMMIT_MESSAGE: get(env, "VERCEL_GIT_COMMIT_MESSAGE"),
      /**
      * The username attached to the author of the commit that the project was deployed by.
      * @example "johndoe"
      */
      VERCEL_GIT_COMMIT_AUTHOR_LOGIN: get(env, "VERCEL_GIT_COMMIT_AUTHOR_LOGIN"),
      /**
      * The name attached to the author of the commit that the project was deployed by.
      * @example "John Doe"
      */
      VERCEL_GIT_COMMIT_AUTHOR_NAME: get(env, "VERCEL_GIT_COMMIT_AUTHOR_NAME"),
      /**
      * The git SHA of the last successful deployment for the project and branch.
      * NOTE: This Variable is only exposed when an Ignored Build Step is provided.
      * @example "fa1eade47b73733d6312d5abfad33ce9e4068080"
      */
      VERCEL_GIT_PREVIOUS_SHA: get(env, "VERCEL_GIT_PREVIOUS_SHA"),
      /**
      * The pull request id the deployment was triggered by. If a deployment is created on a branch before a pull request is made, this value will be an empty string.
      * @example "23"
      */
      VERCEL_GIT_PULL_REQUEST_ID: get(env, "VERCEL_GIT_PULL_REQUEST_ID")
    }), "getEnv");
    var get = /* @__PURE__ */ __name((env, key) => {
      const value = env[key];
      return value === "" ? void 0 : value;
    }, "get");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/get-context.js
var require_get_context = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/get-context.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var get_context_exports = {};
    __export2(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: /* @__PURE__ */ __name(() => SYMBOL_FOR_REQ_CONTEXT, "SYMBOL_FOR_REQ_CONTEXT"),
      getContext: /* @__PURE__ */ __name(() => getContext2, "getContext")
    });
    module2.exports = __toCommonJS2(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
    function getContext2() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
    __name(getContext2, "getContext");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/wait-until.js
var require_wait_until = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/wait-until.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var wait_until_exports = {};
    __export2(wait_until_exports, {
      waitUntil: /* @__PURE__ */ __name(() => waitUntil5, "waitUntil")
    });
    module2.exports = __toCommonJS2(wait_until_exports);
    var import_get_context = require_get_context();
    var waitUntil5 = /* @__PURE__ */ __name((promise2) => {
      if (promise2 === null || typeof promise2 !== "object" || typeof promise2.then !== "function") {
        throw new TypeError(`waitUntil can only be called with a Promise, got ${typeof promise2}`);
      }
      return (0, import_get_context.getContext)().waitUntil?.(promise2);
    }, "waitUntil");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/middleware.js
var require_middleware = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/middleware.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var middleware_exports = {};
    __export2(middleware_exports, {
      next: /* @__PURE__ */ __name(() => next2, "next"),
      rewrite: /* @__PURE__ */ __name(() => rewrite2, "rewrite")
    });
    module2.exports = __toCommonJS2(middleware_exports);
    function handleMiddlewareField(init, headers) {
      if (init?.request?.headers) {
        if (!(init.request.headers instanceof Headers)) {
          throw new Error("request.headers must be an instance of Headers");
        }
        const keys = [];
        for (const [key, value] of init.request.headers) {
          headers.set("x-middleware-request-" + key, value);
          keys.push(key);
        }
        headers.set("x-middleware-override-headers", keys.join(","));
      }
    }
    __name(handleMiddlewareField, "handleMiddlewareField");
    function rewrite2(destination, init) {
      const headers = new Headers(init?.headers ?? {});
      headers.set("x-middleware-rewrite", String(destination));
      handleMiddlewareField(init, headers);
      return new Response(null, {
        ...init,
        headers
      });
    }
    __name(rewrite2, "rewrite");
    function next2(init) {
      const headers = new Headers(init?.headers ?? {});
      headers.set("x-middleware-next", "1");
      handleMiddlewareField(init, headers);
      return new Response(null, {
        ...init,
        headers
      });
    }
    __name(next2, "next");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/cache/in-memory-cache.js
var require_in_memory_cache = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/cache/in-memory-cache.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var in_memory_cache_exports = {};
    __export2(in_memory_cache_exports, {
      InMemoryCache: /* @__PURE__ */ __name(() => InMemoryCache, "InMemoryCache")
    });
    module2.exports = __toCommonJS2(in_memory_cache_exports);
    var InMemoryCache = class {
      static {
        __name(this, "InMemoryCache");
      }
      constructor() {
        this.cache = {};
      }
      async get(key) {
        const entry = this.cache[key];
        if (entry) {
          if (entry.ttl && entry.lastModified + entry.ttl * 1e3 < Date.now()) {
            await this.delete(key);
            return null;
          }
          return entry.value;
        }
        return null;
      }
      async set(key, value, options) {
        this.cache[key] = {
          value,
          lastModified: Date.now(),
          ttl: options?.ttl,
          tags: new Set(options?.tags || [])
        };
      }
      async delete(key) {
        delete this.cache[key];
      }
      async expireTag(tag) {
        const tags = Array.isArray(tag) ? tag : [
          tag
        ];
        for (const key in this.cache) {
          if (Object.prototype.hasOwnProperty.call(this.cache, key)) {
            const entry = this.cache[key];
            if (tags.some((t2) => entry.tags.has(t2))) {
              delete this.cache[key];
            }
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/cache/build-client.js
var require_build_client = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/cache/build-client.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var build_client_exports = {};
    __export2(build_client_exports, {
      BuildCache: /* @__PURE__ */ __name(() => BuildCache, "BuildCache")
    });
    module2.exports = __toCommonJS2(build_client_exports);
    var import_index2 = require_cache();
    var BuildCache = class {
      static {
        __name(this, "BuildCache");
      }
      constructor({ endpoint: endpoint2, headers, onError, timeout = 500 }) {
        this.get = async (key) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);
          try {
            const res = await fetch(`${this.endpoint}${key}`, {
              headers: this.headers,
              method: "GET",
              signal: controller.signal
            });
            if (res.status === 404) {
              clearTimeout(timeoutId);
              return null;
            }
            if (res.status === 200) {
              const cacheState = res.headers.get(import_index2.HEADERS_VERCEL_CACHE_STATE);
              if (cacheState !== import_index2.PkgCacheState.Fresh) {
                res.body?.cancel?.();
                clearTimeout(timeoutId);
                return null;
              }
              const result = await res.json();
              clearTimeout(timeoutId);
              return result;
            } else {
              clearTimeout(timeoutId);
              throw new Error(`Failed to get cache: ${res.statusText}`);
            }
          } catch (error45) {
            clearTimeout(timeoutId);
            if (error45.name === "AbortError") {
              const timeoutError = new Error(`Cache request timed out after ${this.timeout}ms`);
              timeoutError.stack = error45.stack;
              this.onError?.(timeoutError);
            } else {
              this.onError?.(error45);
            }
            return null;
          }
        };
        this.set = async (key, value, options) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);
          try {
            const optionalHeaders = {};
            if (options?.ttl) {
              optionalHeaders[import_index2.HEADERS_VERCEL_REVALIDATE] = options.ttl.toString();
            }
            if (options?.tags && options.tags.length > 0) {
              optionalHeaders[import_index2.HEADERS_VERCEL_CACHE_TAGS] = options.tags.join(",");
            }
            if (options?.name) {
              optionalHeaders[import_index2.HEADERS_VERCEL_CACHE_ITEM_NAME] = options.name;
            }
            const res = await fetch(`${this.endpoint}${key}`, {
              method: "POST",
              headers: {
                ...this.headers,
                ...optionalHeaders
              },
              body: JSON.stringify(value),
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (res.status !== 200) {
              throw new Error(`Failed to set cache: ${res.status} ${res.statusText}`);
            }
          } catch (error45) {
            clearTimeout(timeoutId);
            if (error45.name === "AbortError") {
              const timeoutError = new Error(`Cache request timed out after ${this.timeout}ms`);
              timeoutError.stack = error45.stack;
              this.onError?.(timeoutError);
            } else {
              this.onError?.(error45);
            }
          }
        };
        this.delete = async (key) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);
          try {
            const res = await fetch(`${this.endpoint}${key}`, {
              method: "DELETE",
              headers: this.headers,
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (res.status !== 200) {
              throw new Error(`Failed to delete cache: ${res.statusText}`);
            }
          } catch (error45) {
            clearTimeout(timeoutId);
            if (error45.name === "AbortError") {
              const timeoutError = new Error(`Cache request timed out after ${this.timeout}ms`);
              timeoutError.stack = error45.stack;
              this.onError?.(timeoutError);
            } else {
              this.onError?.(error45);
            }
          }
        };
        this.expireTag = async (tag) => {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);
          try {
            if (Array.isArray(tag)) {
              tag = tag.join(",");
            }
            const res = await fetch(`${this.endpoint}revalidate?tags=${tag}`, {
              method: "POST",
              headers: this.headers,
              signal: controller.signal
            });
            clearTimeout(timeoutId);
            if (res.status !== 200) {
              throw new Error(`Failed to revalidate tag: ${res.statusText}`);
            }
          } catch (error45) {
            clearTimeout(timeoutId);
            if (error45.name === "AbortError") {
              const timeoutError = new Error(`Cache request timed out after ${this.timeout}ms`);
              timeoutError.stack = error45.stack;
              this.onError?.(timeoutError);
            } else {
              this.onError?.(error45);
            }
          }
        };
        this.endpoint = endpoint2;
        this.headers = headers;
        this.onError = onError;
        this.timeout = timeout;
      }
    };
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/cache/index.js
var require_cache = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/cache/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var cache_exports = {};
    __export2(cache_exports, {
      HEADERS_VERCEL_CACHE_ITEM_NAME: /* @__PURE__ */ __name(() => HEADERS_VERCEL_CACHE_ITEM_NAME, "HEADERS_VERCEL_CACHE_ITEM_NAME"),
      HEADERS_VERCEL_CACHE_STATE: /* @__PURE__ */ __name(() => HEADERS_VERCEL_CACHE_STATE, "HEADERS_VERCEL_CACHE_STATE"),
      HEADERS_VERCEL_CACHE_TAGS: /* @__PURE__ */ __name(() => HEADERS_VERCEL_CACHE_TAGS, "HEADERS_VERCEL_CACHE_TAGS"),
      HEADERS_VERCEL_REVALIDATE: /* @__PURE__ */ __name(() => HEADERS_VERCEL_REVALIDATE, "HEADERS_VERCEL_REVALIDATE"),
      PkgCacheState: /* @__PURE__ */ __name(() => PkgCacheState, "PkgCacheState"),
      getCache: /* @__PURE__ */ __name(() => getCache2, "getCache")
    });
    module2.exports = __toCommonJS2(cache_exports);
    var import_get_context = require_get_context();
    var import_in_memory_cache = require_in_memory_cache();
    var import_build_client = require_build_client();
    var defaultKeyHashFunction = /* @__PURE__ */ __name((key) => {
      let hash2 = 5381;
      for (let i2 = 0; i2 < key.length; i2++) {
        hash2 = hash2 * 33 ^ key.charCodeAt(i2);
      }
      return (hash2 >>> 0).toString(16);
    }, "defaultKeyHashFunction");
    var defaultNamespaceSeparator = "$";
    var inMemoryCacheInstance = null;
    var buildCacheInstance = null;
    var getCache2 = /* @__PURE__ */ __name((cacheOptions) => {
      const resolveCache = /* @__PURE__ */ __name(() => {
        let cache;
        if ((0, import_get_context.getContext)().cache) {
          cache = (0, import_get_context.getContext)().cache;
        } else {
          cache = getCacheImplementation(process.env.SUSPENSE_CACHE_DEBUG === "true");
        }
        return cache;
      }, "resolveCache");
      return wrapWithKeyTransformation(resolveCache, createKeyTransformer(cacheOptions));
    }, "getCache");
    function createKeyTransformer(cacheOptions) {
      const hashFunction = cacheOptions?.keyHashFunction || defaultKeyHashFunction;
      return (key) => {
        if (!cacheOptions?.namespace) return hashFunction(key);
        const separator = cacheOptions.namespaceSeparator || defaultNamespaceSeparator;
        return `${cacheOptions.namespace}${separator}${hashFunction(key)}`;
      };
    }
    __name(createKeyTransformer, "createKeyTransformer");
    function wrapWithKeyTransformation(resolveCache, makeKey) {
      return {
        get: /* @__PURE__ */ __name((key) => {
          return resolveCache().get(makeKey(key));
        }, "get"),
        set: /* @__PURE__ */ __name((key, value, options) => {
          return resolveCache().set(makeKey(key), value, options);
        }, "set"),
        delete: /* @__PURE__ */ __name((key) => {
          return resolveCache().delete(makeKey(key));
        }, "delete"),
        expireTag: /* @__PURE__ */ __name((tag) => {
          return resolveCache().expireTag(tag);
        }, "expireTag")
      };
    }
    __name(wrapWithKeyTransformation, "wrapWithKeyTransformation");
    var warnedCacheUnavailable = false;
    function getCacheImplementation(debug2) {
      if (!inMemoryCacheInstance) {
        inMemoryCacheInstance = new import_in_memory_cache.InMemoryCache();
      }
      if (process.env.RUNTIME_CACHE_DISABLE_BUILD_CACHE === "true") {
        debug2 && console.log("Using InMemoryCache as build cache is disabled");
        return inMemoryCacheInstance;
      }
      const { RUNTIME_CACHE_ENDPOINT, RUNTIME_CACHE_HEADERS } = process.env;
      if (debug2) {
        console.log("Runtime cache environment variables:", {
          RUNTIME_CACHE_ENDPOINT,
          RUNTIME_CACHE_HEADERS
        });
      }
      if (!RUNTIME_CACHE_ENDPOINT || !RUNTIME_CACHE_HEADERS) {
        if (!warnedCacheUnavailable) {
          console.warn("Runtime Cache unavailable in this environment. Falling back to in-memory cache.");
          warnedCacheUnavailable = true;
        }
        return inMemoryCacheInstance;
      }
      if (!buildCacheInstance) {
        let parsedHeaders = {};
        try {
          parsedHeaders = JSON.parse(RUNTIME_CACHE_HEADERS);
        } catch (e2) {
          console.error("Failed to parse RUNTIME_CACHE_HEADERS:", e2);
          return inMemoryCacheInstance;
        }
        let timeout = 500;
        if (process.env.RUNTIME_CACHE_TIMEOUT) {
          const parsed = parseInt(process.env.RUNTIME_CACHE_TIMEOUT, 10);
          if (!isNaN(parsed) && parsed > 0) {
            timeout = parsed;
          } else {
            console.warn(`Invalid RUNTIME_CACHE_TIMEOUT value: "${process.env.RUNTIME_CACHE_TIMEOUT}". Using default: ${timeout}ms`);
          }
        }
        buildCacheInstance = new import_build_client.BuildCache({
          endpoint: RUNTIME_CACHE_ENDPOINT,
          headers: parsedHeaders,
          onError: /* @__PURE__ */ __name((error45) => console.error(error45), "onError"),
          timeout
        });
      }
      return buildCacheInstance;
    }
    __name(getCacheImplementation, "getCacheImplementation");
    var PkgCacheState = /* @__PURE__ */ ((PkgCacheState2) => {
      PkgCacheState2["Fresh"] = "fresh";
      PkgCacheState2["Stale"] = "stale";
      PkgCacheState2["Expired"] = "expired";
      PkgCacheState2["NotFound"] = "notFound";
      PkgCacheState2["Error"] = "error";
      return PkgCacheState2;
    })(PkgCacheState || {});
    var HEADERS_VERCEL_CACHE_STATE = "x-vercel-cache-state";
    var HEADERS_VERCEL_REVALIDATE = "x-vercel-revalidate";
    var HEADERS_VERCEL_CACHE_TAGS = "x-vercel-cache-tags";
    var HEADERS_VERCEL_CACHE_ITEM_NAME = "x-vercel-cache-item-name";
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/db-connections/index.js
var require_db_connections = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/db-connections/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var db_connections_exports = {};
    __export2(db_connections_exports, {
      attachDatabasePool: /* @__PURE__ */ __name(() => attachDatabasePool2, "attachDatabasePool"),
      experimental_attachDatabasePool: /* @__PURE__ */ __name(() => experimental_attachDatabasePool2, "experimental_attachDatabasePool")
    });
    module2.exports = __toCommonJS2(db_connections_exports);
    var import_get_context = require_get_context();
    var DEBUG = !!process.env.DEBUG;
    function getIdleTimeout(dbPool) {
      if ("options" in dbPool && dbPool.options) {
        if ("idleTimeoutMillis" in dbPool.options) {
          return typeof dbPool.options.idleTimeoutMillis === "number" ? dbPool.options.idleTimeoutMillis : 1e4;
        }
        if ("maxIdleTimeMS" in dbPool.options) {
          return typeof dbPool.options.maxIdleTimeMS === "number" ? dbPool.options.maxIdleTimeMS : 0;
        }
        if ("status" in dbPool) {
          return 5e3;
        }
        if ("connect" in dbPool && "execute" in dbPool) {
          return 3e4;
        }
      }
      if ("config" in dbPool && dbPool.config) {
        if ("connectionConfig" in dbPool.config && dbPool.config.connectionConfig) {
          return dbPool.config.connectionConfig.idleTimeout || 6e4;
        }
        if ("idleTimeout" in dbPool.config) {
          return typeof dbPool.config.idleTimeout === "number" ? dbPool.config.idleTimeout : 6e4;
        }
      }
      if ("poolTimeout" in dbPool) {
        return typeof dbPool.poolTimeout === "number" ? dbPool.poolTimeout : 6e4;
      }
      if ("idleTimeout" in dbPool) {
        return typeof dbPool.idleTimeout === "number" ? dbPool.idleTimeout : 0;
      }
      return 1e4;
    }
    __name(getIdleTimeout, "getIdleTimeout");
    var idleTimeout = null;
    var idleTimeoutResolve = /* @__PURE__ */ __name(() => {
    }, "idleTimeoutResolve");
    var bootTime = Date.now();
    var maximumDuration = 15 * 60 * 1e3 - 1e3;
    function waitUntilIdleTimeout(dbPool) {
      if (!process.env.VERCEL_URL || // This is not set during builds where we don't need to wait for idle connections using the mechanism
      !process.env.VERCEL_REGION) {
        return;
      }
      if (idleTimeout) {
        clearTimeout(idleTimeout);
        idleTimeoutResolve();
      }
      const promise2 = new Promise((resolve) => {
        idleTimeoutResolve = resolve;
      });
      const waitTime = Math.min(getIdleTimeout(dbPool) + 100, maximumDuration - (Date.now() - bootTime));
      idleTimeout = setTimeout(() => {
        idleTimeoutResolve?.();
        if (DEBUG) {
          console.log("Database pool idle timeout reached. Releasing connections.");
        }
      }, waitTime);
      const requestContext = (0, import_get_context.getContext)();
      if (requestContext?.waitUntil) {
        requestContext.waitUntil(promise2);
      } else {
        console.warn("Pool release event triggered outside of request scope.");
      }
    }
    __name(waitUntilIdleTimeout, "waitUntilIdleTimeout");
    function attachDatabasePool2(dbPool) {
      if (idleTimeout) {
        idleTimeoutResolve?.();
        clearTimeout(idleTimeout);
      }
      if ("on" in dbPool && dbPool.on && "options" in dbPool && "idleTimeoutMillis" in dbPool.options) {
        const pgPool = dbPool;
        pgPool.on("release", () => {
          if (DEBUG) {
            console.log("Client released from pool");
          }
          waitUntilIdleTimeout(dbPool);
        });
        return;
      } else if ("on" in dbPool && dbPool.on && "config" in dbPool && dbPool.config && "connectionConfig" in dbPool.config) {
        const mysqlPool = dbPool;
        mysqlPool.on("release", () => {
          if (DEBUG) {
            console.log("MySQL client released from pool");
          }
          waitUntilIdleTimeout(dbPool);
        });
        return;
      } else if ("on" in dbPool && dbPool.on && "config" in dbPool && dbPool.config && "idleTimeout" in dbPool.config) {
        const mysql2Pool = dbPool;
        mysql2Pool.on("release", () => {
          if (DEBUG) {
            console.log("MySQL2/MariaDB client released from pool");
          }
          waitUntilIdleTimeout(dbPool);
        });
        return;
      }
      if ("on" in dbPool && dbPool.on && "options" in dbPool && dbPool.options && "maxIdleTimeMS" in dbPool.options) {
        const mongoPool = dbPool;
        mongoPool.on("connectionCheckedOut", () => {
          if (DEBUG) {
            console.log("MongoDB connection checked out");
          }
          waitUntilIdleTimeout(dbPool);
        });
        return;
      }
      if ("on" in dbPool && dbPool.on && "options" in dbPool && dbPool.options && "socket" in dbPool.options) {
        const redisPool = dbPool;
        redisPool.on("end", () => {
          if (DEBUG) {
            console.log("Redis connection ended");
          }
          waitUntilIdleTimeout(dbPool);
        });
        return;
      }
      throw new Error("Unsupported database pool type");
    }
    __name(attachDatabasePool2, "attachDatabasePool");
    var experimental_attachDatabasePool2 = attachDatabasePool2;
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/purge/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/purge/types.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var types_exports = {};
    module2.exports = __toCommonJS2(types_exports);
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/purge/index.js
var require_purge = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/purge/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __reExport = /* @__PURE__ */ __name((target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default")), "__reExport");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var purge_exports = {};
    __export2(purge_exports, {
      dangerouslyDeleteByTag: /* @__PURE__ */ __name(() => dangerouslyDeleteByTag2, "dangerouslyDeleteByTag"),
      invalidateByTag: /* @__PURE__ */ __name(() => invalidateByTag2, "invalidateByTag")
    });
    module2.exports = __toCommonJS2(purge_exports);
    var import_get_context = require_get_context();
    __reExport(purge_exports, require_types(), module2.exports);
    var invalidateByTag2 = /* @__PURE__ */ __name((tag) => {
      const api = (0, import_get_context.getContext)().purge;
      if (api) {
        return api.invalidateByTag(tag);
      }
      return Promise.resolve();
    }, "invalidateByTag");
    var dangerouslyDeleteByTag2 = /* @__PURE__ */ __name((tag, options) => {
      const api = (0, import_get_context.getContext)().purge;
      if (api) {
        return api.dangerouslyDeleteByTag(tag, options);
      }
      return Promise.resolve();
    }, "dangerouslyDeleteByTag");
  }
});

// node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/index.js
var require_functions = __commonJS({
  "node_modules/.pnpm/@vercel+functions@3.1.4_@aws-sdk+credential-provider-web-identity@3.609.0_@aws-sdk+client-sts@3.917.0_/node_modules/@vercel/functions/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var src_exports = {};
    __export2(src_exports, {
      attachDatabasePool: /* @__PURE__ */ __name(() => import_db_connections.attachDatabasePool, "attachDatabasePool"),
      dangerouslyDeleteByTag: /* @__PURE__ */ __name(() => import_purge.dangerouslyDeleteByTag, "dangerouslyDeleteByTag"),
      experimental_attachDatabasePool: /* @__PURE__ */ __name(() => import_db_connections.experimental_attachDatabasePool, "experimental_attachDatabasePool"),
      geolocation: /* @__PURE__ */ __name(() => import_headers.geolocation, "geolocation"),
      getCache: /* @__PURE__ */ __name(() => import_cache.getCache, "getCache"),
      getEnv: /* @__PURE__ */ __name(() => import_get_env.getEnv, "getEnv"),
      invalidateByTag: /* @__PURE__ */ __name(() => import_purge.invalidateByTag, "invalidateByTag"),
      ipAddress: /* @__PURE__ */ __name(() => import_headers.ipAddress, "ipAddress"),
      next: /* @__PURE__ */ __name(() => import_middleware.next, "next"),
      rewrite: /* @__PURE__ */ __name(() => import_middleware.rewrite, "rewrite"),
      waitUntil: /* @__PURE__ */ __name(() => import_wait_until.waitUntil, "waitUntil")
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_headers = require_headers();
    var import_get_env = require_get_env();
    var import_wait_until = require_wait_until();
    var import_middleware = require_middleware();
    var import_cache = require_cache();
    var import_db_connections = require_db_connections();
    var import_purge = require_purge();
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/get-context.js
var require_get_context2 = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/get-context.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var get_context_exports = {};
    __export2(get_context_exports, {
      SYMBOL_FOR_REQ_CONTEXT: /* @__PURE__ */ __name(() => SYMBOL_FOR_REQ_CONTEXT, "SYMBOL_FOR_REQ_CONTEXT"),
      getContext: /* @__PURE__ */ __name(() => getContext2, "getContext")
    });
    module2.exports = __toCommonJS2(get_context_exports);
    var SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
    function getContext2() {
      const fromSymbol = globalThis;
      return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
    }
    __name(getContext2, "getContext");
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token-error.js
var require_token_error = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token-error.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var token_error_exports = {};
    __export2(token_error_exports, {
      VercelOidcTokenError: /* @__PURE__ */ __name(() => VercelOidcTokenError, "VercelOidcTokenError")
    });
    module2.exports = __toCommonJS2(token_error_exports);
    var VercelOidcTokenError = class extends Error {
      static {
        __name(this, "VercelOidcTokenError");
      }
      constructor(message, cause) {
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
      }
      toString() {
        if (this.cause) {
          return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
      }
    };
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token-io.js
var require_token_io = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token-io.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toESM2 = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
        value: mod,
        enumerable: true
      }) : target,
      mod
    )), "__toESM");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var token_io_exports = {};
    __export2(token_io_exports, {
      findRootDir: /* @__PURE__ */ __name(() => findRootDir, "findRootDir"),
      getUserDataDir: /* @__PURE__ */ __name(() => getUserDataDir, "getUserDataDir")
    });
    module2.exports = __toCommonJS2(token_io_exports);
    var import_path = __toESM2(require("path"));
    var import_fs3 = __toESM2(require("fs"));
    var import_os = __toESM2(require("os"));
    var import_token_error = require_token_error();
    function findRootDir() {
      try {
        let dir = process.cwd();
        while (dir !== import_path.default.dirname(dir)) {
          const pkgPath = import_path.default.join(dir, ".vercel");
          if (import_fs3.default.existsSync(pkgPath)) {
            return dir;
          }
          dir = import_path.default.dirname(dir);
        }
      } catch (e2) {
        throw new import_token_error.VercelOidcTokenError("Token refresh only supported in node server environments");
      }
      throw new import_token_error.VercelOidcTokenError("Unable to find root directory");
    }
    __name(findRootDir, "findRootDir");
    function getUserDataDir() {
      if (process.env.XDG_DATA_HOME) {
        return process.env.XDG_DATA_HOME;
      }
      switch (import_os.default.platform()) {
        case "darwin":
          return import_path.default.join(import_os.default.homedir(), "Library/Application Support");
        case "linux":
          return import_path.default.join(import_os.default.homedir(), ".local/share");
        case "win32":
          if (process.env.LOCALAPPDATA) {
            return process.env.LOCALAPPDATA;
          }
          return null;
        default:
          return null;
      }
    }
    __name(getUserDataDir, "getUserDataDir");
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token-util.js
var require_token_util = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token-util.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toESM2 = /* @__PURE__ */ __name((mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", {
        value: mod,
        enumerable: true
      }) : target,
      mod
    )), "__toESM");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var token_util_exports = {};
    __export2(token_util_exports, {
      assertVercelOidcTokenResponse: /* @__PURE__ */ __name(() => assertVercelOidcTokenResponse, "assertVercelOidcTokenResponse"),
      findProjectInfo: /* @__PURE__ */ __name(() => findProjectInfo, "findProjectInfo"),
      getTokenPayload: /* @__PURE__ */ __name(() => getTokenPayload, "getTokenPayload"),
      getVercelCliToken: /* @__PURE__ */ __name(() => getVercelCliToken, "getVercelCliToken"),
      getVercelDataDir: /* @__PURE__ */ __name(() => getVercelDataDir, "getVercelDataDir"),
      getVercelOidcToken: /* @__PURE__ */ __name(() => getVercelOidcToken4, "getVercelOidcToken"),
      isExpired: /* @__PURE__ */ __name(() => isExpired, "isExpired"),
      loadToken: /* @__PURE__ */ __name(() => loadToken, "loadToken"),
      saveToken: /* @__PURE__ */ __name(() => saveToken, "saveToken")
    });
    module2.exports = __toCommonJS2(token_util_exports);
    var path4 = __toESM2(require("path"));
    var fs2 = __toESM2(require("fs"));
    var import_token_error = require_token_error();
    var import_token_io = require_token_io();
    function getVercelDataDir() {
      const vercelFolder = "com.vercel.cli";
      const dataDir = (0, import_token_io.getUserDataDir)();
      if (!dataDir) {
        return null;
      }
      return path4.join(dataDir, vercelFolder);
    }
    __name(getVercelDataDir, "getVercelDataDir");
    function getVercelCliToken() {
      const dataDir = getVercelDataDir();
      if (!dataDir) {
        return null;
      }
      const tokenPath = path4.join(dataDir, "auth.json");
      if (!fs2.existsSync(tokenPath)) {
        return null;
      }
      const token = fs2.readFileSync(tokenPath, "utf8");
      if (!token) {
        return null;
      }
      return JSON.parse(token).token;
    }
    __name(getVercelCliToken, "getVercelCliToken");
    async function getVercelOidcToken4(authToken, projectId, teamId) {
      try {
        const url2 = `https://api.vercel.com/v1/projects/${projectId}/token?source=vercel-oidc-refresh${teamId ? `&teamId=${teamId}` : ""}`;
        const res = await fetch(url2, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${authToken}`
          }
        });
        if (!res.ok) {
          throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token: ${res.statusText}`);
        }
        const tokenRes = await res.json();
        assertVercelOidcTokenResponse(tokenRes);
        return tokenRes;
      } catch (e2) {
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, e2);
      }
    }
    __name(getVercelOidcToken4, "getVercelOidcToken");
    function assertVercelOidcTokenResponse(res) {
      if (!res || typeof res !== "object") {
        throw new TypeError("Expected an object");
      }
      if (!("token" in res) || typeof res.token !== "string") {
        throw new TypeError("Expected a string-valued token property");
      }
    }
    __name(assertVercelOidcTokenResponse, "assertVercelOidcTokenResponse");
    function findProjectInfo() {
      const dir = (0, import_token_io.findRootDir)();
      if (!dir) {
        throw new import_token_error.VercelOidcTokenError("Unable to find root directory");
      }
      try {
        const prjPath = path4.join(dir, ".vercel", "project.json");
        if (!fs2.existsSync(prjPath)) {
          throw new import_token_error.VercelOidcTokenError("project.json not found");
        }
        const prj = JSON.parse(fs2.readFileSync(prjPath, "utf8"));
        if (typeof prj.projectId !== "string" && typeof prj.orgId !== "string") {
          throw new TypeError("Expected a string-valued projectId property");
        }
        return {
          projectId: prj.projectId,
          teamId: prj.orgId
        };
      } catch (e2) {
        throw new import_token_error.VercelOidcTokenError(`Unable to find project ID`, e2);
      }
    }
    __name(findProjectInfo, "findProjectInfo");
    function saveToken(token, projectId) {
      try {
        const dir = (0, import_token_io.getUserDataDir)();
        if (!dir) {
          throw new import_token_error.VercelOidcTokenError("Unable to find user data directory");
        }
        const tokenPath = path4.join(dir, "com.vercel.token", `${projectId}.json`);
        const tokenJson = JSON.stringify(token);
        fs2.mkdirSync(path4.dirname(tokenPath), {
          mode: 432,
          recursive: true
        });
        fs2.writeFileSync(tokenPath, tokenJson);
        fs2.chmodSync(tokenPath, 432);
        return;
      } catch (e2) {
        throw new import_token_error.VercelOidcTokenError(`Failed to save token`, e2);
      }
    }
    __name(saveToken, "saveToken");
    function loadToken(projectId) {
      try {
        const dir = (0, import_token_io.getUserDataDir)();
        if (!dir) {
          return null;
        }
        const tokenPath = path4.join(dir, "com.vercel.token", `${projectId}.json`);
        if (!fs2.existsSync(tokenPath)) {
          return null;
        }
        const token = JSON.parse(fs2.readFileSync(tokenPath, "utf8"));
        assertVercelOidcTokenResponse(token);
        return token;
      } catch (e2) {
        throw new import_token_error.VercelOidcTokenError(`Failed to load token`, e2);
      }
    }
    __name(loadToken, "loadToken");
    function getTokenPayload(token) {
      const tokenParts = token.split(".");
      if (tokenParts.length !== 3) {
        throw new import_token_error.VercelOidcTokenError("Invalid token");
      }
      const base643 = tokenParts[1].replace(/-/g, "+").replace(/_/g, "/");
      const padded = base643.padEnd(base643.length + (4 - base643.length % 4) % 4, "=");
      return JSON.parse(Buffer.from(padded, "base64").toString("utf8"));
    }
    __name(getTokenPayload, "getTokenPayload");
    var TIME_15_MINUTES_IN_MS = 15 * 60 * 1e3;
    function isExpired(token) {
      return token.exp * 1e3 < Date.now() + TIME_15_MINUTES_IN_MS;
    }
    __name(isExpired, "isExpired");
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token.js
var require_token = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/token.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var token_exports = {};
    __export2(token_exports, {
      refreshToken: /* @__PURE__ */ __name(() => refreshToken, "refreshToken")
    });
    module2.exports = __toCommonJS2(token_exports);
    var import_token_error = require_token_error();
    var import_token_util = require_token_util();
    async function refreshToken() {
      const { projectId, teamId } = (0, import_token_util.findProjectInfo)();
      let maybeToken = (0, import_token_util.loadToken)(projectId);
      if (!maybeToken || (0, import_token_util.isExpired)((0, import_token_util.getTokenPayload)(maybeToken.token))) {
        const authToken = (0, import_token_util.getVercelCliToken)();
        if (!authToken) {
          throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token: login to vercel cli");
        }
        if (!projectId) {
          throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token: project id not found");
        }
        maybeToken = await (0, import_token_util.getVercelOidcToken)(authToken, projectId, teamId);
        if (!maybeToken) {
          throw new import_token_error.VercelOidcTokenError("Failed to refresh OIDC token");
        }
        (0, import_token_util.saveToken)(maybeToken, projectId);
      }
      process.env.VERCEL_OIDC_TOKEN = maybeToken.token;
      return;
    }
    __name(refreshToken, "refreshToken");
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js
var require_get_vercel_oidc_token = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var get_vercel_oidc_token_exports = {};
    __export2(get_vercel_oidc_token_exports, {
      getVercelOidcToken: /* @__PURE__ */ __name(() => getVercelOidcToken4, "getVercelOidcToken"),
      getVercelOidcTokenSync: /* @__PURE__ */ __name(() => getVercelOidcTokenSync2, "getVercelOidcTokenSync")
    });
    module2.exports = __toCommonJS2(get_vercel_oidc_token_exports);
    var import_get_context = require_get_context2();
    var import_token_error = require_token_error();
    async function getVercelOidcToken4() {
      let token = "";
      let err;
      try {
        token = getVercelOidcTokenSync2();
      } catch (error45) {
        err = error45;
      }
      try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
          await Promise.resolve().then(() => __toESM(require_token_util())),
          await Promise.resolve().then(() => __toESM(require_token()))
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
          await refreshToken();
          token = getVercelOidcTokenSync2();
        }
      } catch (error45) {
        if (err?.message && error45 instanceof Error) {
          error45.message = `${err.message}
${error45.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error45);
      }
      return token;
    }
    __name(getVercelOidcToken4, "getVercelOidcToken");
    function getVercelOidcTokenSync2() {
      const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
      if (!token) {
        throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
      }
      return token;
    }
    __name(getVercelOidcTokenSync2, "getVercelOidcTokenSync");
  }
});

// node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@vercel+oidc@3.0.3/node_modules/@vercel/oidc/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = /* @__PURE__ */ __name((target, all) => {
      for (var name in all) __defProp2(target, name, {
        get: all[name],
        enumerable: true
      });
    }, "__export");
    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from)) if (!__hasOwnProp2.call(to, key) && key !== except) __defProp2(to, key, {
          get: /* @__PURE__ */ __name(() => from[key], "get"),
          enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable
        });
      }
      return to;
    }, "__copyProps");
    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", {
      value: true
    }), mod), "__toCommonJS");
    var src_exports = {};
    __export2(src_exports, {
      getContext: /* @__PURE__ */ __name(() => import_get_context.getContext, "getContext"),
      getVercelOidcToken: /* @__PURE__ */ __name(() => import_get_vercel_oidc_token.getVercelOidcToken, "getVercelOidcToken"),
      getVercelOidcTokenSync: /* @__PURE__ */ __name(() => import_get_vercel_oidc_token.getVercelOidcTokenSync, "getVercelOidcTokenSync")
    });
    module2.exports = __toCommonJS2(src_exports);
    var import_get_vercel_oidc_token = require_get_vercel_oidc_token();
    var import_get_context = require_get_context2();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/platform/node/index.js
var require_node = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/platform/node/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o2, k22, {
        enumerable: true,
        get: /* @__PURE__ */ __name(function() {
          return m2[k2];
        }, "get")
      });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports1) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p2)) __createBinding(exports1, m2, p2);
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    __exportStar(require_globalThis(), exports2);
  }
});

// ../../node_modules/@opentelemetry/api/build/src/platform/index.js
var require_platform = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/platform/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o2, k22, {
        enumerable: true,
        get: /* @__PURE__ */ __name(function() {
          return m2[k2];
        }, "get")
      });
    } : function(o2, m2, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o2[k22] = m2[k2];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m2, exports1) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p2)) __createBinding(exports1, m2, p2);
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    __exportStar(require_node(), exports2);
  }
});

// ../../node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.9.0";
  }
});

// ../../node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/internal/semver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isCompatible = exports2._makeCompatibilityCheck = void 0;
    var version_1 = require_version();
    var re2 = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      const acceptedVersions = /* @__PURE__ */ new Set([
        ownVersion
      ]);
      const rejectedVersions = /* @__PURE__ */ new Set();
      const myVersionMatch = ownVersion.match(re2);
      if (!myVersionMatch) {
        return () => false;
      }
      const ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        }, "isExactmatch");
      }
      function _reject(v2) {
        rejectedVersions.add(v2);
        return false;
      }
      __name(_reject, "_reject");
      function _accept(v2) {
        acceptedVersions.add(v2);
        return true;
      }
      __name(_accept, "_accept");
      return /* @__PURE__ */ __name(function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        const globalVersionMatch = globalVersion.match(re2);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        const globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }, "isCompatible");
    }
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    exports2._makeCompatibilityCheck = _makeCompatibilityCheck;
    exports2.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
  }
});

// ../../node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/internal/global-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.unregisterGlobal = exports2.getGlobal = exports2.registerGlobal = void 0;
    var platform_1 = require_platform();
    var version_1 = require_version();
    var semver_1 = require_semver();
    var major = version_1.VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
    var _global = platform_1._globalThis;
    function registerGlobal(type, instance, diag, allowOverride = false) {
      var _a;
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: version_1.VERSION
      };
      if (!allowOverride && api[type]) {
        const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type}`);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== version_1.VERSION) {
        const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${version_1.VERSION}`);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type] = instance;
      diag.debug(`@opentelemetry/api: Registered a global for ${type} v${version_1.VERSION}.`);
      return true;
    }
    __name(registerGlobal, "registerGlobal");
    exports2.registerGlobal = registerGlobal;
    function getGlobal(type) {
      var _a, _b;
      const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
        return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
    }
    __name(getGlobal, "getGlobal");
    exports2.getGlobal = getGlobal;
    function unregisterGlobal(type, diag) {
      diag.debug(`@opentelemetry/api: Unregistering a global for ${type} v${version_1.VERSION}.`);
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type];
      }
    }
    __name(unregisterGlobal, "unregisterGlobal");
    exports2.unregisterGlobal = unregisterGlobal;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DiagComponentLogger = void 0;
    var global_utils_1 = require_global_utils();
    var DiagComponentLogger = class {
      static {
        __name(this, "DiagComponentLogger");
      }
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args) {
        return logProxy("debug", this._namespace, args);
      }
      error(...args) {
        return logProxy("error", this._namespace, args);
      }
      info(...args) {
        return logProxy("info", this._namespace, args);
      }
      warn(...args) {
        return logProxy("warn", this._namespace, args);
      }
      verbose(...args) {
        return logProxy("verbose", this._namespace, args);
      }
    };
    exports2.DiagComponentLogger = DiagComponentLogger;
    function logProxy(funcName, namespace, args) {
      const logger = (0, global_utils_1.getGlobal)("diag");
      if (!logger) {
        return;
      }
      args.unshift(namespace);
      return logger[funcName](...args);
    }
    __name(logProxy, "logProxy");
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types2 = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/diag/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DiagLogLevel = void 0;
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel = exports2.DiagLogLevel || (exports2.DiagLogLevel = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createLogLevelDiagLogger = void 0;
    var types_1 = require_types2();
    function createLogLevelDiagLogger(maxLevel, logger) {
      if (maxLevel < types_1.DiagLogLevel.NONE) {
        maxLevel = types_1.DiagLogLevel.NONE;
      } else if (maxLevel > types_1.DiagLogLevel.ALL) {
        maxLevel = types_1.DiagLogLevel.ALL;
      }
      logger = logger || {};
      function _filterFunc(funcName, theLevel) {
        const theFunc = logger[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger);
        }
        return function() {
        };
      }
      __name(_filterFunc, "_filterFunc");
      return {
        error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
        warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
        info: _filterFunc("info", types_1.DiagLogLevel.INFO),
        debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
      };
    }
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
    exports2.createLogLevelDiagLogger = createLogLevelDiagLogger;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/api/diag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DiagAPI = void 0;
    var ComponentLogger_1 = require_ComponentLogger();
    var logLevelLogger_1 = require_logLevelLogger();
    var types_1 = require_types2();
    var global_utils_1 = require_global_utils();
    var API_NAME = "diag";
    var DiagAPI = class _DiagAPI {
      static {
        __name(this, "DiagAPI");
      }
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
        function _logProxy(funcName) {
          return function(...args) {
            const logger = (0, global_utils_1.getGlobal)("diag");
            if (!logger) return;
            return logger[funcName](...args);
          };
        }
        __name(_logProxy, "_logProxy");
        const self2 = this;
        const setLogger = /* @__PURE__ */ __name((logger, optionsOrLogLevel = {
          logLevel: types_1.DiagLogLevel.INFO
        }) => {
          var _a, _b, _c;
          if (logger === self2) {
            const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          const oldLogger = (0, global_utils_1.getGlobal)("diag");
          const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            const stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn(`Current logger will be overwritten from ${stack}`);
            newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
          }
          return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
        }, "setLogger");
        self2.setLogger = setLogger;
        self2.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
        };
        self2.createComponentLogger = (options) => {
          return new ComponentLogger_1.DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
        if (!this._instance) {
          this._instance = new _DiagAPI();
        }
        return this._instance;
      }
    };
    exports2.DiagAPI = DiagAPI;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BaggageImpl = void 0;
    var BaggageImpl = class _BaggageImpl {
      static {
        __name(this, "BaggageImpl");
      }
      constructor(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      getEntry(key) {
        const entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      }
      getAllEntries() {
        return Array.from(this._entries.entries()).map(([k2, v2]) => [
          k2,
          v2
        ]);
      }
      setEntry(key, entry) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      }
      removeEntry(key) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      }
      removeEntries(...keys) {
        const newBaggage = new _BaggageImpl(this._entries);
        for (const key of keys) {
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      }
      clear() {
        return new _BaggageImpl();
      }
    };
    exports2.BaggageImpl = BaggageImpl;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.baggageEntryMetadataSymbol = void 0;
    exports2.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/baggage/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.baggageEntryMetadataFromString = exports2.createBaggage = void 0;
    var diag_1 = require_diag();
    var baggage_impl_1 = require_baggage_impl();
    var symbol_1 = require_symbol();
    var diag = diag_1.DiagAPI.instance();
    function createBaggage(entries = {}) {
      return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries)));
    }
    __name(createBaggage, "createBaggage");
    exports2.createBaggage = createBaggage;
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
        str = "";
      }
      return {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString() {
          return str;
        }
      };
    }
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
    exports2.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/context/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ROOT_CONTEXT = exports2.createContextKey = void 0;
    function createContextKey(description) {
      return Symbol.for(description);
    }
    __name(createContextKey, "createContextKey");
    exports2.createContextKey = createContextKey;
    var BaseContext = class _BaseContext {
      static {
        __name(this, "BaseContext");
      }
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
        const self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = (key) => self2._currentContext.get(key);
        self2.setValue = (key, value) => {
          const context = new _BaseContext(self2._currentContext);
          context._currentContext.set(key, value);
          return context;
        };
        self2.deleteValue = (key) => {
          const context = new _BaseContext(self2._currentContext);
          context._currentContext.delete(key);
          return context;
        };
      }
    };
    exports2.ROOT_CONTEXT = new BaseContext();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DiagConsoleLogger = void 0;
    var consoleMap = [
      {
        n: "error",
        c: "error"
      },
      {
        n: "warn",
        c: "warn"
      },
      {
        n: "info",
        c: "info"
      },
      {
        n: "debug",
        c: "debug"
      },
      {
        n: "verbose",
        c: "trace"
      }
    ];
    var DiagConsoleLogger = class {
      static {
        __name(this, "DiagConsoleLogger");
      }
      constructor() {
        function _consoleFunc(funcName) {
          return function(...args) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (let i2 = 0; i2 < consoleMap.length; i2++) {
          this[consoleMap[i2].n] = _consoleFunc(consoleMap[i2].c);
        }
      }
    };
    exports2.DiagConsoleLogger = DiagConsoleLogger;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createNoopMeter = exports2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports2.NOOP_OBSERVABLE_GAUGE_METRIC = exports2.NOOP_OBSERVABLE_COUNTER_METRIC = exports2.NOOP_UP_DOWN_COUNTER_METRIC = exports2.NOOP_HISTOGRAM_METRIC = exports2.NOOP_GAUGE_METRIC = exports2.NOOP_COUNTER_METRIC = exports2.NOOP_METER = exports2.NoopObservableUpDownCounterMetric = exports2.NoopObservableGaugeMetric = exports2.NoopObservableCounterMetric = exports2.NoopObservableMetric = exports2.NoopHistogramMetric = exports2.NoopGaugeMetric = exports2.NoopUpDownCounterMetric = exports2.NoopCounterMetric = exports2.NoopMetric = exports2.NoopMeter = void 0;
    var NoopMeter = class {
      static {
        __name(this, "NoopMeter");
      }
      constructor() {
      }
      /**
       * @see {@link Meter.createGauge}
       */
      createGauge(_name, _options) {
        return exports2.NOOP_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
        return exports2.NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
        return exports2.NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
        return exports2.NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
        return exports2.NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
        return exports2.NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
        return exports2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) {
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) {
      }
    };
    exports2.NoopMeter = NoopMeter;
    var NoopMetric = class {
      static {
        __name(this, "NoopMetric");
      }
    };
    exports2.NoopMetric = NoopMetric;
    var NoopCounterMetric = class extends NoopMetric {
      static {
        __name(this, "NoopCounterMetric");
      }
      add(_value, _attributes) {
      }
    };
    exports2.NoopCounterMetric = NoopCounterMetric;
    var NoopUpDownCounterMetric = class extends NoopMetric {
      static {
        __name(this, "NoopUpDownCounterMetric");
      }
      add(_value, _attributes) {
      }
    };
    exports2.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
    var NoopGaugeMetric = class extends NoopMetric {
      static {
        __name(this, "NoopGaugeMetric");
      }
      record(_value, _attributes) {
      }
    };
    exports2.NoopGaugeMetric = NoopGaugeMetric;
    var NoopHistogramMetric = class extends NoopMetric {
      static {
        __name(this, "NoopHistogramMetric");
      }
      record(_value, _attributes) {
      }
    };
    exports2.NoopHistogramMetric = NoopHistogramMetric;
    var NoopObservableMetric = class {
      static {
        __name(this, "NoopObservableMetric");
      }
      addCallback(_callback) {
      }
      removeCallback(_callback) {
      }
    };
    exports2.NoopObservableMetric = NoopObservableMetric;
    var NoopObservableCounterMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableCounterMetric");
      }
    };
    exports2.NoopObservableCounterMetric = NoopObservableCounterMetric;
    var NoopObservableGaugeMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableGaugeMetric");
      }
    };
    exports2.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
    var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableUpDownCounterMetric");
      }
    };
    exports2.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
    exports2.NOOP_METER = new NoopMeter();
    exports2.NOOP_COUNTER_METRIC = new NoopCounterMetric();
    exports2.NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    exports2.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    exports2.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    exports2.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    exports2.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    exports2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    function createNoopMeter() {
      return exports2.NOOP_METER;
    }
    __name(createNoopMeter, "createNoopMeter");
    exports2.createNoopMeter = createNoopMeter;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/metrics/Metric.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ValueType = void 0;
    var ValueType;
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType = exports2.ValueType || (exports2.ValueType = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.defaultTextMapSetter = exports2.defaultTextMapGetter = void 0;
    exports2.defaultTextMapGetter = {
      get(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    exports2.defaultTextMapSetter = {
      set(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// ../../node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoopContextManager = void 0;
    var context_1 = require_context();
    var NoopContextManager = class {
      static {
        __name(this, "NoopContextManager");
      }
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      bind(_context, target) {
        return target;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
    exports2.NoopContextManager = NoopContextManager;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/api/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ContextAPI = void 0;
    var NoopContextManager_1 = require_NoopContextManager();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
    var ContextAPI = class _ContextAPI {
      static {
        __name(this, "ContextAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Context API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _ContextAPI();
        }
        return this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
        return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context, fn, thisArg, ...args) {
        return this._getContextManager().with(context, fn, thisArg, ...args);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context, target) {
        return this._getContextManager().bind(context, target);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
        this._getContextManager().disable();
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports2.ContextAPI = ContextAPI;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/trace_flags.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TraceFlags = void 0;
    var TraceFlags;
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags = exports2.TraceFlags || (exports2.TraceFlags = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.INVALID_SPAN_CONTEXT = exports2.INVALID_TRACEID = exports2.INVALID_SPANID = void 0;
    var trace_flags_1 = require_trace_flags();
    exports2.INVALID_SPANID = "0000000000000000";
    exports2.INVALID_TRACEID = "00000000000000000000000000000000";
    exports2.INVALID_SPAN_CONTEXT = {
      traceId: exports2.INVALID_TRACEID,
      spanId: exports2.INVALID_SPANID,
      traceFlags: trace_flags_1.TraceFlags.NONE
    };
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NonRecordingSpan = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan = class {
      static {
        __name(this, "NonRecordingSpan");
      }
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
        return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
        return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
        return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
        return this;
      }
      addLink(_link) {
        return this;
      }
      addLinks(_links) {
        return this;
      }
      // By default does nothing
      setStatus(_status) {
        return this;
      }
      // By default does nothing
      updateName(_name) {
        return this;
      }
      // By default does nothing
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return false;
      }
      // By default does nothing
      recordException(_exception, _time) {
      }
    };
    exports2.NonRecordingSpan = NonRecordingSpan;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/context-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getSpanContext = exports2.setSpanContext = exports2.deleteSpan = exports2.setSpan = exports2.getActiveSpan = exports2.getSpan = void 0;
    var context_1 = require_context();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var context_2 = require_context2();
    var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
    function getSpan(context) {
      return context.getValue(SPAN_KEY) || void 0;
    }
    __name(getSpan, "getSpan");
    exports2.getSpan = getSpan;
    function getActiveSpan2() {
      return getSpan(context_2.ContextAPI.getInstance().active());
    }
    __name(getActiveSpan2, "getActiveSpan");
    exports2.getActiveSpan = getActiveSpan2;
    function setSpan(context, span) {
      return context.setValue(SPAN_KEY, span);
    }
    __name(setSpan, "setSpan");
    exports2.setSpan = setSpan;
    function deleteSpan(context) {
      return context.deleteValue(SPAN_KEY);
    }
    __name(deleteSpan, "deleteSpan");
    exports2.deleteSpan = deleteSpan;
    function setSpanContext(context, spanContext) {
      return setSpan(context, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
    }
    __name(setSpanContext, "setSpanContext");
    exports2.setSpanContext = setSpanContext;
    function getSpanContext(context) {
      var _a;
      return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }
    __name(getSpanContext, "getSpanContext");
    exports2.getSpanContext = getSpanContext;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.wrapSpanContext = exports2.isSpanContextValid = exports2.isValidSpanId = exports2.isValidTraceId = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
    }
    __name(isValidTraceId, "isValidTraceId");
    exports2.isValidTraceId = isValidTraceId;
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
    }
    __name(isValidSpanId, "isValidSpanId");
    exports2.isValidSpanId = isValidSpanId;
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    __name(isSpanContextValid, "isSpanContextValid");
    exports2.isSpanContextValid = isSpanContextValid;
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
    }
    __name(wrapSpanContext, "wrapSpanContext");
    exports2.wrapSpanContext = wrapSpanContext;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoopTracer = void 0;
    var context_1 = require_context2();
    var context_utils_1 = require_context_utils();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var spancontext_utils_1 = require_spancontext_utils();
    var contextApi = context_1.ContextAPI.getInstance();
    var NoopTracer = class {
      static {
        __name(this, "NoopTracer");
      }
      // startSpan starts a noop span.
      startSpan(name, options, context = contextApi.active()) {
        const root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
        const parentFromContext = context && (0, context_utils_1.getSpanContext)(context);
        if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
          return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        const span = this.startSpan(name, opts, parentContext);
        const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      }
    };
    exports2.NoopTracer = NoopTracer;
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
    __name(isSpanContext, "isSpanContext");
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProxyTracer = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NOOP_TRACER = new NoopTracer_1.NoopTracer();
    var ProxyTracer = class {
      static {
        __name(this, "ProxyTracer");
      }
      constructor(_provider, name, version2, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version2;
        this.options = options;
      }
      startSpan(name, options, context) {
        return this._getTracer().startSpan(name, options, context);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        const tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
        if (this._delegate) {
          return this._delegate;
        }
        const tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      }
    };
    exports2.ProxyTracer = ProxyTracer;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoopTracerProvider = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NoopTracerProvider = class {
      static {
        __name(this, "NoopTracerProvider");
      }
      getTracer(_name, _version, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
    exports2.NoopTracerProvider = NoopTracerProvider;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProxyTracerProvider = void 0;
    var ProxyTracer_1 = require_ProxyTracer();
    var NoopTracerProvider_1 = require_NoopTracerProvider();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
    var ProxyTracerProvider = class {
      static {
        __name(this, "ProxyTracerProvider");
      }
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name, version2, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version2, options)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version2, options);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name, version2, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version2, options);
      }
    };
    exports2.ProxyTracerProvider = ProxyTracerProvider;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports2.SamplingDecision || (exports2.SamplingDecision = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/span_kind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SpanKind = void 0;
    var SpanKind;
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind = exports2.SpanKind || (exports2.SpanKind = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/status.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SpanStatusCode = void 0;
    var SpanStatusCode;
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode = exports2.SpanStatusCode || (exports2.SpanStatusCode = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
    var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
    var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    __name(validateKey, "validateKey");
    exports2.validateKey = validateKey;
    function validateValue(value) {
      return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
    }
    __name(validateValue, "validateValue");
    exports2.validateValue = validateValue;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TraceStateImpl = void 0;
    var tracestate_validators_1 = require_tracestate_validators();
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = class _TraceStateImpl {
      static {
        __name(this, "TraceStateImpl");
      }
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState) this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN) return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i2 = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i2 !== -1) {
            const key = listMember.slice(0, i2);
            const value = listMember.slice(i2 + 1, part.length);
            if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceStateImpl = TraceStateImpl;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace/internal/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createTraceState = void 0;
    var tracestate_impl_1 = require_tracestate_impl();
    function createTraceState(rawTraceState) {
      return new tracestate_impl_1.TraceStateImpl(rawTraceState);
    }
    __name(createTraceState, "createTraceState");
    exports2.createTraceState = createTraceState;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/context-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.context = void 0;
    var context_1 = require_context2();
    exports2.context = context_1.ContextAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/diag-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.diag = void 0;
    var diag_1 = require_diag();
    exports2.diag = diag_1.DiagAPI.instance();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NOOP_METER_PROVIDER = exports2.NoopMeterProvider = void 0;
    var NoopMeter_1 = require_NoopMeter();
    var NoopMeterProvider = class {
      static {
        __name(this, "NoopMeterProvider");
      }
      getMeter(_name, _version, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
    exports2.NoopMeterProvider = NoopMeterProvider;
    exports2.NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/api/metrics.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MetricsAPI = void 0;
    var NoopMeterProvider_1 = require_NoopMeterProvider();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "metrics";
    var MetricsAPI = class _MetricsAPI {
      static {
        __name(this, "MetricsAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _MetricsAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name, version2, options) {
        return this.getMeterProvider().getMeter(name, version2, options);
      }
      /** Remove the global meter provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports2.MetricsAPI = MetricsAPI;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/metrics-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.metrics = void 0;
    var metrics_1 = require_metrics();
    exports2.metrics = metrics_1.MetricsAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NoopTextMapPropagator = void 0;
    var NoopTextMapPropagator = class {
      static {
        __name(this, "NoopTextMapPropagator");
      }
      /** Noop inject function does nothing */
      inject(_context, _carrier) {
      }
      /** Noop extract function does nothing and returns the input context */
      extract(context, _carrier) {
        return context;
      }
      fields() {
        return [];
      }
    };
    exports2.NoopTextMapPropagator = NoopTextMapPropagator;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.deleteBaggage = exports2.setBaggage = exports2.getActiveBaggage = exports2.getBaggage = void 0;
    var context_1 = require_context2();
    var context_2 = require_context();
    var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
    function getBaggage(context) {
      return context.getValue(BAGGAGE_KEY) || void 0;
    }
    __name(getBaggage, "getBaggage");
    exports2.getBaggage = getBaggage;
    function getActiveBaggage() {
      return getBaggage(context_1.ContextAPI.getInstance().active());
    }
    __name(getActiveBaggage, "getActiveBaggage");
    exports2.getActiveBaggage = getActiveBaggage;
    function setBaggage(context, baggage) {
      return context.setValue(BAGGAGE_KEY, baggage);
    }
    __name(setBaggage, "setBaggage");
    exports2.setBaggage = setBaggage;
    function deleteBaggage(context) {
      return context.deleteValue(BAGGAGE_KEY);
    }
    __name(deleteBaggage, "deleteBaggage");
    exports2.deleteBaggage = deleteBaggage;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/api/propagation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PropagationAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
    var TextMapPropagator_1 = require_TextMapPropagator();
    var context_helpers_1 = require_context_helpers();
    var utils_1 = require_utils();
    var diag_1 = require_diag();
    var API_NAME = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator();
    var PropagationAPI = class _PropagationAPI {
      static {
        __name(this, "PropagationAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this.createBaggage = utils_1.createBaggage;
        this.getBaggage = context_helpers_1.getBaggage;
        this.getActiveBaggage = context_helpers_1.getActiveBaggage;
        this.setBaggage = context_helpers_1.setBaggage;
        this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _PropagationAPI();
        }
        return this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
        return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
    exports2.PropagationAPI = PropagationAPI;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/propagation-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.propagation = void 0;
    var propagation_1 = require_propagation();
    exports2.propagation = propagation_1.PropagationAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/api/trace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TraceAPI = void 0;
    var global_utils_1 = require_global_utils();
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    var spancontext_utils_1 = require_spancontext_utils();
    var context_utils_1 = require_context_utils();
    var diag_1 = require_diag();
    var API_NAME = "trace";
    var TraceAPI = class _TraceAPI {
      static {
        __name(this, "TraceAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
        this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
        this.deleteSpan = context_utils_1.deleteSpan;
        this.getSpan = context_utils_1.getSpan;
        this.getActiveSpan = context_utils_1.getActiveSpan;
        this.getSpanContext = context_utils_1.getSpanContext;
        this.setSpan = context_utils_1.setSpan;
        this.setSpanContext = context_utils_1.setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _TraceAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
        const success2 = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        if (success2) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success2;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name, version2) {
        return this.getTracerProvider().getTracer(name, version2);
      }
      /** Remove the global tracer provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
    exports2.TraceAPI = TraceAPI;
  }
});

// ../../node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/trace-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.trace = void 0;
    var trace_1 = require_trace();
    exports2.trace = trace_1.TraceAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS({
  "../../node_modules/@opentelemetry/api/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.trace = exports2.propagation = exports2.metrics = exports2.diag = exports2.context = exports2.INVALID_SPAN_CONTEXT = exports2.INVALID_TRACEID = exports2.INVALID_SPANID = exports2.isValidSpanId = exports2.isValidTraceId = exports2.isSpanContextValid = exports2.createTraceState = exports2.TraceFlags = exports2.SpanStatusCode = exports2.SpanKind = exports2.SamplingDecision = exports2.ProxyTracerProvider = exports2.ProxyTracer = exports2.defaultTextMapSetter = exports2.defaultTextMapGetter = exports2.ValueType = exports2.createNoopMeter = exports2.DiagLogLevel = exports2.DiagConsoleLogger = exports2.ROOT_CONTEXT = exports2.createContextKey = exports2.baggageEntryMetadataFromString = void 0;
    var utils_1 = require_utils();
    Object.defineProperty(exports2, "baggageEntryMetadataFromString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return utils_1.baggageEntryMetadataFromString;
      }, "get")
    });
    var context_1 = require_context();
    Object.defineProperty(exports2, "createContextKey", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return context_1.createContextKey;
      }, "get")
    });
    Object.defineProperty(exports2, "ROOT_CONTEXT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return context_1.ROOT_CONTEXT;
      }, "get")
    });
    var consoleLogger_1 = require_consoleLogger();
    Object.defineProperty(exports2, "DiagConsoleLogger", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return consoleLogger_1.DiagConsoleLogger;
      }, "get")
    });
    var types_1 = require_types2();
    Object.defineProperty(exports2, "DiagLogLevel", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return types_1.DiagLogLevel;
      }, "get")
    });
    var NoopMeter_1 = require_NoopMeter();
    Object.defineProperty(exports2, "createNoopMeter", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return NoopMeter_1.createNoopMeter;
      }, "get")
    });
    var Metric_1 = require_Metric();
    Object.defineProperty(exports2, "ValueType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return Metric_1.ValueType;
      }, "get")
    });
    var TextMapPropagator_1 = require_TextMapPropagator();
    Object.defineProperty(exports2, "defaultTextMapGetter", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return TextMapPropagator_1.defaultTextMapGetter;
      }, "get")
    });
    Object.defineProperty(exports2, "defaultTextMapSetter", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return TextMapPropagator_1.defaultTextMapSetter;
      }, "get")
    });
    var ProxyTracer_1 = require_ProxyTracer();
    Object.defineProperty(exports2, "ProxyTracer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return ProxyTracer_1.ProxyTracer;
      }, "get")
    });
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    Object.defineProperty(exports2, "ProxyTracerProvider", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return ProxyTracerProvider_1.ProxyTracerProvider;
      }, "get")
    });
    var SamplingResult_1 = require_SamplingResult();
    Object.defineProperty(exports2, "SamplingDecision", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return SamplingResult_1.SamplingDecision;
      }, "get")
    });
    var span_kind_1 = require_span_kind();
    Object.defineProperty(exports2, "SpanKind", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return span_kind_1.SpanKind;
      }, "get")
    });
    var status_1 = require_status();
    Object.defineProperty(exports2, "SpanStatusCode", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return status_1.SpanStatusCode;
      }, "get")
    });
    var trace_flags_1 = require_trace_flags();
    Object.defineProperty(exports2, "TraceFlags", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return trace_flags_1.TraceFlags;
      }, "get")
    });
    var utils_2 = require_utils2();
    Object.defineProperty(exports2, "createTraceState", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return utils_2.createTraceState;
      }, "get")
    });
    var spancontext_utils_1 = require_spancontext_utils();
    Object.defineProperty(exports2, "isSpanContextValid", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return spancontext_utils_1.isSpanContextValid;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidTraceId", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return spancontext_utils_1.isValidTraceId;
      }, "get")
    });
    Object.defineProperty(exports2, "isValidSpanId", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return spancontext_utils_1.isValidSpanId;
      }, "get")
    });
    var invalid_span_constants_1 = require_invalid_span_constants();
    Object.defineProperty(exports2, "INVALID_SPANID", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return invalid_span_constants_1.INVALID_SPANID;
      }, "get")
    });
    Object.defineProperty(exports2, "INVALID_TRACEID", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return invalid_span_constants_1.INVALID_TRACEID;
      }, "get")
    });
    Object.defineProperty(exports2, "INVALID_SPAN_CONTEXT", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
      }, "get")
    });
    var context_api_1 = require_context_api();
    Object.defineProperty(exports2, "context", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return context_api_1.context;
      }, "get")
    });
    var diag_api_1 = require_diag_api();
    Object.defineProperty(exports2, "diag", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return diag_api_1.diag;
      }, "get")
    });
    var metrics_api_1 = require_metrics_api();
    Object.defineProperty(exports2, "metrics", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return metrics_api_1.metrics;
      }, "get")
    });
    var propagation_api_1 = require_propagation_api();
    Object.defineProperty(exports2, "propagation", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return propagation_api_1.propagation;
      }, "get")
    });
    var trace_api_1 = require_trace_api();
    Object.defineProperty(exports2, "trace", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return trace_api_1.trace;
      }, "get")
    });
    exports2.default = {
      context: context_api_1.context,
      diag: diag_api_1.diag,
      metrics: metrics_api_1.metrics,
      propagation: propagation_api_1.propagation,
      trace: trace_api_1.trace
    };
  }
});

// node_modules/.pnpm/jsbi@4.3.2/node_modules/jsbi/dist/jsbi-cjs.js
var require_jsbi_cjs = __commonJS({
  "node_modules/.pnpm/jsbi@4.3.2/node_modules/jsbi/dist/jsbi-cjs.js"(exports2, module2) {
    "use strict";
    var JSBI = class _JSBI extends Array {
      static {
        __name(this, "JSBI");
      }
      constructor(i2, _2) {
        if (super(i2), this.sign = _2, Object.setPrototypeOf(this, _JSBI.prototype), i2 > _JSBI.__kMaxLength) throw new RangeError("Maximum BigInt size exceeded");
      }
      static BigInt(i2) {
        var _2 = Math.floor, t2 = Number.isFinite;
        if ("number" == typeof i2) {
          if (0 === i2) return _JSBI.__zero();
          if (_JSBI.__isOneDigitInt(i2)) return 0 > i2 ? _JSBI.__oneDigit(-i2, true) : _JSBI.__oneDigit(i2, false);
          if (!t2(i2) || _2(i2) !== i2) throw new RangeError("The number " + i2 + " cannot be converted to BigInt because it is not an integer");
          return _JSBI.__fromDouble(i2);
        }
        if ("string" == typeof i2) {
          const _3 = _JSBI.__fromString(i2);
          if (null === _3) throw new SyntaxError("Cannot convert " + i2 + " to a BigInt");
          return _3;
        }
        if ("boolean" == typeof i2) return true === i2 ? _JSBI.__oneDigit(1, false) : _JSBI.__zero();
        if ("object" == typeof i2) {
          if (i2.constructor === _JSBI) return i2;
          const _3 = _JSBI.__toPrimitive(i2);
          return _JSBI.BigInt(_3);
        }
        throw new TypeError("Cannot convert " + i2 + " to a BigInt");
      }
      toDebugString() {
        const i2 = [
          "BigInt["
        ];
        for (const _2 of this) i2.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
        return i2.push("]"), i2.join("");
      }
      toString(i2 = 10) {
        if (2 > i2 || 36 < i2) throw new RangeError("toString() radix argument must be between 2 and 36");
        return 0 === this.length ? "0" : 0 == (i2 & i2 - 1) ? _JSBI.__toStringBasePowerOfTwo(this, i2) : _JSBI.__toStringGeneric(this, i2, false);
      }
      valueOf() {
        throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
      }
      static toNumber(i2) {
        const _2 = i2.length;
        if (0 === _2) return 0;
        if (1 === _2) {
          const _3 = i2.__unsignedDigit(0);
          return i2.sign ? -_3 : _3;
        }
        const t2 = i2.__digit(_2 - 1), e2 = _JSBI.__clz30(t2), n2 = 30 * _2 - e2;
        if (1024 < n2) return i2.sign ? -Infinity : 1 / 0;
        let g2 = n2 - 1, o2 = t2, s2 = _2 - 1;
        const l2 = e2 + 3;
        let r2 = 32 === l2 ? 0 : o2 << l2;
        r2 >>>= 12;
        const a2 = l2 - 12;
        let u2 = 12 <= l2 ? 0 : o2 << 20 + l2, d2 = 20 + l2;
        for (0 < a2 && 0 < s2 && (s2--, o2 = i2.__digit(s2), r2 |= o2 >>> 30 - a2, u2 = o2 << a2 + 2, d2 = a2 + 2); 0 < d2 && 0 < s2; ) s2--, o2 = i2.__digit(s2), u2 |= 30 <= d2 ? o2 << d2 - 30 : o2 >>> 30 - d2, d2 -= 30;
        const h2 = _JSBI.__decideRounding(i2, d2, s2, o2);
        if ((1 === h2 || 0 === h2 && 1 == (1 & u2)) && (u2 = u2 + 1 >>> 0, 0 === u2 && (r2++, 0 != r2 >>> 20 && (r2 = 0, g2++, 1023 < g2)))) return i2.sign ? -Infinity : 1 / 0;
        const m2 = i2.sign ? -2147483648 : 0;
        return g2 = g2 + 1023 << 20, _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntHigh] = m2 | g2 | r2, _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntLow] = u2, _JSBI.__kBitConversionDouble[0];
      }
      static unaryMinus(i2) {
        if (0 === i2.length) return i2;
        const _2 = i2.__copy();
        return _2.sign = !i2.sign, _2;
      }
      static bitwiseNot(i2) {
        return i2.sign ? _JSBI.__absoluteSubOne(i2).__trim() : _JSBI.__absoluteAddOne(i2, true);
      }
      static exponentiate(i2, _2) {
        if (_2.sign) throw new RangeError("Exponent must be positive");
        if (0 === _2.length) return _JSBI.__oneDigit(1, false);
        if (0 === i2.length) return i2;
        if (1 === i2.length && 1 === i2.__digit(0)) return i2.sign && 0 == (1 & _2.__digit(0)) ? _JSBI.unaryMinus(i2) : i2;
        if (1 < _2.length) throw new RangeError("BigInt too big");
        let t2 = _2.__unsignedDigit(0);
        if (1 === t2) return i2;
        if (t2 >= _JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
        if (1 === i2.length && 2 === i2.__digit(0)) {
          const _3 = 1 + (0 | t2 / 30), e3 = i2.sign && 0 != (1 & t2), n3 = new _JSBI(_3, e3);
          n3.__initializeDigits();
          const g2 = 1 << t2 % 30;
          return n3.__setDigit(_3 - 1, g2), n3;
        }
        let e2 = null, n2 = i2;
        for (0 != (1 & t2) && (e2 = i2), t2 >>= 1; 0 !== t2; t2 >>= 1) n2 = _JSBI.multiply(n2, n2), 0 != (1 & t2) && (null === e2 ? e2 = n2 : e2 = _JSBI.multiply(e2, n2));
        return e2;
      }
      static multiply(_2, t2) {
        if (0 === _2.length) return _2;
        if (0 === t2.length) return t2;
        let i2 = _2.length + t2.length;
        30 <= _2.__clzmsd() + t2.__clzmsd() && i2--;
        const e2 = new _JSBI(i2, _2.sign !== t2.sign);
        e2.__initializeDigits();
        for (let n2 = 0; n2 < _2.length; n2++) _JSBI.__multiplyAccumulate(t2, _2.__digit(n2), e2, n2);
        return e2.__trim();
      }
      static divide(i2, _2) {
        if (0 === _2.length) throw new RangeError("Division by zero");
        if (0 > _JSBI.__absoluteCompare(i2, _2)) return _JSBI.__zero();
        const t2 = i2.sign !== _2.sign, e2 = _2.__unsignedDigit(0);
        let n2;
        if (1 === _2.length && 32767 >= e2) {
          if (1 === e2) return t2 === i2.sign ? i2 : _JSBI.unaryMinus(i2);
          n2 = _JSBI.__absoluteDivSmall(i2, e2, null);
        } else n2 = _JSBI.__absoluteDivLarge(i2, _2, true, false);
        return n2.sign = t2, n2.__trim();
      }
      static remainder(i2, _2) {
        if (0 === _2.length) throw new RangeError("Division by zero");
        if (0 > _JSBI.__absoluteCompare(i2, _2)) return i2;
        const t2 = _2.__unsignedDigit(0);
        if (1 === _2.length && 32767 >= t2) {
          if (1 === t2) return _JSBI.__zero();
          const _3 = _JSBI.__absoluteModSmall(i2, t2);
          return 0 === _3 ? _JSBI.__zero() : _JSBI.__oneDigit(_3, i2.sign);
        }
        const e2 = _JSBI.__absoluteDivLarge(i2, _2, false, true);
        return e2.sign = i2.sign, e2.__trim();
      }
      static add(i2, _2) {
        const t2 = i2.sign;
        return t2 === _2.sign ? _JSBI.__absoluteAdd(i2, _2, t2) : 0 <= _JSBI.__absoluteCompare(i2, _2) ? _JSBI.__absoluteSub(i2, _2, t2) : _JSBI.__absoluteSub(_2, i2, !t2);
      }
      static subtract(i2, _2) {
        const t2 = i2.sign;
        return t2 === _2.sign ? 0 <= _JSBI.__absoluteCompare(i2, _2) ? _JSBI.__absoluteSub(i2, _2, t2) : _JSBI.__absoluteSub(_2, i2, !t2) : _JSBI.__absoluteAdd(i2, _2, t2);
      }
      static leftShift(i2, _2) {
        return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? _JSBI.__rightShiftByAbsolute(i2, _2) : _JSBI.__leftShiftByAbsolute(i2, _2);
      }
      static signedRightShift(i2, _2) {
        return 0 === _2.length || 0 === i2.length ? i2 : _2.sign ? _JSBI.__leftShiftByAbsolute(i2, _2) : _JSBI.__rightShiftByAbsolute(i2, _2);
      }
      static unsignedRightShift() {
        throw new TypeError("BigInts have no unsigned right shift; use >> instead");
      }
      static lessThan(i2, _2) {
        return 0 > _JSBI.__compareToBigInt(i2, _2);
      }
      static lessThanOrEqual(i2, _2) {
        return 0 >= _JSBI.__compareToBigInt(i2, _2);
      }
      static greaterThan(i2, _2) {
        return 0 < _JSBI.__compareToBigInt(i2, _2);
      }
      static greaterThanOrEqual(i2, _2) {
        return 0 <= _JSBI.__compareToBigInt(i2, _2);
      }
      static equal(_2, t2) {
        if (_2.sign !== t2.sign) return false;
        if (_2.length !== t2.length) return false;
        for (let e2 = 0; e2 < _2.length; e2++) if (_2.__digit(e2) !== t2.__digit(e2)) return false;
        return true;
      }
      static notEqual(i2, _2) {
        return !_JSBI.equal(i2, _2);
      }
      static bitwiseAnd(i2, _2) {
        var t2 = Math.max;
        if (!i2.sign && !_2.sign) return _JSBI.__absoluteAnd(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          const e2 = t2(i2.length, _2.length) + 1;
          let n2 = _JSBI.__absoluteSubOne(i2, e2);
          const g2 = _JSBI.__absoluteSubOne(_2);
          return n2 = _JSBI.__absoluteOr(n2, g2, n2), _JSBI.__absoluteAddOne(n2, true, n2).__trim();
        }
        return i2.sign && ([i2, _2] = [
          _2,
          i2
        ]), _JSBI.__absoluteAndNot(i2, _JSBI.__absoluteSubOne(_2)).__trim();
      }
      static bitwiseXor(i2, _2) {
        var t2 = Math.max;
        if (!i2.sign && !_2.sign) return _JSBI.__absoluteXor(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          const e3 = t2(i2.length, _2.length), n3 = _JSBI.__absoluteSubOne(i2, e3), g2 = _JSBI.__absoluteSubOne(_2);
          return _JSBI.__absoluteXor(n3, g2, n3).__trim();
        }
        const e2 = t2(i2.length, _2.length) + 1;
        i2.sign && ([i2, _2] = [
          _2,
          i2
        ]);
        let n2 = _JSBI.__absoluteSubOne(_2, e2);
        return n2 = _JSBI.__absoluteXor(n2, i2, n2), _JSBI.__absoluteAddOne(n2, true, n2).__trim();
      }
      static bitwiseOr(i2, _2) {
        var t2 = Math.max;
        const e2 = t2(i2.length, _2.length);
        if (!i2.sign && !_2.sign) return _JSBI.__absoluteOr(i2, _2).__trim();
        if (i2.sign && _2.sign) {
          let t3 = _JSBI.__absoluteSubOne(i2, e2);
          const n3 = _JSBI.__absoluteSubOne(_2);
          return t3 = _JSBI.__absoluteAnd(t3, n3, t3), _JSBI.__absoluteAddOne(t3, true, t3).__trim();
        }
        i2.sign && ([i2, _2] = [
          _2,
          i2
        ]);
        let n2 = _JSBI.__absoluteSubOne(_2, e2);
        return n2 = _JSBI.__absoluteAndNot(n2, i2, n2), _JSBI.__absoluteAddOne(n2, true, n2).__trim();
      }
      static asIntN(_2, t2) {
        var i2 = Math.floor;
        if (0 === t2.length) return t2;
        if (_2 = i2(_2), 0 > _2) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === _2) return _JSBI.__zero();
        if (_2 >= _JSBI.__kMaxLengthBits) return t2;
        const e2 = 0 | (_2 + 29) / 30;
        if (t2.length < e2) return t2;
        const g2 = t2.__unsignedDigit(e2 - 1), o2 = 1 << (_2 - 1) % 30;
        if (t2.length === e2 && g2 < o2) return t2;
        if (!((g2 & o2) === o2)) return _JSBI.__truncateToNBits(_2, t2);
        if (!t2.sign) return _JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, true);
        if (0 == (g2 & o2 - 1)) {
          for (let n2 = e2 - 2; 0 <= n2; n2--) if (0 !== t2.__digit(n2)) return _JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
          return t2.length === e2 && g2 === o2 ? t2 : _JSBI.__truncateToNBits(_2, t2);
        }
        return _JSBI.__truncateAndSubFromPowerOfTwo(_2, t2, false);
      }
      static asUintN(i2, _2) {
        var t2 = Math.floor;
        if (0 === _2.length) return _2;
        if (i2 = t2(i2), 0 > i2) throw new RangeError("Invalid value: not (convertible to) a safe integer");
        if (0 === i2) return _JSBI.__zero();
        if (_2.sign) {
          if (i2 > _JSBI.__kMaxLengthBits) throw new RangeError("BigInt too big");
          return _JSBI.__truncateAndSubFromPowerOfTwo(i2, _2, false);
        }
        if (i2 >= _JSBI.__kMaxLengthBits) return _2;
        const e2 = 0 | (i2 + 29) / 30;
        if (_2.length < e2) return _2;
        const g2 = i2 % 30;
        if (_2.length == e2) {
          if (0 === g2) return _2;
          const i3 = _2.__digit(e2 - 1);
          if (0 == i3 >>> g2) return _2;
        }
        return _JSBI.__truncateToNBits(i2, _2);
      }
      static ADD(i2, _2) {
        if (i2 = _JSBI.__toPrimitive(i2), _2 = _JSBI.__toPrimitive(_2), "string" == typeof i2) return "string" != typeof _2 && (_2 = _2.toString()), i2 + _2;
        if ("string" == typeof _2) return i2.toString() + _2;
        if (i2 = _JSBI.__toNumeric(i2), _2 = _JSBI.__toNumeric(_2), _JSBI.__isBigInt(i2) && _JSBI.__isBigInt(_2)) return _JSBI.add(i2, _2);
        if ("number" == typeof i2 && "number" == typeof _2) return i2 + _2;
        throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
      }
      static LT(i2, _2) {
        return _JSBI.__compare(i2, _2, 0);
      }
      static LE(i2, _2) {
        return _JSBI.__compare(i2, _2, 1);
      }
      static GT(i2, _2) {
        return _JSBI.__compare(i2, _2, 2);
      }
      static GE(i2, _2) {
        return _JSBI.__compare(i2, _2, 3);
      }
      static EQ(i2, _2) {
        for (; ; ) {
          if (_JSBI.__isBigInt(i2)) return _JSBI.__isBigInt(_2) ? _JSBI.equal(i2, _2) : _JSBI.EQ(_2, i2);
          if ("number" == typeof i2) {
            if (_JSBI.__isBigInt(_2)) return _JSBI.__equalToNumber(_2, i2);
            if ("object" != typeof _2) return i2 == _2;
            _2 = _JSBI.__toPrimitive(_2);
          } else if ("string" == typeof i2) {
            if (_JSBI.__isBigInt(_2)) return i2 = _JSBI.__fromString(i2), null !== i2 && _JSBI.equal(i2, _2);
            if ("object" != typeof _2) return i2 == _2;
            _2 = _JSBI.__toPrimitive(_2);
          } else if ("boolean" == typeof i2) {
            if (_JSBI.__isBigInt(_2)) return _JSBI.__equalToNumber(_2, +i2);
            if ("object" != typeof _2) return i2 == _2;
            _2 = _JSBI.__toPrimitive(_2);
          } else if ("symbol" == typeof i2) {
            if (_JSBI.__isBigInt(_2)) return false;
            if ("object" != typeof _2) return i2 == _2;
            _2 = _JSBI.__toPrimitive(_2);
          } else if ("object" == typeof i2) {
            if ("object" == typeof _2 && _2.constructor !== _JSBI) return i2 == _2;
            i2 = _JSBI.__toPrimitive(i2);
          } else return i2 == _2;
        }
      }
      static NE(i2, _2) {
        return !_JSBI.EQ(i2, _2);
      }
      static DataViewGetBigInt64(i2, _2, t2 = false) {
        return _JSBI.asIntN(64, _JSBI.DataViewGetBigUint64(i2, _2, t2));
      }
      static DataViewGetBigUint64(i2, _2, t2 = false) {
        const [e2, n2] = t2 ? [
          4,
          0
        ] : [
          0,
          4
        ], g2 = i2.getUint32(_2 + e2, t2), o2 = i2.getUint32(_2 + n2, t2), s2 = new _JSBI(3, false);
        return s2.__setDigit(0, 1073741823 & o2), s2.__setDigit(1, (268435455 & g2) << 2 | o2 >>> 30), s2.__setDigit(2, g2 >>> 28), s2.__trim();
      }
      static DataViewSetBigInt64(i2, _2, t2, e2 = false) {
        _JSBI.DataViewSetBigUint64(i2, _2, t2, e2);
      }
      static DataViewSetBigUint64(i2, _2, t2, e2 = false) {
        t2 = _JSBI.asUintN(64, t2);
        let n2 = 0, g2 = 0;
        if (0 < t2.length && (g2 = t2.__digit(0), 1 < t2.length)) {
          const i3 = t2.__digit(1);
          g2 |= i3 << 30, n2 = i3 >>> 2, 2 < t2.length && (n2 |= t2.__digit(2) << 28);
        }
        const [o2, s2] = e2 ? [
          4,
          0
        ] : [
          0,
          4
        ];
        i2.setUint32(_2 + o2, n2, e2), i2.setUint32(_2 + s2, g2, e2);
      }
      static __zero() {
        return new _JSBI(0, false);
      }
      static __oneDigit(i2, _2) {
        const t2 = new _JSBI(1, _2);
        return t2.__setDigit(0, i2), t2;
      }
      __copy() {
        const _2 = new _JSBI(this.length, this.sign);
        for (let t2 = 0; t2 < this.length; t2++) _2[t2] = this[t2];
        return _2;
      }
      __trim() {
        let i2 = this.length, _2 = this[i2 - 1];
        for (; 0 === _2; ) i2--, _2 = this[i2 - 1], this.pop();
        return 0 === i2 && (this.sign = false), this;
      }
      __initializeDigits() {
        for (let _2 = 0; _2 < this.length; _2++) this[_2] = 0;
      }
      static __decideRounding(i2, _2, t2, e2) {
        if (0 < _2) return -1;
        let n2;
        if (0 > _2) n2 = -_2 - 1;
        else {
          if (0 === t2) return -1;
          t2--, e2 = i2.__digit(t2), n2 = 29;
        }
        let g2 = 1 << n2;
        if (0 == (e2 & g2)) return -1;
        if (g2 -= 1, 0 != (e2 & g2)) return 1;
        for (; 0 < t2; ) if (t2--, 0 !== i2.__digit(t2)) return 1;
        return 0;
      }
      static __fromDouble(i2) {
        _JSBI.__kBitConversionDouble[0] = i2;
        const _2 = 2047 & _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntHigh] >>> 20, t2 = _2 - 1023, e2 = (0 | t2 / 30) + 1, n2 = new _JSBI(e2, 0 > i2);
        let g2 = 1048575 & _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntHigh] | 1048576, o2 = _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntLow];
        const s2 = 20, l2 = t2 % 30;
        let r2, a2 = 0;
        if (l2 < 20) {
          const i3 = s2 - l2;
          a2 = i3 + 32, r2 = g2 >>> i3, g2 = g2 << 32 - i3 | o2 >>> i3, o2 <<= 32 - i3;
        } else if (l2 === 20) a2 = 32, r2 = g2, g2 = o2, o2 = 0;
        else {
          const i3 = l2 - s2;
          a2 = 32 - i3, r2 = g2 << i3 | o2 >>> 32 - i3, g2 = o2 << i3, o2 = 0;
        }
        n2.__setDigit(e2 - 1, r2);
        for (let _3 = e2 - 2; 0 <= _3; _3--) 0 < a2 ? (a2 -= 30, r2 = g2 >>> 2, g2 = g2 << 30 | o2 >>> 2, o2 <<= 30) : r2 = 0, n2.__setDigit(_3, r2);
        return n2.__trim();
      }
      static __isWhitespace(i2) {
        return !!(13 >= i2 && 9 <= i2) || (159 >= i2 ? 32 == i2 : 131071 >= i2 ? 160 == i2 || 5760 == i2 : 196607 >= i2 ? (i2 &= 131071, 10 >= i2 || 40 == i2 || 41 == i2 || 47 == i2 || 95 == i2 || 4096 == i2) : 65279 == i2);
      }
      static __fromString(i2, _2 = 0) {
        let t2 = 0;
        const e2 = i2.length;
        let n2 = 0;
        if (n2 === e2) return _JSBI.__zero();
        let g2 = i2.charCodeAt(n2);
        for (; _JSBI.__isWhitespace(g2); ) {
          if (++n2 === e2) return _JSBI.__zero();
          g2 = i2.charCodeAt(n2);
        }
        if (43 === g2) {
          if (++n2 === e2) return null;
          g2 = i2.charCodeAt(n2), t2 = 1;
        } else if (45 === g2) {
          if (++n2 === e2) return null;
          g2 = i2.charCodeAt(n2), t2 = -1;
        }
        if (0 === _2) {
          if (_2 = 10, 48 === g2) {
            if (++n2 === e2) return _JSBI.__zero();
            if (g2 = i2.charCodeAt(n2), 88 === g2 || 120 === g2) {
              if (_2 = 16, ++n2 === e2) return null;
              g2 = i2.charCodeAt(n2);
            } else if (79 === g2 || 111 === g2) {
              if (_2 = 8, ++n2 === e2) return null;
              g2 = i2.charCodeAt(n2);
            } else if (66 === g2 || 98 === g2) {
              if (_2 = 2, ++n2 === e2) return null;
              g2 = i2.charCodeAt(n2);
            }
          }
        } else if (16 === _2 && 48 === g2) {
          if (++n2 === e2) return _JSBI.__zero();
          if (g2 = i2.charCodeAt(n2), 88 === g2 || 120 === g2) {
            if (++n2 === e2) return null;
            g2 = i2.charCodeAt(n2);
          }
        }
        if (0 != t2 && 10 !== _2) return null;
        for (; 48 === g2; ) {
          if (++n2 === e2) return _JSBI.__zero();
          g2 = i2.charCodeAt(n2);
        }
        const o2 = e2 - n2;
        let s2 = _JSBI.__kMaxBitsPerChar[_2], l2 = _JSBI.__kBitsPerCharTableMultiplier - 1;
        if (o2 > 1073741824 / s2) return null;
        const r2 = s2 * o2 + l2 >>> _JSBI.__kBitsPerCharTableShift, a2 = new _JSBI(0 | (r2 + 29) / 30, false), u2 = 10 > _2 ? _2 : 10, h2 = 10 < _2 ? _2 - 10 : 0;
        if (0 == (_2 & _2 - 1)) {
          s2 >>= _JSBI.__kBitsPerCharTableShift;
          const _3 = [], t3 = [];
          let o3 = false;
          do {
            let l3 = 0, r3 = 0;
            for (; ; ) {
              let _4;
              if (g2 - 48 >>> 0 < u2) _4 = g2 - 48;
              else if ((32 | g2) - 97 >>> 0 < h2) _4 = (32 | g2) - 87;
              else {
                o3 = true;
                break;
              }
              if (r3 += s2, l3 = l3 << s2 | _4, ++n2 === e2) {
                o3 = true;
                break;
              }
              if (g2 = i2.charCodeAt(n2), 30 < r3 + s2) break;
            }
            _3.push(l3), t3.push(r3);
          } while (!o3);
          _JSBI.__fillFromParts(a2, _3, t3);
        } else {
          a2.__initializeDigits();
          let t3 = false, o3 = 0;
          do {
            let r3 = 0, b2 = 1;
            for (; ; ) {
              let s3;
              if (g2 - 48 >>> 0 < u2) s3 = g2 - 48;
              else if ((32 | g2) - 97 >>> 0 < h2) s3 = (32 | g2) - 87;
              else {
                t3 = true;
                break;
              }
              const l3 = b2 * _2;
              if (1073741823 < l3) break;
              if (b2 = l3, r3 = r3 * _2 + s3, o3++, ++n2 === e2) {
                t3 = true;
                break;
              }
              g2 = i2.charCodeAt(n2);
            }
            l2 = 30 * _JSBI.__kBitsPerCharTableMultiplier - 1;
            const D2 = 0 | (s2 * o3 + l2 >>> _JSBI.__kBitsPerCharTableShift) / 30;
            a2.__inplaceMultiplyAdd(b2, r3, D2);
          } while (!t3);
        }
        if (n2 !== e2) {
          if (!_JSBI.__isWhitespace(g2)) return null;
          for (n2++; n2 < e2; n2++) if (g2 = i2.charCodeAt(n2), !_JSBI.__isWhitespace(g2)) return null;
        }
        return a2.sign = -1 == t2, a2.__trim();
      }
      static __fillFromParts(_2, t2, e2) {
        let n2 = 0, g2 = 0, o2 = 0;
        for (let s2 = t2.length - 1; 0 <= s2; s2--) {
          const i2 = t2[s2], l2 = e2[s2];
          g2 |= i2 << o2, o2 += l2, 30 === o2 ? (_2.__setDigit(n2++, g2), o2 = 0, g2 = 0) : 30 < o2 && (_2.__setDigit(n2++, 1073741823 & g2), o2 -= 30, g2 = i2 >>> l2 - o2);
        }
        if (0 !== g2) {
          if (n2 >= _2.length) throw new Error("implementation bug");
          _2.__setDigit(n2++, g2);
        }
        for (; n2 < _2.length; n2++) _2.__setDigit(n2, 0);
      }
      static __toStringBasePowerOfTwo(_2, i2) {
        const t2 = _2.length;
        let e2 = i2 - 1;
        e2 = (85 & e2 >>> 1) + (85 & e2), e2 = (51 & e2 >>> 2) + (51 & e2), e2 = (15 & e2 >>> 4) + (15 & e2);
        const n2 = e2, g2 = i2 - 1, o2 = _2.__digit(t2 - 1), s2 = _JSBI.__clz30(o2);
        let l2 = 0 | (30 * t2 - s2 + n2 - 1) / n2;
        if (_2.sign && l2++, 268435456 < l2) throw new Error("string too long");
        const r2 = Array(l2);
        let a2 = l2 - 1, u2 = 0, d2 = 0;
        for (let e3 = 0; e3 < t2 - 1; e3++) {
          const i3 = _2.__digit(e3), t3 = (u2 | i3 << d2) & g2;
          r2[a2--] = _JSBI.__kConversionChars[t3];
          const o3 = n2 - d2;
          for (u2 = i3 >>> o3, d2 = 30 - o3; d2 >= n2; ) r2[a2--] = _JSBI.__kConversionChars[u2 & g2], u2 >>>= n2, d2 -= n2;
        }
        const h2 = (u2 | o2 << d2) & g2;
        for (r2[a2--] = _JSBI.__kConversionChars[h2], u2 = o2 >>> n2 - d2; 0 !== u2; ) r2[a2--] = _JSBI.__kConversionChars[u2 & g2], u2 >>>= n2;
        if (_2.sign && (r2[a2--] = "-"), -1 != a2) throw new Error("implementation bug");
        return r2.join("");
      }
      static __toStringGeneric(_2, i2, t2) {
        const e2 = _2.length;
        if (0 === e2) return "";
        if (1 === e2) {
          let e3 = _2.__unsignedDigit(0).toString(i2);
          return false === t2 && _2.sign && (e3 = "-" + e3), e3;
        }
        const n2 = 30 * e2 - _JSBI.__clz30(_2.__digit(e2 - 1)), g2 = _JSBI.__kMaxBitsPerChar[i2], o2 = g2 - 1;
        let s2 = n2 * _JSBI.__kBitsPerCharTableMultiplier;
        s2 += o2 - 1, s2 = 0 | s2 / o2;
        const l2 = s2 + 1 >> 1, r2 = _JSBI.exponentiate(_JSBI.__oneDigit(i2, false), _JSBI.__oneDigit(l2, false));
        let a2, u2;
        const d2 = r2.__unsignedDigit(0);
        if (1 === r2.length && 32767 >= d2) {
          a2 = new _JSBI(_2.length, false), a2.__initializeDigits();
          let t3 = 0;
          for (let e3 = 2 * _2.length - 1; 0 <= e3; e3--) {
            const i3 = t3 << 15 | _2.__halfDigit(e3);
            a2.__setHalfDigit(e3, 0 | i3 / d2), t3 = 0 | i3 % d2;
          }
          u2 = t3.toString(i2);
        } else {
          const t3 = _JSBI.__absoluteDivLarge(_2, r2, true, true);
          a2 = t3.quotient;
          const e3 = t3.remainder.__trim();
          u2 = _JSBI.__toStringGeneric(e3, i2, true);
        }
        a2.__trim();
        let h2 = _JSBI.__toStringGeneric(a2, i2, true);
        for (; u2.length < l2; ) u2 = "0" + u2;
        return false === t2 && _2.sign && (h2 = "-" + h2), h2 + u2;
      }
      static __unequalSign(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteGreater(i2) {
        return i2 ? -1 : 1;
      }
      static __absoluteLess(i2) {
        return i2 ? 1 : -1;
      }
      static __compareToBigInt(i2, _2) {
        const t2 = i2.sign;
        if (t2 !== _2.sign) return _JSBI.__unequalSign(t2);
        const e2 = _JSBI.__absoluteCompare(i2, _2);
        return 0 < e2 ? _JSBI.__absoluteGreater(t2) : 0 > e2 ? _JSBI.__absoluteLess(t2) : 0;
      }
      static __compareToNumber(i2, _2) {
        if (_JSBI.__isOneDigitInt(_2)) {
          const t2 = i2.sign, e2 = 0 > _2;
          if (t2 !== e2) return _JSBI.__unequalSign(t2);
          if (0 === i2.length) {
            if (e2) throw new Error("implementation bug");
            return 0 === _2 ? 0 : -1;
          }
          if (1 < i2.length) return _JSBI.__absoluteGreater(t2);
          const n2 = Math.abs(_2), g2 = i2.__unsignedDigit(0);
          return g2 > n2 ? _JSBI.__absoluteGreater(t2) : g2 < n2 ? _JSBI.__absoluteLess(t2) : 0;
        }
        return _JSBI.__compareToDouble(i2, _2);
      }
      static __compareToDouble(i2, _2) {
        if (_2 !== _2) return _2;
        if (_2 === 1 / 0) return -1;
        if (_2 === -Infinity) return 1;
        const t2 = i2.sign;
        if (t2 !== 0 > _2) return _JSBI.__unequalSign(t2);
        if (0 === _2) throw new Error("implementation bug: should be handled elsewhere");
        if (0 === i2.length) return -1;
        _JSBI.__kBitConversionDouble[0] = _2;
        const e2 = 2047 & _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntHigh] >>> 20;
        if (2047 == e2) throw new Error("implementation bug: handled elsewhere");
        const n2 = e2 - 1023;
        if (0 > n2) return _JSBI.__absoluteGreater(t2);
        const g2 = i2.length;
        let o2 = i2.__digit(g2 - 1);
        const s2 = _JSBI.__clz30(o2), l2 = 30 * g2 - s2, r2 = n2 + 1;
        if (l2 < r2) return _JSBI.__absoluteLess(t2);
        if (l2 > r2) return _JSBI.__absoluteGreater(t2);
        let a2 = 1048576 | 1048575 & _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntHigh], u2 = _JSBI.__kBitConversionInts[_JSBI.__kBitConversionIntLow];
        const d2 = 20, h2 = 29 - s2;
        if (h2 !== (0 | (l2 - 1) % 30)) throw new Error("implementation bug");
        let m2, b2 = 0;
        if (20 > h2) {
          const i3 = d2 - h2;
          b2 = i3 + 32, m2 = a2 >>> i3, a2 = a2 << 32 - i3 | u2 >>> i3, u2 <<= 32 - i3;
        } else if (20 === h2) b2 = 32, m2 = a2, a2 = u2, u2 = 0;
        else {
          const i3 = h2 - d2;
          b2 = 32 - i3, m2 = a2 << i3 | u2 >>> 32 - i3, a2 = u2 << i3, u2 = 0;
        }
        if (o2 >>>= 0, m2 >>>= 0, o2 > m2) return _JSBI.__absoluteGreater(t2);
        if (o2 < m2) return _JSBI.__absoluteLess(t2);
        for (let e3 = g2 - 2; 0 <= e3; e3--) {
          0 < b2 ? (b2 -= 30, m2 = a2 >>> 2, a2 = a2 << 30 | u2 >>> 2, u2 <<= 30) : m2 = 0;
          const _3 = i2.__unsignedDigit(e3);
          if (_3 > m2) return _JSBI.__absoluteGreater(t2);
          if (_3 < m2) return _JSBI.__absoluteLess(t2);
        }
        if (0 !== a2 || 0 !== u2) {
          if (0 === b2) throw new Error("implementation bug");
          return _JSBI.__absoluteLess(t2);
        }
        return 0;
      }
      static __equalToNumber(i2, _2) {
        var t2 = Math.abs;
        return _JSBI.__isOneDigitInt(_2) ? 0 === _2 ? 0 === i2.length : 1 === i2.length && i2.sign === 0 > _2 && i2.__unsignedDigit(0) === t2(_2) : 0 === _JSBI.__compareToDouble(i2, _2);
      }
      static __comparisonResultToBool(i2, _2) {
        return 0 === _2 ? 0 > i2 : 1 === _2 ? 0 >= i2 : 2 === _2 ? 0 < i2 : 3 === _2 ? 0 <= i2 : void 0;
      }
      static __compare(i2, _2, t2) {
        if (i2 = _JSBI.__toPrimitive(i2), _2 = _JSBI.__toPrimitive(_2), "string" == typeof i2 && "string" == typeof _2) switch (t2) {
          case 0:
            return i2 < _2;
          case 1:
            return i2 <= _2;
          case 2:
            return i2 > _2;
          case 3:
            return i2 >= _2;
        }
        if (_JSBI.__isBigInt(i2) && "string" == typeof _2) return _2 = _JSBI.__fromString(_2), null !== _2 && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i2, _2), t2);
        if ("string" == typeof i2 && _JSBI.__isBigInt(_2)) return i2 = _JSBI.__fromString(i2), null !== i2 && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i2, _2), t2);
        if (i2 = _JSBI.__toNumeric(i2), _2 = _JSBI.__toNumeric(_2), _JSBI.__isBigInt(i2)) {
          if (_JSBI.__isBigInt(_2)) return _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i2, _2), t2);
          if ("number" != typeof _2) throw new Error("implementation bug");
          return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(i2, _2), t2);
        }
        if ("number" != typeof i2) throw new Error("implementation bug");
        if (_JSBI.__isBigInt(_2)) return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(_2, i2), 2 ^ t2);
        if ("number" != typeof _2) throw new Error("implementation bug");
        return 0 === t2 ? i2 < _2 : 1 === t2 ? i2 <= _2 : 2 === t2 ? i2 > _2 : 3 === t2 ? i2 >= _2 : void 0;
      }
      __clzmsd() {
        return _JSBI.__clz30(this.__digit(this.length - 1));
      }
      static __absoluteAdd(_2, t2, e2) {
        if (_2.length < t2.length) return _JSBI.__absoluteAdd(t2, _2, e2);
        if (0 === _2.length) return _2;
        if (0 === t2.length) return _2.sign === e2 ? _2 : _JSBI.unaryMinus(_2);
        let n2 = _2.length;
        (0 === _2.__clzmsd() || t2.length === _2.length && 0 === t2.__clzmsd()) && n2++;
        const g2 = new _JSBI(n2, e2);
        let o2 = 0, s2 = 0;
        for (; s2 < t2.length; s2++) {
          const i2 = _2.__digit(s2) + t2.__digit(s2) + o2;
          o2 = i2 >>> 30, g2.__setDigit(s2, 1073741823 & i2);
        }
        for (; s2 < _2.length; s2++) {
          const i2 = _2.__digit(s2) + o2;
          o2 = i2 >>> 30, g2.__setDigit(s2, 1073741823 & i2);
        }
        return s2 < g2.length && g2.__setDigit(s2, o2), g2.__trim();
      }
      static __absoluteSub(_2, t2, e2) {
        if (0 === _2.length) return _2;
        if (0 === t2.length) return _2.sign === e2 ? _2 : _JSBI.unaryMinus(_2);
        const n2 = new _JSBI(_2.length, e2);
        let g2 = 0, o2 = 0;
        for (; o2 < t2.length; o2++) {
          const i2 = _2.__digit(o2) - t2.__digit(o2) - g2;
          g2 = 1 & i2 >>> 30, n2.__setDigit(o2, 1073741823 & i2);
        }
        for (; o2 < _2.length; o2++) {
          const i2 = _2.__digit(o2) - g2;
          g2 = 1 & i2 >>> 30, n2.__setDigit(o2, 1073741823 & i2);
        }
        return n2.__trim();
      }
      static __absoluteAddOne(_2, i2, t2 = null) {
        const e2 = _2.length;
        null === t2 ? t2 = new _JSBI(e2, i2) : t2.sign = i2;
        let n2 = 1;
        for (let g2 = 0; g2 < e2; g2++) {
          const i3 = _2.__digit(g2) + n2;
          n2 = i3 >>> 30, t2.__setDigit(g2, 1073741823 & i3);
        }
        return 0 != n2 && t2.__setDigitGrow(e2, 1), t2;
      }
      static __absoluteSubOne(_2, t2) {
        const e2 = _2.length;
        t2 = t2 || e2;
        const n2 = new _JSBI(t2, false);
        let g2 = 1;
        for (let o2 = 0; o2 < e2; o2++) {
          const i2 = _2.__digit(o2) - g2;
          g2 = 1 & i2 >>> 30, n2.__setDigit(o2, 1073741823 & i2);
        }
        if (0 != g2) throw new Error("implementation bug");
        for (let g3 = e2; g3 < t2; g3++) n2.__setDigit(g3, 0);
        return n2;
      }
      static __absoluteAnd(_2, t2, e2 = null) {
        let n2 = _2.length, g2 = t2.length, o2 = g2;
        if (n2 < g2) {
          o2 = n2;
          const i2 = _2, e3 = n2;
          _2 = t2, n2 = g2, t2 = i2, g2 = e3;
        }
        let s2 = o2;
        null === e2 ? e2 = new _JSBI(s2, false) : s2 = e2.length;
        let l2 = 0;
        for (; l2 < o2; l2++) e2.__setDigit(l2, _2.__digit(l2) & t2.__digit(l2));
        for (; l2 < s2; l2++) e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteAndNot(_2, t2, e2 = null) {
        const n2 = _2.length, g2 = t2.length;
        let o2 = g2;
        n2 < g2 && (o2 = n2);
        let s2 = n2;
        null === e2 ? e2 = new _JSBI(s2, false) : s2 = e2.length;
        let l2 = 0;
        for (; l2 < o2; l2++) e2.__setDigit(l2, _2.__digit(l2) & ~t2.__digit(l2));
        for (; l2 < n2; l2++) e2.__setDigit(l2, _2.__digit(l2));
        for (; l2 < s2; l2++) e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteOr(_2, t2, e2 = null) {
        let n2 = _2.length, g2 = t2.length, o2 = g2;
        if (n2 < g2) {
          o2 = n2;
          const i2 = _2, e3 = n2;
          _2 = t2, n2 = g2, t2 = i2, g2 = e3;
        }
        let s2 = n2;
        null === e2 ? e2 = new _JSBI(s2, false) : s2 = e2.length;
        let l2 = 0;
        for (; l2 < o2; l2++) e2.__setDigit(l2, _2.__digit(l2) | t2.__digit(l2));
        for (; l2 < n2; l2++) e2.__setDigit(l2, _2.__digit(l2));
        for (; l2 < s2; l2++) e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteXor(_2, t2, e2 = null) {
        let n2 = _2.length, g2 = t2.length, o2 = g2;
        if (n2 < g2) {
          o2 = n2;
          const i2 = _2, e3 = n2;
          _2 = t2, n2 = g2, t2 = i2, g2 = e3;
        }
        let s2 = n2;
        null === e2 ? e2 = new _JSBI(s2, false) : s2 = e2.length;
        let l2 = 0;
        for (; l2 < o2; l2++) e2.__setDigit(l2, _2.__digit(l2) ^ t2.__digit(l2));
        for (; l2 < n2; l2++) e2.__setDigit(l2, _2.__digit(l2));
        for (; l2 < s2; l2++) e2.__setDigit(l2, 0);
        return e2;
      }
      static __absoluteCompare(_2, t2) {
        const e2 = _2.length - t2.length;
        if (0 != e2) return e2;
        let n2 = _2.length - 1;
        for (; 0 <= n2 && _2.__digit(n2) === t2.__digit(n2); ) n2--;
        return 0 > n2 ? 0 : _2.__unsignedDigit(n2) > t2.__unsignedDigit(n2) ? 1 : -1;
      }
      static __multiplyAccumulate(_2, t2, e2, n2) {
        if (0 === t2) return;
        const g2 = 32767 & t2, o2 = t2 >>> 15;
        let s2 = 0, l2 = 0;
        for (let r2, a2 = 0; a2 < _2.length; a2++, n2++) {
          r2 = e2.__digit(n2);
          const i2 = _2.__digit(a2), t3 = 32767 & i2, u2 = i2 >>> 15, d2 = _JSBI.__imul(t3, g2), h2 = _JSBI.__imul(t3, o2), m2 = _JSBI.__imul(u2, g2), b2 = _JSBI.__imul(u2, o2);
          r2 += l2 + d2 + s2, s2 = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & h2) << 15) + ((32767 & m2) << 15), s2 += r2 >>> 30, l2 = b2 + (h2 >>> 15) + (m2 >>> 15), e2.__setDigit(n2, 1073741823 & r2);
        }
        for (; 0 != s2 || 0 !== l2; n2++) {
          let i2 = e2.__digit(n2);
          i2 += s2 + l2, l2 = 0, s2 = i2 >>> 30, e2.__setDigit(n2, 1073741823 & i2);
        }
      }
      static __internalMultiplyAdd(_2, t2, e2, g2, o2) {
        let s2 = e2, l2 = 0;
        for (let n2 = 0; n2 < g2; n2++) {
          const i2 = _2.__digit(n2), e3 = _JSBI.__imul(32767 & i2, t2), g3 = _JSBI.__imul(i2 >>> 15, t2), a2 = e3 + ((32767 & g3) << 15) + l2 + s2;
          s2 = a2 >>> 30, l2 = g3 >>> 15, o2.__setDigit(n2, 1073741823 & a2);
        }
        if (o2.length > g2) for (o2.__setDigit(g2++, s2 + l2); g2 < o2.length; ) o2.__setDigit(g2++, 0);
        else if (0 !== s2 + l2) throw new Error("implementation bug");
      }
      __inplaceMultiplyAdd(i2, _2, t2) {
        t2 > this.length && (t2 = this.length);
        const e2 = 32767 & i2, n2 = i2 >>> 15;
        let g2 = 0, o2 = _2;
        for (let s2 = 0; s2 < t2; s2++) {
          const i3 = this.__digit(s2), _3 = 32767 & i3, t3 = i3 >>> 15, l2 = _JSBI.__imul(_3, e2), r2 = _JSBI.__imul(_3, n2), a2 = _JSBI.__imul(t3, e2), u2 = _JSBI.__imul(t3, n2);
          let d2 = o2 + l2 + g2;
          g2 = d2 >>> 30, d2 &= 1073741823, d2 += ((32767 & r2) << 15) + ((32767 & a2) << 15), g2 += d2 >>> 30, o2 = u2 + (r2 >>> 15) + (a2 >>> 15), this.__setDigit(s2, 1073741823 & d2);
        }
        if (0 != g2 || 0 !== o2) throw new Error("implementation bug");
      }
      static __absoluteDivSmall(_2, t2, e2 = null) {
        null === e2 && (e2 = new _JSBI(_2.length, false));
        let n2 = 0;
        for (let g2, o2 = 2 * _2.length - 1; 0 <= o2; o2 -= 2) {
          g2 = (n2 << 15 | _2.__halfDigit(o2)) >>> 0;
          const i2 = 0 | g2 / t2;
          n2 = 0 | g2 % t2, g2 = (n2 << 15 | _2.__halfDigit(o2 - 1)) >>> 0;
          const s2 = 0 | g2 / t2;
          n2 = 0 | g2 % t2, e2.__setDigit(o2 >>> 1, i2 << 15 | s2);
        }
        return e2;
      }
      static __absoluteModSmall(_2, t2) {
        let e2 = 0;
        for (let n2 = 2 * _2.length - 1; 0 <= n2; n2--) {
          const i2 = (e2 << 15 | _2.__halfDigit(n2)) >>> 0;
          e2 = 0 | i2 % t2;
        }
        return e2;
      }
      static __absoluteDivLarge(i2, _2, t2, e2) {
        const g2 = _2.__halfDigitLength(), n2 = _2.length, o2 = i2.__halfDigitLength() - g2;
        let s2 = null;
        t2 && (s2 = new _JSBI(o2 + 2 >>> 1, false), s2.__initializeDigits());
        const l2 = new _JSBI(g2 + 2 >>> 1, false);
        l2.__initializeDigits();
        const r2 = _JSBI.__clz15(_2.__halfDigit(g2 - 1));
        0 < r2 && (_2 = _JSBI.__specialLeftShift(_2, r2, 0));
        const a2 = _JSBI.__specialLeftShift(i2, r2, 1), u2 = _2.__halfDigit(g2 - 1);
        let d2 = 0;
        for (let r3, h2 = o2; 0 <= h2; h2--) {
          r3 = 32767;
          const i3 = a2.__halfDigit(h2 + g2);
          if (i3 !== u2) {
            const t3 = (i3 << 15 | a2.__halfDigit(h2 + g2 - 1)) >>> 0;
            r3 = 0 | t3 / u2;
            let e4 = 0 | t3 % u2;
            const n3 = _2.__halfDigit(g2 - 2), o3 = a2.__halfDigit(h2 + g2 - 2);
            for (; _JSBI.__imul(r3, n3) >>> 0 > (e4 << 16 | o3) >>> 0 && (r3--, e4 += u2, !(32767 < e4)); ) ;
          }
          _JSBI.__internalMultiplyAdd(_2, r3, 0, n2, l2);
          let e3 = a2.__inplaceSub(l2, h2, g2 + 1);
          0 !== e3 && (e3 = a2.__inplaceAdd(_2, h2, g2), a2.__setHalfDigit(h2 + g2, 32767 & a2.__halfDigit(h2 + g2) + e3), r3--), t2 && (1 & h2 ? d2 = r3 << 15 : s2.__setDigit(h2 >>> 1, d2 | r3));
        }
        if (e2) return a2.__inplaceRightShift(r2), t2 ? {
          quotient: s2,
          remainder: a2
        } : a2;
        if (t2) return s2;
        throw new Error("unreachable");
      }
      static __clz15(i2) {
        return _JSBI.__clz30(i2) - 15;
      }
      __inplaceAdd(_2, t2, e2) {
        let n2 = 0;
        for (let g2 = 0; g2 < e2; g2++) {
          const i2 = this.__halfDigit(t2 + g2) + _2.__halfDigit(g2) + n2;
          n2 = i2 >>> 15, this.__setHalfDigit(t2 + g2, 32767 & i2);
        }
        return n2;
      }
      __inplaceSub(_2, t2, e2) {
        let n2 = 0;
        if (1 & t2) {
          t2 >>= 1;
          let g2 = this.__digit(t2), o2 = 32767 & g2, s2 = 0;
          for (; s2 < e2 - 1 >>> 1; s2++) {
            const i3 = _2.__digit(s2), e3 = (g2 >>> 15) - (32767 & i3) - n2;
            n2 = 1 & e3 >>> 15, this.__setDigit(t2 + s2, (32767 & e3) << 15 | 32767 & o2), g2 = this.__digit(t2 + s2 + 1), o2 = (32767 & g2) - (i3 >>> 15) - n2, n2 = 1 & o2 >>> 15;
          }
          const i2 = _2.__digit(s2), l2 = (g2 >>> 15) - (32767 & i2) - n2;
          n2 = 1 & l2 >>> 15, this.__setDigit(t2 + s2, (32767 & l2) << 15 | 32767 & o2);
          if (t2 + s2 + 1 >= this.length) throw new RangeError("out of bounds");
          0 == (1 & e2) && (g2 = this.__digit(t2 + s2 + 1), o2 = (32767 & g2) - (i2 >>> 15) - n2, n2 = 1 & o2 >>> 15, this.__setDigit(t2 + _2.length, 1073709056 & g2 | 32767 & o2));
        } else {
          t2 >>= 1;
          let g2 = 0;
          for (; g2 < _2.length - 1; g2++) {
            const i3 = this.__digit(t2 + g2), e3 = _2.__digit(g2), o3 = (32767 & i3) - (32767 & e3) - n2;
            n2 = 1 & o3 >>> 15;
            const s3 = (i3 >>> 15) - (e3 >>> 15) - n2;
            n2 = 1 & s3 >>> 15, this.__setDigit(t2 + g2, (32767 & s3) << 15 | 32767 & o3);
          }
          const i2 = this.__digit(t2 + g2), o2 = _2.__digit(g2), s2 = (32767 & i2) - (32767 & o2) - n2;
          n2 = 1 & s2 >>> 15;
          let l2 = 0;
          0 == (1 & e2) && (l2 = (i2 >>> 15) - (o2 >>> 15) - n2, n2 = 1 & l2 >>> 15), this.__setDigit(t2 + g2, (32767 & l2) << 15 | 32767 & s2);
        }
        return n2;
      }
      __inplaceRightShift(_2) {
        if (0 === _2) return;
        let t2 = this.__digit(0) >>> _2;
        const e2 = this.length - 1;
        for (let n2 = 0; n2 < e2; n2++) {
          const i2 = this.__digit(n2 + 1);
          this.__setDigit(n2, 1073741823 & i2 << 30 - _2 | t2), t2 = i2 >>> _2;
        }
        this.__setDigit(e2, t2);
      }
      static __specialLeftShift(_2, t2, e2) {
        const g2 = _2.length, n2 = new _JSBI(g2 + e2, false);
        if (0 === t2) {
          for (let t3 = 0; t3 < g2; t3++) n2.__setDigit(t3, _2.__digit(t3));
          return 0 < e2 && n2.__setDigit(g2, 0), n2;
        }
        let o2 = 0;
        for (let s2 = 0; s2 < g2; s2++) {
          const i2 = _2.__digit(s2);
          n2.__setDigit(s2, 1073741823 & i2 << t2 | o2), o2 = i2 >>> 30 - t2;
        }
        return 0 < e2 && n2.__setDigit(g2, o2), n2;
      }
      static __leftShiftByAbsolute(_2, i2) {
        const t2 = _JSBI.__toShiftAmount(i2);
        if (0 > t2) throw new RangeError("BigInt too big");
        const e2 = 0 | t2 / 30, n2 = t2 % 30, g2 = _2.length, o2 = 0 !== n2 && 0 != _2.__digit(g2 - 1) >>> 30 - n2, s2 = g2 + e2 + (o2 ? 1 : 0), l2 = new _JSBI(s2, _2.sign);
        if (0 === n2) {
          let t3 = 0;
          for (; t3 < e2; t3++) l2.__setDigit(t3, 0);
          for (; t3 < s2; t3++) l2.__setDigit(t3, _2.__digit(t3 - e2));
        } else {
          let t3 = 0;
          for (let _3 = 0; _3 < e2; _3++) l2.__setDigit(_3, 0);
          for (let o3 = 0; o3 < g2; o3++) {
            const i3 = _2.__digit(o3);
            l2.__setDigit(o3 + e2, 1073741823 & i3 << n2 | t3), t3 = i3 >>> 30 - n2;
          }
          if (o2) l2.__setDigit(g2 + e2, t3);
          else if (0 !== t3) throw new Error("implementation bug");
        }
        return l2.__trim();
      }
      static __rightShiftByAbsolute(_2, i2) {
        const t2 = _2.length, e2 = _2.sign, n2 = _JSBI.__toShiftAmount(i2);
        if (0 > n2) return _JSBI.__rightShiftByMaximum(e2);
        const g2 = 0 | n2 / 30, o2 = n2 % 30;
        let s2 = t2 - g2;
        if (0 >= s2) return _JSBI.__rightShiftByMaximum(e2);
        let l2 = false;
        if (e2) {
          if (0 != (_2.__digit(g2) & (1 << o2) - 1)) l2 = true;
          else for (let t3 = 0; t3 < g2; t3++) if (0 !== _2.__digit(t3)) {
            l2 = true;
            break;
          }
        }
        if (l2 && 0 === o2) {
          const i3 = _2.__digit(t2 - 1);
          0 == ~i3 && s2++;
        }
        let r2 = new _JSBI(s2, e2);
        if (0 === o2) {
          r2.__setDigit(s2 - 1, 0);
          for (let e3 = g2; e3 < t2; e3++) r2.__setDigit(e3 - g2, _2.__digit(e3));
        } else {
          let e3 = _2.__digit(g2) >>> o2;
          const n3 = t2 - g2 - 1;
          for (let t3 = 0; t3 < n3; t3++) {
            const i3 = _2.__digit(t3 + g2 + 1);
            r2.__setDigit(t3, 1073741823 & i3 << 30 - o2 | e3), e3 = i3 >>> o2;
          }
          r2.__setDigit(n3, e3);
        }
        return l2 && (r2 = _JSBI.__absoluteAddOne(r2, true, r2)), r2.__trim();
      }
      static __rightShiftByMaximum(i2) {
        return i2 ? _JSBI.__oneDigit(1, true) : _JSBI.__zero();
      }
      static __toShiftAmount(i2) {
        if (1 < i2.length) return -1;
        const _2 = i2.__unsignedDigit(0);
        return _2 > _JSBI.__kMaxLengthBits ? -1 : _2;
      }
      static __toPrimitive(i2, _2 = "default") {
        if ("object" != typeof i2) return i2;
        if (i2.constructor === _JSBI) return i2;
        if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive && i2[Symbol.toPrimitive]) {
          const t3 = i2[Symbol.toPrimitive](_2);
          if ("object" != typeof t3) return t3;
          throw new TypeError("Cannot convert object to primitive value");
        }
        const t2 = i2.valueOf;
        if (t2) {
          const _3 = t2.call(i2);
          if ("object" != typeof _3) return _3;
        }
        const e2 = i2.toString;
        if (e2) {
          const _3 = e2.call(i2);
          if ("object" != typeof _3) return _3;
        }
        throw new TypeError("Cannot convert object to primitive value");
      }
      static __toNumeric(i2) {
        return _JSBI.__isBigInt(i2) ? i2 : +i2;
      }
      static __isBigInt(i2) {
        return "object" == typeof i2 && null !== i2 && i2.constructor === _JSBI;
      }
      static __truncateToNBits(i2, _2) {
        const t2 = 0 | (i2 + 29) / 30, e2 = new _JSBI(t2, _2.sign), n2 = t2 - 1;
        for (let t3 = 0; t3 < n2; t3++) e2.__setDigit(t3, _2.__digit(t3));
        let g2 = _2.__digit(n2);
        if (0 != i2 % 30) {
          const _3 = 32 - i2 % 30;
          g2 = g2 << _3 >>> _3;
        }
        return e2.__setDigit(n2, g2), e2.__trim();
      }
      static __truncateAndSubFromPowerOfTwo(_2, t2, e2) {
        var n2 = Math.min;
        const g2 = 0 | (_2 + 29) / 30, o2 = new _JSBI(g2, e2);
        let s2 = 0;
        const l2 = g2 - 1;
        let a2 = 0;
        for (const i2 = n2(l2, t2.length); s2 < i2; s2++) {
          const i3 = 0 - t2.__digit(s2) - a2;
          a2 = 1 & i3 >>> 30, o2.__setDigit(s2, 1073741823 & i3);
        }
        for (; s2 < l2; s2++) o2.__setDigit(s2, 0 | 1073741823 & -a2);
        let u2 = l2 < t2.length ? t2.__digit(l2) : 0;
        const d2 = _2 % 30;
        let h2;
        if (0 == d2) h2 = 0 - u2 - a2, h2 &= 1073741823;
        else {
          const i2 = 32 - d2;
          u2 = u2 << i2 >>> i2;
          const _3 = 1 << 32 - i2;
          h2 = _3 - u2 - a2, h2 &= _3 - 1;
        }
        return o2.__setDigit(l2, h2), o2.__trim();
      }
      __digit(_2) {
        return this[_2];
      }
      __unsignedDigit(_2) {
        return this[_2] >>> 0;
      }
      __setDigit(_2, i2) {
        this[_2] = 0 | i2;
      }
      __setDigitGrow(_2, i2) {
        this[_2] = 0 | i2;
      }
      __halfDigitLength() {
        const i2 = this.length;
        return 32767 >= this.__unsignedDigit(i2 - 1) ? 2 * i2 - 1 : 2 * i2;
      }
      __halfDigit(_2) {
        return 32767 & this[_2 >>> 1] >>> 15 * (1 & _2);
      }
      __setHalfDigit(_2, i2) {
        const t2 = _2 >>> 1, e2 = this.__digit(t2), n2 = 1 & _2 ? 32767 & e2 | i2 << 15 : 1073709056 & e2 | 32767 & i2;
        this.__setDigit(t2, n2);
      }
      static __digitPow(i2, _2) {
        let t2 = 1;
        for (; 0 < _2; ) 1 & _2 && (t2 *= i2), _2 >>>= 1, i2 *= i2;
        return t2;
      }
      static __detectBigEndian() {
        return _JSBI.__kBitConversionDouble[0] = -0, 0 !== _JSBI.__kBitConversionInts[0];
      }
      static __isOneDigitInt(i2) {
        return (1073741823 & i2) === i2;
      }
    };
    JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [
      0,
      0,
      32,
      51,
      64,
      75,
      83,
      90,
      96,
      102,
      107,
      111,
      115,
      119,
      122,
      126,
      128,
      131,
      134,
      136,
      139,
      141,
      143,
      145,
      147,
      149,
      151,
      153,
      154,
      156,
      158,
      159,
      160,
      162,
      163,
      165,
      166
    ], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z"
    ], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionIntHigh = JSBI.__detectBigEndian() ? 0 : 1, JSBI.__kBitConversionIntLow = JSBI.__detectBigEndian() ? 1 : 0, JSBI.__clz30 = Math.clz32 ? function(i2) {
      return Math.clz32(i2) - 2;
    } : function(i2) {
      return 0 === i2 ? 30 : 0 | 29 - (0 | Math.log(i2 >>> 0) / Math.LN2);
    }, JSBI.__imul = Math.imul || function(i2, _2) {
      return 0 | i2 * _2;
    }, module2.exports = JSBI;
  }
});

// node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}
var init_universal_user_agent = __esm({
  "node_modules/.pnpm/universal-user-agent@7.0.3/node_modules/universal-user-agent/index.js"() {
    __name(getUserAgent, "getUserAgent");
  }
});

// node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/register.js
function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }
  if (!options) {
    options = {};
  }
  if (Array.isArray(name)) {
    return name.reverse().reduce((callback, name2) => {
      return register.bind(null, state, name2, callback, options);
    }, method)();
  }
  return Promise.resolve().then(() => {
    if (!state.registry[name]) {
      return method(options);
    }
    return state.registry[name].reduce((method2, registered) => {
      return registered.hook.bind(null, method2, options);
    }, method)();
  });
}
var init_register = __esm({
  "node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/register.js"() {
    __name(register, "register");
  }
});

// node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/add.js
function addHook(state, kind, name, hook2) {
  const orig = hook2;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }
  if (kind === "before") {
    hook2 = /* @__PURE__ */ __name((method, options) => {
      return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
    }, "hook");
  }
  if (kind === "after") {
    hook2 = /* @__PURE__ */ __name((method, options) => {
      let result;
      return Promise.resolve().then(method.bind(null, options)).then((result_) => {
        result = result_;
        return orig(result, options);
      }).then(() => {
        return result;
      });
    }, "hook");
  }
  if (kind === "error") {
    hook2 = /* @__PURE__ */ __name((method, options) => {
      return Promise.resolve().then(method.bind(null, options)).catch((error45) => {
        return orig(error45, options);
      });
    }, "hook");
  }
  state.registry[name].push({
    hook: hook2,
    orig
  });
}
var init_add = __esm({
  "node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/add.js"() {
    __name(addHook, "addHook");
  }
});

// node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/remove.js
function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }
  const index = state.registry[name].map((registered) => {
    return registered.orig;
  }).indexOf(method);
  if (index === -1) {
    return;
  }
  state.registry[name].splice(index, 1);
}
var init_remove = __esm({
  "node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/lib/remove.js"() {
    __name(removeHook, "removeHook");
  }
});

// node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/index.js
function bindApi(hook2, state, name) {
  const removeHookRef = bindable(removeHook, null).apply(null, name ? [
    state,
    name
  ] : [
    state
  ]);
  hook2.api = {
    remove: removeHookRef
  };
  hook2.remove = removeHookRef;
  [
    "before",
    "error",
    "after",
    "wrap"
  ].forEach((kind) => {
    const args = name ? [
      state,
      kind,
      name
    ] : [
      state,
      kind
    ];
    hook2[kind] = hook2.api[kind] = bindable(addHook, null).apply(null, args);
  });
}
function Singular() {
  const singularHookName = Symbol("Singular");
  const singularHookState = {
    registry: {}
  };
  const singularHook = register.bind(null, singularHookState, singularHookName);
  bindApi(singularHook, singularHookState, singularHookName);
  return singularHook;
}
function Collection() {
  const state = {
    registry: {}
  };
  const hook2 = register.bind(null, state);
  bindApi(hook2, state);
  return hook2;
}
var bind, bindable, before_after_hook_default;
var init_before_after_hook = __esm({
  "node_modules/.pnpm/before-after-hook@3.0.2/node_modules/before-after-hook/index.js"() {
    init_register();
    init_add();
    init_remove();
    bind = Function.bind;
    bindable = bind.bind(bind);
    __name(bindApi, "bindApi");
    __name(Singular, "Singular");
    __name(Collection, "Collection");
    before_after_hook_default = {
      Singular,
      Collection
    };
  }
});

// node_modules/.pnpm/@octokit+endpoint@10.1.4/node_modules/@octokit/endpoint/dist-bundle/index.js
function lowercaseKeys(object2) {
  if (!object2) {
    return {};
  }
  return Object.keys(object2).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object2[key];
    return newObj;
  }, {});
}
function isPlainObject2(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach((key) => {
    if (isPlainObject2(options[key])) {
      if (!(key in defaults)) Object.assign(result, {
        [key]: options[key]
      });
      else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, {
        [key]: options[key]
      });
    }
  });
  return result;
}
function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === void 0) {
      delete obj[key];
    }
  }
  return obj;
}
function merge2(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url2] = route.split(" ");
    options = Object.assign(url2 ? {
      method,
      url: url2
    } : {
      url: method
    }, options);
  } else {
    options = Object.assign({}, route);
  }
  options.headers = lowercaseKeys(options.headers);
  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options);
  if (options.url === "/graphql") {
    if (defaults && defaults.mediaType.previews?.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview) => preview.replace(/-preview/, ""));
  }
  return mergedOptions;
}
function addQueryParameters(url2, parameters) {
  const separator = /\?/.test(url2) ? "&" : "?";
  const names = Object.keys(parameters);
  if (names.length === 0) {
    return url2;
  }
  return url2 + separator + names.map((name) => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }
    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}
function removeNonChars(variableName) {
  return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url2) {
  const matches = url2.match(urlVariableRegex);
  if (!matches) {
    return [];
  }
  return matches.map(removeNonChars).reduce((a2, b2) => a2.concat(b2), []);
}
function omit2(object2, keysToOmit) {
  const result = {
    __proto__: null
  };
  for (const key of Object.keys(object2)) {
    if (keysToOmit.indexOf(key) === -1) {
      result[key] = object2[key];
    }
  }
  return result;
}
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }
    return part;
  }).join("");
}
function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function(c2) {
    return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
  });
}
function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
  var value = context[key], result = [];
  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();
      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }
      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined(value[k2])) {
              result.push(encodeValue(operator, value[k2], k2));
            }
          });
        }
      } else {
        const tmp = [];
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function(value2) {
            tmp.push(encodeValue(operator, value2));
          });
        } else {
          Object.keys(value).forEach(function(k2) {
            if (isDefined(value[k2])) {
              tmp.push(encodeUnreserved(k2));
              tmp.push(encodeValue(operator, value[k2].toString()));
            }
          });
        }
        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }
  return result;
}
function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}
function expand(template, context) {
  var operators = [
    "+",
    "#",
    ".",
    "/",
    ";",
    "?",
    "&"
  ];
  template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_2, expression, literal2) {
    if (expression) {
      let operator = "";
      const values = [];
      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }
      expression.split(/,/g).forEach(function(variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });
      if (operator && operator !== "+") {
        var separator = ",";
        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }
        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal2);
    }
  });
  if (template === "/") {
    return template;
  } else {
    return template.replace(/\/$/, "");
  }
}
function parse4(options) {
  let method = options.method.toUpperCase();
  let url2 = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit2(options, [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "mediaType"
  ]);
  const urlVariableNames = extractUrlVariableNames(url2);
  url2 = parseUrl(url2).expand(parameters);
  if (!/^http/.test(url2)) {
    url2 = options.baseUrl + url2;
  }
  const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit2(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      headers.accept = headers.accept.split(/,/).map((format2) => format2.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }
    if (url2.endsWith("/graphql")) {
      if (options.mediaType.previews?.length) {
        const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format2 = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format2}`;
        }).join(",");
      }
    }
  }
  if ([
    "GET",
    "HEAD"
  ].includes(method)) {
    url2 = addQueryParameters(url2, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      }
    }
  }
  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  }
  if ([
    "PATCH",
    "PUT"
  ].includes(method) && typeof body === "undefined") {
    body = "";
  }
  return Object.assign({
    method,
    url: url2,
    headers
  }, typeof body !== "undefined" ? {
    body
  } : null, options.request ? {
    request: options.request
  } : null);
}
function endpointWithDefaults(defaults, route, options) {
  return parse4(merge2(defaults, route, options));
}
function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS2 = merge2(oldDefaults, newDefaults);
  const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
  return Object.assign(endpoint2, {
    DEFAULTS: DEFAULTS2,
    defaults: withDefaults.bind(null, DEFAULTS2),
    merge: merge2.bind(null, DEFAULTS2),
    parse: parse4
  });
}
var VERSION, userAgent, DEFAULTS, urlVariableRegex, endpoint;
var init_dist_bundle = __esm({
  "node_modules/.pnpm/@octokit+endpoint@10.1.4/node_modules/@octokit/endpoint/dist-bundle/index.js"() {
    init_universal_user_agent();
    VERSION = "0.0.0-development";
    userAgent = `octokit-endpoint.js/${VERSION} ${getUserAgent()}`;
    DEFAULTS = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
      },
      mediaType: {
        format: ""
      }
    };
    __name(lowercaseKeys, "lowercaseKeys");
    __name(isPlainObject2, "isPlainObject");
    __name(mergeDeep, "mergeDeep");
    __name(removeUndefinedProperties, "removeUndefinedProperties");
    __name(merge2, "merge");
    __name(addQueryParameters, "addQueryParameters");
    urlVariableRegex = /\{[^{}}]+\}/g;
    __name(removeNonChars, "removeNonChars");
    __name(extractUrlVariableNames, "extractUrlVariableNames");
    __name(omit2, "omit");
    __name(encodeReserved, "encodeReserved");
    __name(encodeUnreserved, "encodeUnreserved");
    __name(encodeValue, "encodeValue");
    __name(isDefined, "isDefined");
    __name(isKeyOperator, "isKeyOperator");
    __name(getValues, "getValues");
    __name(parseUrl, "parseUrl");
    __name(expand, "expand");
    __name(parse4, "parse");
    __name(endpointWithDefaults, "endpointWithDefaults");
    __name(withDefaults, "withDefaults");
    endpoint = withDefaults(null, DEFAULTS);
  }
});

// node_modules/.pnpm/fast-content-type-parse@2.0.1/node_modules/fast-content-type-parse/index.js
var require_fast_content_type_parse = __commonJS({
  "node_modules/.pnpm/fast-content-type-parse@2.0.1/node_modules/fast-content-type-parse/index.js"(exports2, module2) {
    "use strict";
    var NullObject = /* @__PURE__ */ __name(function NullObject2() {
    }, "NullObject");
    NullObject.prototype = /* @__PURE__ */ Object.create(null);
    var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
    var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
    var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
    var defaultContentType = {
      type: "",
      parameters: new NullObject()
    };
    Object.freeze(defaultContentType.parameters);
    Object.freeze(defaultContentType);
    function parse5(header) {
      if (typeof header !== "string") {
        throw new TypeError("argument header is required and must be a string");
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        throw new TypeError("invalid media type");
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        throw new TypeError("invalid parameter format");
      }
      return result;
    }
    __name(parse5, "parse");
    function safeParse4(header) {
      if (typeof header !== "string") {
        return defaultContentType;
      }
      let index = header.indexOf(";");
      const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
      if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
      }
      const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
      };
      if (index === -1) {
        return result;
      }
      let key;
      let match;
      let value;
      paramRE.lastIndex = index;
      while (match = paramRE.exec(header)) {
        if (match.index !== index) {
          return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
          value = value.slice(1, value.length - 1);
          quotedPairRE.test(value) && (value = value.replace(quotedPairRE, "$1"));
        }
        result.parameters[key] = value;
      }
      if (index !== header.length) {
        return defaultContentType;
      }
      return result;
    }
    __name(safeParse4, "safeParse");
    module2.exports.default = {
      parse: parse5,
      safeParse: safeParse4
    };
    module2.exports.parse = parse5;
    module2.exports.safeParse = safeParse4;
    module2.exports.defaultContentType = defaultContentType;
  }
});

// node_modules/.pnpm/@octokit+request-error@6.1.8/node_modules/@octokit/request-error/dist-src/index.js
var RequestError;
var init_dist_src = __esm({
  "node_modules/.pnpm/@octokit+request-error@6.1.8/node_modules/@octokit/request-error/dist-src/index.js"() {
    RequestError = class extends Error {
      static {
        __name(this, "RequestError");
      }
      name;
      /**
      * http status code
      */
      status;
      /**
      * Request options that lead to the error.
      */
      request;
      /**
      * Response object if a response was received
      */
      response;
      constructor(message, statusCode, options) {
        super(message);
        this.name = "HttpError";
        this.status = Number.parseInt(statusCode);
        if (Number.isNaN(this.status)) {
          this.status = 0;
        }
        if ("response" in options) {
          this.response = options.response;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
          requestCopy.headers = Object.assign({}, options.request.headers, {
            authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
          });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
      }
    };
  }
});

// node_modules/.pnpm/@octokit+request@9.2.4/node_modules/@octokit/request/dist-bundle/index.js
function isPlainObject3(value) {
  if (typeof value !== "object" || value === null) return false;
  if (Object.prototype.toString.call(value) !== "[object Object]") return false;
  const proto = Object.getPrototypeOf(value);
  if (proto === null) return true;
  const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
async function fetchWrapper(requestOptions) {
  const fetch3 = requestOptions.request?.fetch || globalThis.fetch;
  if (!fetch3) {
    throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
  }
  const log = requestOptions.request?.log || console;
  const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
  const body = isPlainObject3(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
  const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value]) => [
    name,
    String(value)
  ]));
  let fetchResponse;
  try {
    fetchResponse = await fetch3(requestOptions.url, {
      method: requestOptions.method,
      body,
      redirect: requestOptions.request?.redirect,
      headers: requestHeaders,
      signal: requestOptions.request?.signal,
      // duplex must be set if request.body is ReadableStream or Async Iterables.
      // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
      ...requestOptions.body && {
        duplex: "half"
      }
    });
  } catch (error45) {
    let message = "Unknown Error";
    if (error45 instanceof Error) {
      if (error45.name === "AbortError") {
        error45.status = 500;
        throw error45;
      }
      message = error45.message;
      if (error45.name === "TypeError" && "cause" in error45) {
        if (error45.cause instanceof Error) {
          message = error45.cause.message;
        } else if (typeof error45.cause === "string") {
          message = error45.cause;
        }
      }
    }
    const requestError = new RequestError(message, 500, {
      request: requestOptions
    });
    requestError.cause = error45;
    throw requestError;
  }
  const status = fetchResponse.status;
  const url2 = fetchResponse.url;
  const responseHeaders = {};
  for (const [key, value] of fetchResponse.headers) {
    responseHeaders[key] = value;
  }
  const octokitResponse = {
    url: url2,
    status,
    headers: responseHeaders,
    data: ""
  };
  if ("deprecation" in responseHeaders) {
    const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
    const deprecationLink = matches && matches.pop();
    log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
  }
  if (status === 204 || status === 205) {
    return octokitResponse;
  }
  if (requestOptions.method === "HEAD") {
    if (status < 400) {
      return octokitResponse;
    }
    throw new RequestError(fetchResponse.statusText, status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status === 304) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError("Not modified", status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  if (status >= 400) {
    octokitResponse.data = await getResponseData(fetchResponse);
    throw new RequestError(toErrorMessage(octokitResponse.data), status, {
      response: octokitResponse,
      request: requestOptions
    });
  }
  octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
  return octokitResponse;
}
async function getResponseData(response) {
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    return response.text().catch(() => "");
  }
  const mimetype = (0, import_fast_content_type_parse.safeParse)(contentType);
  if (isJSONResponse(mimetype)) {
    let text = "";
    try {
      text = await response.text();
      return JSON.parse(text);
    } catch (err) {
      return text;
    }
  } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
    return response.text().catch(() => "");
  } else {
    return response.arrayBuffer().catch(() => new ArrayBuffer(0));
  }
}
function isJSONResponse(mimetype) {
  return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
  if (typeof data === "string") {
    return data;
  }
  if (data instanceof ArrayBuffer) {
    return "Unknown error";
  }
  if ("message" in data) {
    const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
    return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v2) => JSON.stringify(v2)).join(", ")}${suffix}` : `${data.message}${suffix}`;
  }
  return `Unknown error: ${JSON.stringify(data)}`;
}
function withDefaults2(oldEndpoint, newDefaults) {
  const endpoint2 = oldEndpoint.defaults(newDefaults);
  const newApi = /* @__PURE__ */ __name(function(route, parameters) {
    const endpointOptions = endpoint2.merge(route, parameters);
    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint2.parse(endpointOptions));
    }
    const request2 = /* @__PURE__ */ __name((route2, parameters2) => {
      return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
    }, "request2");
    Object.assign(request2, {
      endpoint: endpoint2,
      defaults: withDefaults2.bind(null, endpoint2)
    });
    return endpointOptions.request.hook(request2, endpointOptions);
  }, "newApi");
  return Object.assign(newApi, {
    endpoint: endpoint2,
    defaults: withDefaults2.bind(null, endpoint2)
  });
}
var import_fast_content_type_parse, VERSION2, defaults_default, request;
var init_dist_bundle2 = __esm({
  "node_modules/.pnpm/@octokit+request@9.2.4/node_modules/@octokit/request/dist-bundle/index.js"() {
    init_dist_bundle();
    init_universal_user_agent();
    import_fast_content_type_parse = __toESM(require_fast_content_type_parse(), 1);
    init_dist_src();
    VERSION2 = "9.2.4";
    defaults_default = {
      headers: {
        "user-agent": `octokit-request.js/${VERSION2} ${getUserAgent()}`
      }
    };
    __name(isPlainObject3, "isPlainObject");
    __name(fetchWrapper, "fetchWrapper");
    __name(getResponseData, "getResponseData");
    __name(isJSONResponse, "isJSONResponse");
    __name(toErrorMessage, "toErrorMessage");
    __name(withDefaults2, "withDefaults");
    request = withDefaults2(endpoint, defaults_default);
  }
});

// node_modules/.pnpm/@octokit+graphql@8.2.2/node_modules/@octokit/graphql/dist-bundle/index.js
function _buildMessageForResponseErrors(data) {
  return `Request failed due to following response errors:
` + data.errors.map((e2) => ` - ${e2.message}`).join("\n");
}
function graphql(request2, query, options) {
  if (options) {
    if (typeof query === "string" && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    for (const key in options) {
      if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
      return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
    }
  }
  const parsedOptions = typeof query === "string" ? Object.assign({
    query
  }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }
    if (!result.variables) {
      result.variables = {};
    }
    result.variables[key] = parsedOptions[key];
    return result;
  }, {});
  const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }
  return request2(requestOptions).then((response) => {
    if (response.data.errors) {
      const headers = {};
      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }
      throw new GraphqlResponseError(requestOptions, headers, response.data);
    }
    return response.data.data;
  });
}
function withDefaults3(request2, newDefaults) {
  const newRequest = request2.defaults(newDefaults);
  const newApi = /* @__PURE__ */ __name((query, options) => {
    return graphql(newRequest, query, options);
  }, "newApi");
  return Object.assign(newApi, {
    defaults: withDefaults3.bind(null, newRequest),
    endpoint: newRequest.endpoint
  });
}
function withCustomRequest(customRequest) {
  return withDefaults3(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}
var VERSION3, GraphqlResponseError, NON_VARIABLE_OPTIONS, FORBIDDEN_VARIABLE_OPTIONS, GHES_V3_SUFFIX_REGEX, graphql2;
var init_dist_bundle3 = __esm({
  "node_modules/.pnpm/@octokit+graphql@8.2.2/node_modules/@octokit/graphql/dist-bundle/index.js"() {
    init_dist_bundle2();
    init_universal_user_agent();
    VERSION3 = "0.0.0-development";
    __name(_buildMessageForResponseErrors, "_buildMessageForResponseErrors");
    GraphqlResponseError = class extends Error {
      static {
        __name(this, "GraphqlResponseError");
      }
      constructor(request2, headers, response) {
        super(_buildMessageForResponseErrors(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
      name = "GraphqlResponseError";
      errors;
      data;
    };
    NON_VARIABLE_OPTIONS = [
      "method",
      "baseUrl",
      "url",
      "headers",
      "request",
      "query",
      "mediaType",
      "operationName"
    ];
    FORBIDDEN_VARIABLE_OPTIONS = [
      "query",
      "method",
      "url"
    ];
    GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
    __name(graphql, "graphql");
    __name(withDefaults3, "withDefaults");
    graphql2 = withDefaults3(request, {
      headers: {
        "user-agent": `octokit-graphql.js/${VERSION3} ${getUserAgent()}`
      },
      method: "POST",
      url: "/graphql"
    });
    __name(withCustomRequest, "withCustomRequest");
  }
});

// node_modules/.pnpm/@octokit+auth-token@5.1.2/node_modules/@octokit/auth-token/dist-bundle/index.js
async function auth(token) {
  const isApp = isJWT(token);
  const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
  const isUserToServer = token.startsWith("ghu_");
  const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
  return {
    type: "token",
    token,
    tokenType
  };
}
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }
  return `token ${token}`;
}
async function hook(token, request2, route, parameters) {
  const endpoint2 = request2.endpoint.merge(route, parameters);
  endpoint2.headers.authorization = withAuthorizationPrefix(token);
  return request2(endpoint2);
}
var b64url, sep, jwtRE, isJWT, createTokenAuth;
var init_dist_bundle4 = __esm({
  "node_modules/.pnpm/@octokit+auth-token@5.1.2/node_modules/@octokit/auth-token/dist-bundle/index.js"() {
    b64url = "(?:[a-zA-Z0-9_-]+)";
    sep = "\\.";
    jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
    isJWT = jwtRE.test.bind(jwtRE);
    __name(auth, "auth");
    __name(withAuthorizationPrefix, "withAuthorizationPrefix");
    __name(hook, "hook");
    createTokenAuth = /* @__PURE__ */ __name(function createTokenAuth2(token) {
      if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
      }
      token = token.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token)
      });
    }, "createTokenAuth2");
  }
});

// node_modules/.pnpm/@octokit+core@6.1.6/node_modules/@octokit/core/dist-src/version.js
var VERSION4;
var init_version = __esm({
  "node_modules/.pnpm/@octokit+core@6.1.6/node_modules/@octokit/core/dist-src/version.js"() {
    VERSION4 = "6.1.6";
  }
});

// node_modules/.pnpm/@octokit+core@6.1.6/node_modules/@octokit/core/dist-src/index.js
function createLogger(logger = {}) {
  if (typeof logger.debug !== "function") {
    logger.debug = noop;
  }
  if (typeof logger.info !== "function") {
    logger.info = noop;
  }
  if (typeof logger.warn !== "function") {
    logger.warn = consoleWarn;
  }
  if (typeof logger.error !== "function") {
    logger.error = consoleError;
  }
  return logger;
}
var noop, consoleWarn, consoleError, userAgentTrail, Octokit;
var init_dist_src2 = __esm({
  "node_modules/.pnpm/@octokit+core@6.1.6/node_modules/@octokit/core/dist-src/index.js"() {
    init_universal_user_agent();
    init_before_after_hook();
    init_dist_bundle2();
    init_dist_bundle3();
    init_dist_bundle4();
    init_version();
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    consoleWarn = console.warn.bind(console);
    consoleError = console.error.bind(console);
    __name(createLogger, "createLogger");
    userAgentTrail = `octokit-core.js/${VERSION4} ${getUserAgent()}`;
    Octokit = class {
      static {
        __name(this, "Octokit");
      }
      static VERSION = VERSION4;
      static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
          static {
            __name(this, "OctokitWithDefaults");
          }
          constructor(...args) {
            const options = args[0] || {};
            if (typeof defaults === "function") {
              super(defaults(options));
              return;
            }
            super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
              userAgent: `${options.userAgent} ${defaults.userAgent}`
            } : null));
          }
        };
        return OctokitWithDefaults;
      }
      static plugins = [];
      /**
      * Attach a plugin (or many) to your Octokit instance.
      *
      * @example
      * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
      */
      static plugin(...newPlugins) {
        const currentPlugins = this.plugins;
        const NewOctokit = class extends this {
          static {
            __name(this, "NewOctokit");
          }
          static plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin)));
        };
        return NewOctokit;
      }
      constructor(options = {}) {
        const hook2 = new before_after_hook_default.Collection();
        const requestDefaults = {
          baseUrl: request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, options.request, {
            // @ts-ignore internal usage only, no need to type
            hook: hook2.bind(null, "request")
          }),
          mediaType: {
            previews: [],
            format: ""
          }
        };
        requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
        if (options.baseUrl) {
          requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
          requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
          requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = request.defaults(requestDefaults);
        this.graphql = withCustomRequest(this.request).defaults(requestDefaults);
        this.log = createLogger(options.log);
        this.hook = hook2;
        if (!options.authStrategy) {
          if (!options.auth) {
            this.auth = async () => ({
              type: "unauthenticated"
            });
          } else {
            const auth2 = createTokenAuth(options.auth);
            hook2.wrap("request", auth2.hook);
            this.auth = auth2;
          }
        } else {
          const { authStrategy, ...otherOptions } = options;
          const auth2 = authStrategy(Object.assign({
            request: this.request,
            log: this.log,
            // we pass the current octokit instance as well as its constructor options
            // to allow for authentication strategies that return a new octokit instance
            // that shares the same internal state as the current one. The original
            // requirement for this was the "event-octokit" authentication strategy
            // of https://github.com/probot/octokit-auth-probot.
            octokit: this,
            octokitOptions: otherOptions
          }, options.auth));
          hook2.wrap("request", auth2.hook);
          this.auth = auth2;
        }
        const classConstructor = this.constructor;
        for (let i2 = 0; i2 < classConstructor.plugins.length; ++i2) {
          Object.assign(this, classConstructor.plugins[i2](this, options));
        }
      }
      // assigned during constructor
      request;
      graphql;
      log;
      hook;
      // TODO: type `octokit.auth` based on passed options.authStrategy
      auth;
    };
  }
});

// node_modules/.pnpm/@octokit+plugin-request-log@5.3.1_@octokit+core@6.1.6/node_modules/@octokit/plugin-request-log/dist-src/version.js
var VERSION5;
var init_version2 = __esm({
  "node_modules/.pnpm/@octokit+plugin-request-log@5.3.1_@octokit+core@6.1.6/node_modules/@octokit/plugin-request-log/dist-src/version.js"() {
    VERSION5 = "5.3.1";
  }
});

// node_modules/.pnpm/@octokit+plugin-request-log@5.3.1_@octokit+core@6.1.6/node_modules/@octokit/plugin-request-log/dist-src/index.js
function requestLog(octokit) {
  octokit.hook.wrap("request", (request2, options) => {
    octokit.log.debug("request", options);
    const start2 = Date.now();
    const requestOptions = octokit.request.endpoint.parse(options);
    const path4 = requestOptions.url.replace(options.baseUrl, "");
    return request2(options).then((response) => {
      const requestId = response.headers["x-github-request-id"];
      octokit.log.info(`${requestOptions.method} ${path4} - ${response.status} with id ${requestId} in ${Date.now() - start2}ms`);
      return response;
    }).catch((error45) => {
      const requestId = error45.response?.headers["x-github-request-id"] || "UNKNOWN";
      octokit.log.error(`${requestOptions.method} ${path4} - ${error45.status} with id ${requestId} in ${Date.now() - start2}ms`);
      throw error45;
    });
  });
}
var init_dist_src3 = __esm({
  "node_modules/.pnpm/@octokit+plugin-request-log@5.3.1_@octokit+core@6.1.6/node_modules/@octokit/plugin-request-log/dist-src/index.js"() {
    init_version2();
    __name(requestLog, "requestLog");
    requestLog.VERSION = VERSION5;
  }
});

// node_modules/.pnpm/@octokit+plugin-paginate-rest@11.6.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js
function normalizePaginatedListResponse(response) {
  if (!response.data) {
    return {
      ...response,
      data: []
    };
  }
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization) return response;
  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;
  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }
  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }
  response.data.total_count = totalCount;
  return response;
}
function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url2 = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url2) return {
          done: true
        };
        try {
          const response = await requestMethod({
            method,
            url: url2,
            headers
          });
          const normalizedResponse = normalizePaginatedListResponse(response);
          url2 = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
          return {
            value: normalizedResponse
          };
        } catch (error45) {
          if (error45.status !== 409) throw error45;
          url2 = "";
          return {
            value: {
              status: 200,
              headers: {},
              data: []
            }
          };
        }
      }
    })
  };
}
function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = void 0;
  }
  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
  return iterator2.next().then((result) => {
    if (result.done) {
      return results;
    }
    let earlyExit = false;
    function done() {
      earlyExit = true;
    }
    __name(done, "done");
    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
    if (earlyExit) {
      return results;
    }
    return gather(octokit, results, iterator2, mapFn);
  });
}
function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
var VERSION6, composePaginateRest;
var init_dist_bundle5 = __esm({
  "node_modules/.pnpm/@octokit+plugin-paginate-rest@11.6.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js"() {
    VERSION6 = "0.0.0-development";
    __name(normalizePaginatedListResponse, "normalizePaginatedListResponse");
    __name(iterator, "iterator");
    __name(paginate, "paginate");
    __name(gather, "gather");
    composePaginateRest = Object.assign(paginate, {
      iterator
    });
    __name(paginateRest, "paginateRest");
    paginateRest.VERSION = VERSION6;
  }
});

// node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js
var VERSION7;
var init_version3 = __esm({
  "node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js"() {
    VERSION7 = "13.5.0";
  }
});

// node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js
var Endpoints, endpoints_default;
var init_endpoints = __esm({
  "node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js"() {
    Endpoints = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
          "POST /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        addRepoAccessToSelfHostedRunnerGroupInOrg: [
          "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        approveWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
        ],
        cancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
        ],
        createEnvironmentVariable: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
        ],
        createHostedRunnerForOrg: [
          "POST /orgs/{org}/actions/hosted-runners"
        ],
        createOrUpdateEnvironmentSecret: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        ],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        createOrgVariable: [
          "POST /orgs/{org}/actions/variables"
        ],
        createRegistrationTokenForOrg: [
          "POST /orgs/{org}/actions/runners/registration-token"
        ],
        createRegistrationTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/registration-token"
        ],
        createRemoveTokenForOrg: [
          "POST /orgs/{org}/actions/runners/remove-token"
        ],
        createRemoveTokenForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/remove-token"
        ],
        createRepoVariable: [
          "POST /repos/{owner}/{repo}/actions/variables"
        ],
        createWorkflowDispatch: [
          "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        ],
        deleteActionsCacheById: [
          "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
        ],
        deleteActionsCacheByKey: [
          "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
        ],
        deleteArtifact: [
          "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        deleteEnvironmentSecret: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        ],
        deleteEnvironmentVariable: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        ],
        deleteHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        ],
        deleteOrgSecret: [
          "DELETE /orgs/{org}/actions/secrets/{secret_name}"
        ],
        deleteOrgVariable: [
          "DELETE /orgs/{org}/actions/variables/{name}"
        ],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        deleteRepoVariable: [
          "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        deleteSelfHostedRunnerFromOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}"
        ],
        deleteSelfHostedRunnerFromRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        deleteWorkflowRun: [
          "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"
        ],
        deleteWorkflowRunLogs: [
          "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
          "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        disableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
        ],
        downloadArtifact: [
          "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
        ],
        downloadJobLogsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
        ],
        downloadWorkflowRunAttemptLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
        ],
        downloadWorkflowRunLogs: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        enableWorkflow: [
          "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
        ],
        forceCancelWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
        ],
        generateRunnerJitconfigForOrg: [
          "POST /orgs/{org}/actions/runners/generate-jitconfig"
        ],
        generateRunnerJitconfigForRepo: [
          "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
        ],
        getActionsCacheList: [
          "GET /repos/{owner}/{repo}/actions/caches"
        ],
        getActionsCacheUsage: [
          "GET /repos/{owner}/{repo}/actions/cache/usage"
        ],
        getActionsCacheUsageByRepoForOrg: [
          "GET /orgs/{org}/actions/cache/usage-by-repository"
        ],
        getActionsCacheUsageForOrg: [
          "GET /orgs/{org}/actions/cache/usage"
        ],
        getAllowedActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/selected-actions"
        ],
        getAllowedActionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        getArtifact: [
          "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        getCustomOidcSubClaimForRepo: [
          "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        getEnvironmentPublicKey: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
        ],
        getEnvironmentSecret: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        ],
        getEnvironmentVariable: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions/workflow"
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        getGithubActionsPermissionsOrganization: [
          "GET /orgs/{org}/actions/permissions"
        ],
        getGithubActionsPermissionsRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions"
        ],
        getHostedRunnerForOrg: [
          "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        ],
        getHostedRunnersGithubOwnedImagesForOrg: [
          "GET /orgs/{org}/actions/hosted-runners/images/github-owned"
        ],
        getHostedRunnersLimitsForOrg: [
          "GET /orgs/{org}/actions/hosted-runners/limits"
        ],
        getHostedRunnersMachineSpecsForOrg: [
          "GET /orgs/{org}/actions/hosted-runners/machine-sizes"
        ],
        getHostedRunnersPartnerImagesForOrg: [
          "GET /orgs/{org}/actions/hosted-runners/images/partner"
        ],
        getHostedRunnersPlatformsForOrg: [
          "GET /orgs/{org}/actions/hosted-runners/platforms"
        ],
        getJobForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/jobs/{job_id}"
        ],
        getOrgPublicKey: [
          "GET /orgs/{org}/actions/secrets/public-key"
        ],
        getOrgSecret: [
          "GET /orgs/{org}/actions/secrets/{secret_name}"
        ],
        getOrgVariable: [
          "GET /orgs/{org}/actions/variables/{name}"
        ],
        getPendingDeploymentsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        getRepoPermissions: [
          "GET /repos/{owner}/{repo}/actions/permissions",
          {},
          {
            renamed: [
              "actions",
              "getGithubActionsPermissionsRepository"
            ]
          }
        ],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/actions/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        getRepoVariable: [
          "GET /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        getReviewsForRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
        ],
        getSelfHostedRunnerForOrg: [
          "GET /orgs/{org}/actions/runners/{runner_id}"
        ],
        getSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        getWorkflow: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"
        ],
        getWorkflowAccessToRepository: [
          "GET /repos/{owner}/{repo}/actions/permissions/access"
        ],
        getWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}"
        ],
        getWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
        ],
        getWorkflowRunUsage: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
        ],
        getWorkflowUsage: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
        ],
        listArtifactsForRepo: [
          "GET /repos/{owner}/{repo}/actions/artifacts"
        ],
        listEnvironmentSecrets: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
        ],
        listEnvironmentVariables: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
        ],
        listGithubHostedRunnersInGroupForOrg: [
          "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
        ],
        listHostedRunnersForOrg: [
          "GET /orgs/{org}/actions/hosted-runners"
        ],
        listJobsForWorkflowRun: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        ],
        listJobsForWorkflowRunAttempt: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
        ],
        listLabelsForSelfHostedRunnerForOrg: [
          "GET /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        listLabelsForSelfHostedRunnerForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        listOrgSecrets: [
          "GET /orgs/{org}/actions/secrets"
        ],
        listOrgVariables: [
          "GET /orgs/{org}/actions/variables"
        ],
        listRepoOrganizationSecrets: [
          "GET /repos/{owner}/{repo}/actions/organization-secrets"
        ],
        listRepoOrganizationVariables: [
          "GET /repos/{owner}/{repo}/actions/organization-variables"
        ],
        listRepoSecrets: [
          "GET /repos/{owner}/{repo}/actions/secrets"
        ],
        listRepoVariables: [
          "GET /repos/{owner}/{repo}/actions/variables"
        ],
        listRepoWorkflows: [
          "GET /repos/{owner}/{repo}/actions/workflows"
        ],
        listRunnerApplicationsForOrg: [
          "GET /orgs/{org}/actions/runners/downloads"
        ],
        listRunnerApplicationsForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners/downloads"
        ],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        listSelectedReposForOrgVariable: [
          "GET /orgs/{org}/actions/variables/{name}/repositories"
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
          "GET /orgs/{org}/actions/permissions/repositories"
        ],
        listSelfHostedRunnersForOrg: [
          "GET /orgs/{org}/actions/runners"
        ],
        listSelfHostedRunnersForRepo: [
          "GET /repos/{owner}/{repo}/actions/runners"
        ],
        listWorkflowRunArtifacts: [
          "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
        ],
        listWorkflowRuns: [
          "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
        ],
        listWorkflowRunsForRepo: [
          "GET /repos/{owner}/{repo}/actions/runs"
        ],
        reRunJobForWorkflowRun: [
          "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
        ],
        reRunWorkflow: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
        ],
        reRunWorkflowFailedJobs: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
          "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
          "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgVariable: [
          "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        reviewCustomGatesForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
        ],
        reviewPendingDeploymentsForRun: [
          "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        setAllowedActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/selected-actions"
        ],
        setAllowedActionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
          "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
          "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        setCustomOidcSubClaimForRepo: [
          "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/workflow"
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        setGithubActionsPermissionsOrganization: [
          "PUT /orgs/{org}/actions/permissions"
        ],
        setGithubActionsPermissionsRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgVariable: [
          "PUT /orgs/{org}/actions/variables/{name}/repositories"
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
          "PUT /orgs/{org}/actions/permissions/repositories"
        ],
        setWorkflowAccessToRepository: [
          "PUT /repos/{owner}/{repo}/actions/permissions/access"
        ],
        updateEnvironmentVariable: [
          "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        ],
        updateHostedRunnerForOrg: [
          "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        ],
        updateOrgVariable: [
          "PATCH /orgs/{org}/actions/variables/{name}"
        ],
        updateRepoVariable: [
          "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
        ]
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: [
          "GET /user/starred/{owner}/{repo}"
        ],
        deleteRepoSubscription: [
          "DELETE /repos/{owner}/{repo}/subscription"
        ],
        deleteThreadSubscription: [
          "DELETE /notifications/threads/{thread_id}/subscription"
        ],
        getFeeds: [
          "GET /feeds"
        ],
        getRepoSubscription: [
          "GET /repos/{owner}/{repo}/subscription"
        ],
        getThread: [
          "GET /notifications/threads/{thread_id}"
        ],
        getThreadSubscriptionForAuthenticatedUser: [
          "GET /notifications/threads/{thread_id}/subscription"
        ],
        listEventsForAuthenticatedUser: [
          "GET /users/{username}/events"
        ],
        listNotificationsForAuthenticatedUser: [
          "GET /notifications"
        ],
        listOrgEventsForAuthenticatedUser: [
          "GET /users/{username}/events/orgs/{org}"
        ],
        listPublicEvents: [
          "GET /events"
        ],
        listPublicEventsForRepoNetwork: [
          "GET /networks/{owner}/{repo}/events"
        ],
        listPublicEventsForUser: [
          "GET /users/{username}/events/public"
        ],
        listPublicOrgEvents: [
          "GET /orgs/{org}/events"
        ],
        listReceivedEventsForUser: [
          "GET /users/{username}/received_events"
        ],
        listReceivedPublicEventsForUser: [
          "GET /users/{username}/received_events/public"
        ],
        listRepoEvents: [
          "GET /repos/{owner}/{repo}/events"
        ],
        listRepoNotificationsForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/notifications"
        ],
        listReposStarredByAuthenticatedUser: [
          "GET /user/starred"
        ],
        listReposStarredByUser: [
          "GET /users/{username}/starred"
        ],
        listReposWatchedByUser: [
          "GET /users/{username}/subscriptions"
        ],
        listStargazersForRepo: [
          "GET /repos/{owner}/{repo}/stargazers"
        ],
        listWatchedReposForAuthenticatedUser: [
          "GET /user/subscriptions"
        ],
        listWatchersForRepo: [
          "GET /repos/{owner}/{repo}/subscribers"
        ],
        markNotificationsAsRead: [
          "PUT /notifications"
        ],
        markRepoNotificationsAsRead: [
          "PUT /repos/{owner}/{repo}/notifications"
        ],
        markThreadAsDone: [
          "DELETE /notifications/threads/{thread_id}"
        ],
        markThreadAsRead: [
          "PATCH /notifications/threads/{thread_id}"
        ],
        setRepoSubscription: [
          "PUT /repos/{owner}/{repo}/subscription"
        ],
        setThreadSubscription: [
          "PUT /notifications/threads/{thread_id}/subscription"
        ],
        starRepoForAuthenticatedUser: [
          "PUT /user/starred/{owner}/{repo}"
        ],
        unstarRepoForAuthenticatedUser: [
          "DELETE /user/starred/{owner}/{repo}"
        ]
      },
      apps: {
        addRepoToInstallation: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          {
            renamed: [
              "apps",
              "addRepoToInstallationForAuthenticatedUser"
            ]
          }
        ],
        addRepoToInstallationForAuthenticatedUser: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        checkToken: [
          "POST /applications/{client_id}/token"
        ],
        createFromManifest: [
          "POST /app-manifests/{code}/conversions"
        ],
        createInstallationAccessToken: [
          "POST /app/installations/{installation_id}/access_tokens"
        ],
        deleteAuthorization: [
          "DELETE /applications/{client_id}/grant"
        ],
        deleteInstallation: [
          "DELETE /app/installations/{installation_id}"
        ],
        deleteToken: [
          "DELETE /applications/{client_id}/token"
        ],
        getAuthenticated: [
          "GET /app"
        ],
        getBySlug: [
          "GET /apps/{app_slug}"
        ],
        getInstallation: [
          "GET /app/installations/{installation_id}"
        ],
        getOrgInstallation: [
          "GET /orgs/{org}/installation"
        ],
        getRepoInstallation: [
          "GET /repos/{owner}/{repo}/installation"
        ],
        getSubscriptionPlanForAccount: [
          "GET /marketplace_listing/accounts/{account_id}"
        ],
        getSubscriptionPlanForAccountStubbed: [
          "GET /marketplace_listing/stubbed/accounts/{account_id}"
        ],
        getUserInstallation: [
          "GET /users/{username}/installation"
        ],
        getWebhookConfigForApp: [
          "GET /app/hook/config"
        ],
        getWebhookDelivery: [
          "GET /app/hook/deliveries/{delivery_id}"
        ],
        listAccountsForPlan: [
          "GET /marketplace_listing/plans/{plan_id}/accounts"
        ],
        listAccountsForPlanStubbed: [
          "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
        ],
        listInstallationReposForAuthenticatedUser: [
          "GET /user/installations/{installation_id}/repositories"
        ],
        listInstallationRequestsForAuthenticatedApp: [
          "GET /app/installation-requests"
        ],
        listInstallations: [
          "GET /app/installations"
        ],
        listInstallationsForAuthenticatedUser: [
          "GET /user/installations"
        ],
        listPlans: [
          "GET /marketplace_listing/plans"
        ],
        listPlansStubbed: [
          "GET /marketplace_listing/stubbed/plans"
        ],
        listReposAccessibleToInstallation: [
          "GET /installation/repositories"
        ],
        listSubscriptionsForAuthenticatedUser: [
          "GET /user/marketplace_purchases"
        ],
        listSubscriptionsForAuthenticatedUserStubbed: [
          "GET /user/marketplace_purchases/stubbed"
        ],
        listWebhookDeliveries: [
          "GET /app/hook/deliveries"
        ],
        redeliverWebhookDelivery: [
          "POST /app/hook/deliveries/{delivery_id}/attempts"
        ],
        removeRepoFromInstallation: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          {
            renamed: [
              "apps",
              "removeRepoFromInstallationForAuthenticatedUser"
            ]
          }
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        resetToken: [
          "PATCH /applications/{client_id}/token"
        ],
        revokeInstallationAccessToken: [
          "DELETE /installation/token"
        ],
        scopeToken: [
          "POST /applications/{client_id}/token/scoped"
        ],
        suspendInstallation: [
          "PUT /app/installations/{installation_id}/suspended"
        ],
        unsuspendInstallation: [
          "DELETE /app/installations/{installation_id}/suspended"
        ],
        updateWebhookConfigForApp: [
          "PATCH /app/hook/config"
        ]
      },
      billing: {
        getGithubActionsBillingOrg: [
          "GET /orgs/{org}/settings/billing/actions"
        ],
        getGithubActionsBillingUser: [
          "GET /users/{username}/settings/billing/actions"
        ],
        getGithubBillingUsageReportOrg: [
          "GET /organizations/{org}/settings/billing/usage"
        ],
        getGithubPackagesBillingOrg: [
          "GET /orgs/{org}/settings/billing/packages"
        ],
        getGithubPackagesBillingUser: [
          "GET /users/{username}/settings/billing/packages"
        ],
        getSharedStorageBillingOrg: [
          "GET /orgs/{org}/settings/billing/shared-storage"
        ],
        getSharedStorageBillingUser: [
          "GET /users/{username}/settings/billing/shared-storage"
        ]
      },
      checks: {
        create: [
          "POST /repos/{owner}/{repo}/check-runs"
        ],
        createSuite: [
          "POST /repos/{owner}/{repo}/check-suites"
        ],
        get: [
          "GET /repos/{owner}/{repo}/check-runs/{check_run_id}"
        ],
        getSuite: [
          "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"
        ],
        listAnnotations: [
          "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
        ],
        listForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/check-runs"
        ],
        listForSuite: [
          "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
        ],
        listSuitesForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/check-suites"
        ],
        rerequestRun: [
          "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
        ],
        rerequestSuite: [
          "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
        ],
        setSuitesPreferences: [
          "PATCH /repos/{owner}/{repo}/check-suites/preferences"
        ],
        update: [
          "PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"
        ]
      },
      codeScanning: {
        commitAutofix: [
          "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
        ],
        createAutofix: [
          "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
        ],
        createVariantAnalysis: [
          "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
        ],
        deleteAnalysis: [
          "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
        ],
        deleteCodeqlDatabase: [
          "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getAlert: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
          {},
          {
            renamedParameters: {
              alert_id: "alert_number"
            }
          }
        ],
        getAnalysis: [
          "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        ],
        getAutofix: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
        ],
        getCodeqlDatabase: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getDefaultSetup: [
          "GET /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        getSarif: [
          "GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"
        ],
        getVariantAnalysis: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
        ],
        getVariantAnalysisRepoTask: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
        ],
        listAlertInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
        ],
        listAlertsForOrg: [
          "GET /orgs/{org}/code-scanning/alerts"
        ],
        listAlertsForRepo: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts"
        ],
        listAlertsInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          {},
          {
            renamed: [
              "codeScanning",
              "listAlertInstances"
            ]
          }
        ],
        listCodeqlDatabases: [
          "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
        ],
        listRecentAnalyses: [
          "GET /repos/{owner}/{repo}/code-scanning/analyses"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        ],
        updateDefaultSetup: [
          "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        uploadSarif: [
          "POST /repos/{owner}/{repo}/code-scanning/sarifs"
        ]
      },
      codeSecurity: {
        attachConfiguration: [
          "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
        ],
        attachEnterpriseConfiguration: [
          "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
        ],
        createConfiguration: [
          "POST /orgs/{org}/code-security/configurations"
        ],
        createConfigurationForEnterprise: [
          "POST /enterprises/{enterprise}/code-security/configurations"
        ],
        deleteConfiguration: [
          "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
        ],
        deleteConfigurationForEnterprise: [
          "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        ],
        detachConfiguration: [
          "DELETE /orgs/{org}/code-security/configurations/detach"
        ],
        getConfiguration: [
          "GET /orgs/{org}/code-security/configurations/{configuration_id}"
        ],
        getConfigurationForRepository: [
          "GET /repos/{owner}/{repo}/code-security-configuration"
        ],
        getConfigurationsForEnterprise: [
          "GET /enterprises/{enterprise}/code-security/configurations"
        ],
        getConfigurationsForOrg: [
          "GET /orgs/{org}/code-security/configurations"
        ],
        getDefaultConfigurations: [
          "GET /orgs/{org}/code-security/configurations/defaults"
        ],
        getDefaultConfigurationsForEnterprise: [
          "GET /enterprises/{enterprise}/code-security/configurations/defaults"
        ],
        getRepositoriesForConfiguration: [
          "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
        ],
        getRepositoriesForEnterpriseConfiguration: [
          "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
        ],
        getSingleConfigurationForEnterprise: [
          "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        ],
        setConfigurationAsDefault: [
          "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
        ],
        setConfigurationAsDefaultForEnterprise: [
          "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
        ],
        updateConfiguration: [
          "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
        ],
        updateEnterpriseConfiguration: [
          "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        ]
      },
      codesOfConduct: {
        getAllCodesOfConduct: [
          "GET /codes_of_conduct"
        ],
        getConductCode: [
          "GET /codes_of_conduct/{key}"
        ]
      },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        checkPermissionsForDevcontainer: [
          "GET /repos/{owner}/{repo}/codespaces/permissions_check"
        ],
        codespaceMachinesForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/machines"
        ],
        createForAuthenticatedUser: [
          "POST /user/codespaces"
        ],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}"
        ],
        createWithPrForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
        ],
        createWithRepoForAuthenticatedUser: [
          "POST /repos/{owner}/{repo}/codespaces"
        ],
        deleteForAuthenticatedUser: [
          "DELETE /user/codespaces/{codespace_name}"
        ],
        deleteFromOrganization: [
          "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
        ],
        deleteOrgSecret: [
          "DELETE /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        deleteSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}"
        ],
        exportForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/exports"
        ],
        getCodespacesForUserInOrg: [
          "GET /orgs/{org}/members/{username}/codespaces"
        ],
        getExportDetailsForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}/exports/{export_id}"
        ],
        getForAuthenticatedUser: [
          "GET /user/codespaces/{codespace_name}"
        ],
        getOrgPublicKey: [
          "GET /orgs/{org}/codespaces/secrets/public-key"
        ],
        getOrgSecret: [
          "GET /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        getPublicKeyForAuthenticatedUser: [
          "GET /user/codespaces/secrets/public-key"
        ],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        getSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}"
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/devcontainers"
        ],
        listForAuthenticatedUser: [
          "GET /user/codespaces"
        ],
        listInOrganization: [
          "GET /orgs/{org}/codespaces",
          {},
          {
            renamedParameters: {
              org_id: "org"
            }
          }
        ],
        listInRepositoryForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces"
        ],
        listOrgSecrets: [
          "GET /orgs/{org}/codespaces/secrets"
        ],
        listRepoSecrets: [
          "GET /repos/{owner}/{repo}/codespaces/secrets"
        ],
        listRepositoriesForSecretForAuthenticatedUser: [
          "GET /user/codespaces/secrets/{secret_name}/repositories"
        ],
        listSecretsForAuthenticatedUser: [
          "GET /user/codespaces/secrets"
        ],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        preFlightWithRepoForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/new"
        ],
        publishForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/publish"
        ],
        removeRepositoryForSecretForAuthenticatedUser: [
          "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        repoMachinesForAuthenticatedUser: [
          "GET /repos/{owner}/{repo}/codespaces/machines"
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
          "PUT /user/codespaces/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        startForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/start"
        ],
        stopForAuthenticatedUser: [
          "POST /user/codespaces/{codespace_name}/stop"
        ],
        stopInOrganization: [
          "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
        ],
        updateForAuthenticatedUser: [
          "PATCH /user/codespaces/{codespace_name}"
        ]
      },
      copilot: {
        addCopilotSeatsForTeams: [
          "POST /orgs/{org}/copilot/billing/selected_teams"
        ],
        addCopilotSeatsForUsers: [
          "POST /orgs/{org}/copilot/billing/selected_users"
        ],
        cancelCopilotSeatAssignmentForTeams: [
          "DELETE /orgs/{org}/copilot/billing/selected_teams"
        ],
        cancelCopilotSeatAssignmentForUsers: [
          "DELETE /orgs/{org}/copilot/billing/selected_users"
        ],
        copilotMetricsForOrganization: [
          "GET /orgs/{org}/copilot/metrics"
        ],
        copilotMetricsForTeam: [
          "GET /orgs/{org}/team/{team_slug}/copilot/metrics"
        ],
        getCopilotOrganizationDetails: [
          "GET /orgs/{org}/copilot/billing"
        ],
        getCopilotSeatDetailsForUser: [
          "GET /orgs/{org}/members/{username}/copilot"
        ],
        listCopilotSeats: [
          "GET /orgs/{org}/copilot/billing/seats"
        ],
        usageMetricsForOrg: [
          "GET /orgs/{org}/copilot/usage"
        ],
        usageMetricsForTeam: [
          "GET /orgs/{org}/team/{team_slug}/copilot/usage"
        ]
      },
      dependabot: {
        addSelectedRepoToOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        createOrUpdateOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
          "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        deleteOrgSecret: [
          "DELETE /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        deleteRepoSecret: [
          "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        getAlert: [
          "GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ],
        getOrgPublicKey: [
          "GET /orgs/{org}/dependabot/secrets/public-key"
        ],
        getOrgSecret: [
          "GET /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        getRepoPublicKey: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
        ],
        getRepoSecret: [
          "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/dependabot/alerts"
        ],
        listAlertsForOrg: [
          "GET /orgs/{org}/dependabot/alerts"
        ],
        listAlertsForRepo: [
          "GET /repos/{owner}/{repo}/dependabot/alerts"
        ],
        listOrgSecrets: [
          "GET /orgs/{org}/dependabot/secrets"
        ],
        listRepoSecrets: [
          "GET /repos/{owner}/{repo}/dependabot/secrets"
        ],
        listSelectedReposForOrgSecret: [
          "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        removeSelectedRepoFromOrgSecret: [
          "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        setSelectedReposForOrgSecret: [
          "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ]
      },
      dependencyGraph: {
        createRepositorySnapshot: [
          "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
        ],
        diffRange: [
          "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
        ],
        exportSbom: [
          "GET /repos/{owner}/{repo}/dependency-graph/sbom"
        ]
      },
      emojis: {
        get: [
          "GET /emojis"
        ]
      },
      gists: {
        checkIsStarred: [
          "GET /gists/{gist_id}/star"
        ],
        create: [
          "POST /gists"
        ],
        createComment: [
          "POST /gists/{gist_id}/comments"
        ],
        delete: [
          "DELETE /gists/{gist_id}"
        ],
        deleteComment: [
          "DELETE /gists/{gist_id}/comments/{comment_id}"
        ],
        fork: [
          "POST /gists/{gist_id}/forks"
        ],
        get: [
          "GET /gists/{gist_id}"
        ],
        getComment: [
          "GET /gists/{gist_id}/comments/{comment_id}"
        ],
        getRevision: [
          "GET /gists/{gist_id}/{sha}"
        ],
        list: [
          "GET /gists"
        ],
        listComments: [
          "GET /gists/{gist_id}/comments"
        ],
        listCommits: [
          "GET /gists/{gist_id}/commits"
        ],
        listForUser: [
          "GET /users/{username}/gists"
        ],
        listForks: [
          "GET /gists/{gist_id}/forks"
        ],
        listPublic: [
          "GET /gists/public"
        ],
        listStarred: [
          "GET /gists/starred"
        ],
        star: [
          "PUT /gists/{gist_id}/star"
        ],
        unstar: [
          "DELETE /gists/{gist_id}/star"
        ],
        update: [
          "PATCH /gists/{gist_id}"
        ],
        updateComment: [
          "PATCH /gists/{gist_id}/comments/{comment_id}"
        ]
      },
      git: {
        createBlob: [
          "POST /repos/{owner}/{repo}/git/blobs"
        ],
        createCommit: [
          "POST /repos/{owner}/{repo}/git/commits"
        ],
        createRef: [
          "POST /repos/{owner}/{repo}/git/refs"
        ],
        createTag: [
          "POST /repos/{owner}/{repo}/git/tags"
        ],
        createTree: [
          "POST /repos/{owner}/{repo}/git/trees"
        ],
        deleteRef: [
          "DELETE /repos/{owner}/{repo}/git/refs/{ref}"
        ],
        getBlob: [
          "GET /repos/{owner}/{repo}/git/blobs/{file_sha}"
        ],
        getCommit: [
          "GET /repos/{owner}/{repo}/git/commits/{commit_sha}"
        ],
        getRef: [
          "GET /repos/{owner}/{repo}/git/ref/{ref}"
        ],
        getTag: [
          "GET /repos/{owner}/{repo}/git/tags/{tag_sha}"
        ],
        getTree: [
          "GET /repos/{owner}/{repo}/git/trees/{tree_sha}"
        ],
        listMatchingRefs: [
          "GET /repos/{owner}/{repo}/git/matching-refs/{ref}"
        ],
        updateRef: [
          "PATCH /repos/{owner}/{repo}/git/refs/{ref}"
        ]
      },
      gitignore: {
        getAllTemplates: [
          "GET /gitignore/templates"
        ],
        getTemplate: [
          "GET /gitignore/templates/{name}"
        ]
      },
      hostedCompute: {
        createNetworkConfigurationForOrg: [
          "POST /orgs/{org}/settings/network-configurations"
        ],
        deleteNetworkConfigurationFromOrg: [
          "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"
        ],
        getNetworkConfigurationForOrg: [
          "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"
        ],
        getNetworkSettingsForOrg: [
          "GET /orgs/{org}/settings/network-settings/{network_settings_id}"
        ],
        listNetworkConfigurationsForOrg: [
          "GET /orgs/{org}/settings/network-configurations"
        ],
        updateNetworkConfigurationForOrg: [
          "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"
        ]
      },
      interactions: {
        getRestrictionsForAuthenticatedUser: [
          "GET /user/interaction-limits"
        ],
        getRestrictionsForOrg: [
          "GET /orgs/{org}/interaction-limits"
        ],
        getRestrictionsForRepo: [
          "GET /repos/{owner}/{repo}/interaction-limits"
        ],
        getRestrictionsForYourPublicRepos: [
          "GET /user/interaction-limits",
          {},
          {
            renamed: [
              "interactions",
              "getRestrictionsForAuthenticatedUser"
            ]
          }
        ],
        removeRestrictionsForAuthenticatedUser: [
          "DELETE /user/interaction-limits"
        ],
        removeRestrictionsForOrg: [
          "DELETE /orgs/{org}/interaction-limits"
        ],
        removeRestrictionsForRepo: [
          "DELETE /repos/{owner}/{repo}/interaction-limits"
        ],
        removeRestrictionsForYourPublicRepos: [
          "DELETE /user/interaction-limits",
          {},
          {
            renamed: [
              "interactions",
              "removeRestrictionsForAuthenticatedUser"
            ]
          }
        ],
        setRestrictionsForAuthenticatedUser: [
          "PUT /user/interaction-limits"
        ],
        setRestrictionsForOrg: [
          "PUT /orgs/{org}/interaction-limits"
        ],
        setRestrictionsForRepo: [
          "PUT /repos/{owner}/{repo}/interaction-limits"
        ],
        setRestrictionsForYourPublicRepos: [
          "PUT /user/interaction-limits",
          {},
          {
            renamed: [
              "interactions",
              "setRestrictionsForAuthenticatedUser"
            ]
          }
        ]
      },
      issues: {
        addAssignees: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        addLabels: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        addSubIssue: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
        ],
        checkUserCanBeAssigned: [
          "GET /repos/{owner}/{repo}/assignees/{assignee}"
        ],
        checkUserCanBeAssignedToIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
        ],
        create: [
          "POST /repos/{owner}/{repo}/issues"
        ],
        createComment: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        createLabel: [
          "POST /repos/{owner}/{repo}/labels"
        ],
        createMilestone: [
          "POST /repos/{owner}/{repo}/milestones"
        ],
        deleteComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        deleteLabel: [
          "DELETE /repos/{owner}/{repo}/labels/{name}"
        ],
        deleteMilestone: [
          "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        get: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}"
        ],
        getComment: [
          "GET /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        getEvent: [
          "GET /repos/{owner}/{repo}/issues/events/{event_id}"
        ],
        getLabel: [
          "GET /repos/{owner}/{repo}/labels/{name}"
        ],
        getMilestone: [
          "GET /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        list: [
          "GET /issues"
        ],
        listAssignees: [
          "GET /repos/{owner}/{repo}/assignees"
        ],
        listComments: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        listCommentsForRepo: [
          "GET /repos/{owner}/{repo}/issues/comments"
        ],
        listEvents: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/events"
        ],
        listEventsForRepo: [
          "GET /repos/{owner}/{repo}/issues/events"
        ],
        listEventsForTimeline: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
        ],
        listForAuthenticatedUser: [
          "GET /user/issues"
        ],
        listForOrg: [
          "GET /orgs/{org}/issues"
        ],
        listForRepo: [
          "GET /repos/{owner}/{repo}/issues"
        ],
        listLabelsForMilestone: [
          "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
        ],
        listLabelsForRepo: [
          "GET /repos/{owner}/{repo}/labels"
        ],
        listLabelsOnIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        listMilestones: [
          "GET /repos/{owner}/{repo}/milestones"
        ],
        listSubIssues: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
        ],
        lock: [
          "PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"
        ],
        removeAllLabels: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        removeAssignees: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        removeLabel: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
        ],
        removeSubIssue: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
        ],
        reprioritizeSubIssue: [
          "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
        ],
        setLabels: [
          "PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        unlock: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"
        ],
        update: [
          "PATCH /repos/{owner}/{repo}/issues/{issue_number}"
        ],
        updateComment: [
          "PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        updateLabel: [
          "PATCH /repos/{owner}/{repo}/labels/{name}"
        ],
        updateMilestone: [
          "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
        ]
      },
      licenses: {
        get: [
          "GET /licenses/{license}"
        ],
        getAllCommonlyUsed: [
          "GET /licenses"
        ],
        getForRepo: [
          "GET /repos/{owner}/{repo}/license"
        ]
      },
      markdown: {
        render: [
          "POST /markdown"
        ],
        renderRaw: [
          "POST /markdown/raw",
          {
            headers: {
              "content-type": "text/plain; charset=utf-8"
            }
          }
        ]
      },
      meta: {
        get: [
          "GET /meta"
        ],
        getAllVersions: [
          "GET /versions"
        ],
        getOctocat: [
          "GET /octocat"
        ],
        getZen: [
          "GET /zen"
        ],
        root: [
          "GET /"
        ]
      },
      migrations: {
        deleteArchiveForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/archive"
        ],
        deleteArchiveForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/archive"
        ],
        downloadArchiveForOrg: [
          "GET /orgs/{org}/migrations/{migration_id}/archive"
        ],
        getArchiveForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/archive"
        ],
        getStatusForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}"
        ],
        getStatusForOrg: [
          "GET /orgs/{org}/migrations/{migration_id}"
        ],
        listForAuthenticatedUser: [
          "GET /user/migrations"
        ],
        listForOrg: [
          "GET /orgs/{org}/migrations"
        ],
        listReposForAuthenticatedUser: [
          "GET /user/migrations/{migration_id}/repositories"
        ],
        listReposForOrg: [
          "GET /orgs/{org}/migrations/{migration_id}/repositories"
        ],
        listReposForUser: [
          "GET /user/migrations/{migration_id}/repositories",
          {},
          {
            renamed: [
              "migrations",
              "listReposForAuthenticatedUser"
            ]
          }
        ],
        startForAuthenticatedUser: [
          "POST /user/migrations"
        ],
        startForOrg: [
          "POST /orgs/{org}/migrations"
        ],
        unlockRepoForAuthenticatedUser: [
          "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        unlockRepoForOrg: [
          "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
        ]
      },
      oidc: {
        getOidcCustomSubTemplateForOrg: [
          "GET /orgs/{org}/actions/oidc/customization/sub"
        ],
        updateOidcCustomSubTemplateForOrg: [
          "PUT /orgs/{org}/actions/oidc/customization/sub"
        ]
      },
      orgs: {
        addSecurityManagerTeam: [
          "PUT /orgs/{org}/security-managers/teams/{team_slug}",
          {},
          {
            deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
          }
        ],
        assignTeamToOrgRole: [
          "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        assignUserToOrgRole: [
          "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        blockUser: [
          "PUT /orgs/{org}/blocks/{username}"
        ],
        cancelInvitation: [
          "DELETE /orgs/{org}/invitations/{invitation_id}"
        ],
        checkBlockedUser: [
          "GET /orgs/{org}/blocks/{username}"
        ],
        checkMembershipForUser: [
          "GET /orgs/{org}/members/{username}"
        ],
        checkPublicMembershipForUser: [
          "GET /orgs/{org}/public_members/{username}"
        ],
        convertMemberToOutsideCollaborator: [
          "PUT /orgs/{org}/outside_collaborators/{username}"
        ],
        createInvitation: [
          "POST /orgs/{org}/invitations"
        ],
        createIssueType: [
          "POST /orgs/{org}/issue-types"
        ],
        createOrUpdateCustomProperties: [
          "PATCH /orgs/{org}/properties/schema"
        ],
        createOrUpdateCustomPropertiesValuesForRepos: [
          "PATCH /orgs/{org}/properties/values"
        ],
        createOrUpdateCustomProperty: [
          "PUT /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        createWebhook: [
          "POST /orgs/{org}/hooks"
        ],
        delete: [
          "DELETE /orgs/{org}"
        ],
        deleteIssueType: [
          "DELETE /orgs/{org}/issue-types/{issue_type_id}"
        ],
        deleteWebhook: [
          "DELETE /orgs/{org}/hooks/{hook_id}"
        ],
        enableOrDisableSecurityProductOnAllOrgRepos: [
          "POST /orgs/{org}/{security_product}/{enablement}",
          {},
          {
            deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
          }
        ],
        get: [
          "GET /orgs/{org}"
        ],
        getAllCustomProperties: [
          "GET /orgs/{org}/properties/schema"
        ],
        getCustomProperty: [
          "GET /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        getMembershipForAuthenticatedUser: [
          "GET /user/memberships/orgs/{org}"
        ],
        getMembershipForUser: [
          "GET /orgs/{org}/memberships/{username}"
        ],
        getOrgRole: [
          "GET /orgs/{org}/organization-roles/{role_id}"
        ],
        getOrgRulesetHistory: [
          "GET /orgs/{org}/rulesets/{ruleset_id}/history"
        ],
        getOrgRulesetVersion: [
          "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
        ],
        getWebhook: [
          "GET /orgs/{org}/hooks/{hook_id}"
        ],
        getWebhookConfigForOrg: [
          "GET /orgs/{org}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
          "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        list: [
          "GET /organizations"
        ],
        listAppInstallations: [
          "GET /orgs/{org}/installations"
        ],
        listAttestations: [
          "GET /orgs/{org}/attestations/{subject_digest}"
        ],
        listBlockedUsers: [
          "GET /orgs/{org}/blocks"
        ],
        listCustomPropertiesValuesForRepos: [
          "GET /orgs/{org}/properties/values"
        ],
        listFailedInvitations: [
          "GET /orgs/{org}/failed_invitations"
        ],
        listForAuthenticatedUser: [
          "GET /user/orgs"
        ],
        listForUser: [
          "GET /users/{username}/orgs"
        ],
        listInvitationTeams: [
          "GET /orgs/{org}/invitations/{invitation_id}/teams"
        ],
        listIssueTypes: [
          "GET /orgs/{org}/issue-types"
        ],
        listMembers: [
          "GET /orgs/{org}/members"
        ],
        listMembershipsForAuthenticatedUser: [
          "GET /user/memberships/orgs"
        ],
        listOrgRoleTeams: [
          "GET /orgs/{org}/organization-roles/{role_id}/teams"
        ],
        listOrgRoleUsers: [
          "GET /orgs/{org}/organization-roles/{role_id}/users"
        ],
        listOrgRoles: [
          "GET /orgs/{org}/organization-roles"
        ],
        listOrganizationFineGrainedPermissions: [
          "GET /orgs/{org}/organization-fine-grained-permissions"
        ],
        listOutsideCollaborators: [
          "GET /orgs/{org}/outside_collaborators"
        ],
        listPatGrantRepositories: [
          "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
        ],
        listPatGrantRequestRepositories: [
          "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
        ],
        listPatGrantRequests: [
          "GET /orgs/{org}/personal-access-token-requests"
        ],
        listPatGrants: [
          "GET /orgs/{org}/personal-access-tokens"
        ],
        listPendingInvitations: [
          "GET /orgs/{org}/invitations"
        ],
        listPublicMembers: [
          "GET /orgs/{org}/public_members"
        ],
        listSecurityManagerTeams: [
          "GET /orgs/{org}/security-managers",
          {},
          {
            deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
          }
        ],
        listWebhookDeliveries: [
          "GET /orgs/{org}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: [
          "GET /orgs/{org}/hooks"
        ],
        pingWebhook: [
          "POST /orgs/{org}/hooks/{hook_id}/pings"
        ],
        redeliverWebhookDelivery: [
          "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeCustomProperty: [
          "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        removeMember: [
          "DELETE /orgs/{org}/members/{username}"
        ],
        removeMembershipForUser: [
          "DELETE /orgs/{org}/memberships/{username}"
        ],
        removeOutsideCollaborator: [
          "DELETE /orgs/{org}/outside_collaborators/{username}"
        ],
        removePublicMembershipForAuthenticatedUser: [
          "DELETE /orgs/{org}/public_members/{username}"
        ],
        removeSecurityManagerTeam: [
          "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
          {},
          {
            deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
          }
        ],
        reviewPatGrantRequest: [
          "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
        ],
        reviewPatGrantRequestsInBulk: [
          "POST /orgs/{org}/personal-access-token-requests"
        ],
        revokeAllOrgRolesTeam: [
          "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
        ],
        revokeAllOrgRolesUser: [
          "DELETE /orgs/{org}/organization-roles/users/{username}"
        ],
        revokeOrgRoleTeam: [
          "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        revokeOrgRoleUser: [
          "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        setMembershipForUser: [
          "PUT /orgs/{org}/memberships/{username}"
        ],
        setPublicMembershipForAuthenticatedUser: [
          "PUT /orgs/{org}/public_members/{username}"
        ],
        unblockUser: [
          "DELETE /orgs/{org}/blocks/{username}"
        ],
        update: [
          "PATCH /orgs/{org}"
        ],
        updateIssueType: [
          "PUT /orgs/{org}/issue-types/{issue_type_id}"
        ],
        updateMembershipForAuthenticatedUser: [
          "PATCH /user/memberships/orgs/{org}"
        ],
        updatePatAccess: [
          "POST /orgs/{org}/personal-access-tokens/{pat_id}"
        ],
        updatePatAccesses: [
          "POST /orgs/{org}/personal-access-tokens"
        ],
        updateWebhook: [
          "PATCH /orgs/{org}/hooks/{hook_id}"
        ],
        updateWebhookConfigForOrg: [
          "PATCH /orgs/{org}/hooks/{hook_id}/config"
        ]
      },
      packages: {
        deletePackageForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}"
        ],
        deletePackageForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        deletePackageForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}"
        ],
        deletePackageVersionForAuthenticatedUser: [
          "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForOrg: [
          "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForUser: [
          "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          {},
          {
            renamed: [
              "packages",
              "getAllPackageVersionsForPackageOwnedByOrg"
            ]
          }
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions",
          {},
          {
            renamed: [
              "packages",
              "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
            ]
          }
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions"
        ],
        getPackageForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}"
        ],
        getPackageForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        getPackageForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}"
        ],
        getPackageVersionForAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForOrganization: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForUser: [
          "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: [
          "GET /user/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForOrganization: [
          "GET /orgs/{org}/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForUser: [
          "GET /users/{username}/docker/conflicts"
        ],
        listPackagesForAuthenticatedUser: [
          "GET /user/packages"
        ],
        listPackagesForOrganization: [
          "GET /orgs/{org}/packages"
        ],
        listPackagesForUser: [
          "GET /users/{username}/packages"
        ],
        restorePackageForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageVersionForAuthenticatedUser: [
          "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForOrg: [
          "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForUser: [
          "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ]
      },
      privateRegistries: {
        createOrgPrivateRegistry: [
          "POST /orgs/{org}/private-registries"
        ],
        deleteOrgPrivateRegistry: [
          "DELETE /orgs/{org}/private-registries/{secret_name}"
        ],
        getOrgPrivateRegistry: [
          "GET /orgs/{org}/private-registries/{secret_name}"
        ],
        getOrgPublicKey: [
          "GET /orgs/{org}/private-registries/public-key"
        ],
        listOrgPrivateRegistries: [
          "GET /orgs/{org}/private-registries"
        ],
        updateOrgPrivateRegistry: [
          "PATCH /orgs/{org}/private-registries/{secret_name}"
        ]
      },
      projects: {
        addCollaborator: [
          "PUT /projects/{project_id}/collaborators/{username}",
          {},
          {
            deprecated: "octokit.rest.projects.addCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#add-project-collaborator"
          }
        ],
        createCard: [
          "POST /projects/columns/{column_id}/cards",
          {},
          {
            deprecated: "octokit.rest.projects.createCard() is deprecated, see https://docs.github.com/rest/projects/cards#create-a-project-card"
          }
        ],
        createColumn: [
          "POST /projects/{project_id}/columns",
          {},
          {
            deprecated: "octokit.rest.projects.createColumn() is deprecated, see https://docs.github.com/rest/projects/columns#create-a-project-column"
          }
        ],
        createForAuthenticatedUser: [
          "POST /user/projects",
          {},
          {
            deprecated: "octokit.rest.projects.createForAuthenticatedUser() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-user-project"
          }
        ],
        createForOrg: [
          "POST /orgs/{org}/projects",
          {},
          {
            deprecated: "octokit.rest.projects.createForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#create-an-organization-project"
          }
        ],
        createForRepo: [
          "POST /repos/{owner}/{repo}/projects",
          {},
          {
            deprecated: "octokit.rest.projects.createForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#create-a-repository-project"
          }
        ],
        delete: [
          "DELETE /projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.projects.delete() is deprecated, see https://docs.github.com/rest/projects/projects#delete-a-project"
          }
        ],
        deleteCard: [
          "DELETE /projects/columns/cards/{card_id}",
          {},
          {
            deprecated: "octokit.rest.projects.deleteCard() is deprecated, see https://docs.github.com/rest/projects/cards#delete-a-project-card"
          }
        ],
        deleteColumn: [
          "DELETE /projects/columns/{column_id}",
          {},
          {
            deprecated: "octokit.rest.projects.deleteColumn() is deprecated, see https://docs.github.com/rest/projects/columns#delete-a-project-column"
          }
        ],
        get: [
          "GET /projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.projects.get() is deprecated, see https://docs.github.com/rest/projects/projects#get-a-project"
          }
        ],
        getCard: [
          "GET /projects/columns/cards/{card_id}",
          {},
          {
            deprecated: "octokit.rest.projects.getCard() is deprecated, see https://docs.github.com/rest/projects/cards#get-a-project-card"
          }
        ],
        getColumn: [
          "GET /projects/columns/{column_id}",
          {},
          {
            deprecated: "octokit.rest.projects.getColumn() is deprecated, see https://docs.github.com/rest/projects/columns#get-a-project-column"
          }
        ],
        getPermissionForUser: [
          "GET /projects/{project_id}/collaborators/{username}/permission",
          {},
          {
            deprecated: "octokit.rest.projects.getPermissionForUser() is deprecated, see https://docs.github.com/rest/projects/collaborators#get-project-permission-for-a-user"
          }
        ],
        listCards: [
          "GET /projects/columns/{column_id}/cards",
          {},
          {
            deprecated: "octokit.rest.projects.listCards() is deprecated, see https://docs.github.com/rest/projects/cards#list-project-cards"
          }
        ],
        listCollaborators: [
          "GET /projects/{project_id}/collaborators",
          {},
          {
            deprecated: "octokit.rest.projects.listCollaborators() is deprecated, see https://docs.github.com/rest/projects/collaborators#list-project-collaborators"
          }
        ],
        listColumns: [
          "GET /projects/{project_id}/columns",
          {},
          {
            deprecated: "octokit.rest.projects.listColumns() is deprecated, see https://docs.github.com/rest/projects/columns#list-project-columns"
          }
        ],
        listForOrg: [
          "GET /orgs/{org}/projects",
          {},
          {
            deprecated: "octokit.rest.projects.listForOrg() is deprecated, see https://docs.github.com/rest/projects/projects#list-organization-projects"
          }
        ],
        listForRepo: [
          "GET /repos/{owner}/{repo}/projects",
          {},
          {
            deprecated: "octokit.rest.projects.listForRepo() is deprecated, see https://docs.github.com/rest/projects/projects#list-repository-projects"
          }
        ],
        listForUser: [
          "GET /users/{username}/projects",
          {},
          {
            deprecated: "octokit.rest.projects.listForUser() is deprecated, see https://docs.github.com/rest/projects/projects#list-user-projects"
          }
        ],
        moveCard: [
          "POST /projects/columns/cards/{card_id}/moves",
          {},
          {
            deprecated: "octokit.rest.projects.moveCard() is deprecated, see https://docs.github.com/rest/projects/cards#move-a-project-card"
          }
        ],
        moveColumn: [
          "POST /projects/columns/{column_id}/moves",
          {},
          {
            deprecated: "octokit.rest.projects.moveColumn() is deprecated, see https://docs.github.com/rest/projects/columns#move-a-project-column"
          }
        ],
        removeCollaborator: [
          "DELETE /projects/{project_id}/collaborators/{username}",
          {},
          {
            deprecated: "octokit.rest.projects.removeCollaborator() is deprecated, see https://docs.github.com/rest/projects/collaborators#remove-user-as-a-collaborator"
          }
        ],
        update: [
          "PATCH /projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.projects.update() is deprecated, see https://docs.github.com/rest/projects/projects#update-a-project"
          }
        ],
        updateCard: [
          "PATCH /projects/columns/cards/{card_id}",
          {},
          {
            deprecated: "octokit.rest.projects.updateCard() is deprecated, see https://docs.github.com/rest/projects/cards#update-an-existing-project-card"
          }
        ],
        updateColumn: [
          "PATCH /projects/columns/{column_id}",
          {},
          {
            deprecated: "octokit.rest.projects.updateColumn() is deprecated, see https://docs.github.com/rest/projects/columns#update-an-existing-project-column"
          }
        ]
      },
      pulls: {
        checkIfMerged: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"
        ],
        create: [
          "POST /repos/{owner}/{repo}/pulls"
        ],
        createReplyForReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
        ],
        createReview: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"
        ],
        createReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        deletePendingReview: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        deleteReviewComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        dismissReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
        ],
        get: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}"
        ],
        getReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        getReviewComment: [
          "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        list: [
          "GET /repos/{owner}/{repo}/pulls"
        ],
        listCommentsForReview: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
        ],
        listCommits: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"
        ],
        listFiles: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/files"
        ],
        listRequestedReviewers: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        listReviewComments: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        listReviewCommentsForRepo: [
          "GET /repos/{owner}/{repo}/pulls/comments"
        ],
        listReviews: [
          "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"
        ],
        merge: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"
        ],
        removeRequestedReviewers: [
          "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        requestReviewers: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        submitReview: [
          "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
        ],
        update: [
          "PATCH /repos/{owner}/{repo}/pulls/{pull_number}"
        ],
        updateBranch: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
        ],
        updateReview: [
          "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        updateReviewComment: [
          "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ]
      },
      rateLimit: {
        get: [
          "GET /rate_limit"
        ]
      },
      reactions: {
        createForCommitComment: [
          "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        createForIssue: [
          "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        createForIssueComment: [
          "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        createForPullRequestReviewComment: [
          "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        createForRelease: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        createForTeamDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        createForTeamDiscussionInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ],
        deleteForCommitComment: [
          "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForIssue: [
          "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
        ],
        deleteForIssueComment: [
          "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForPullRequestComment: [
          "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForRelease: [
          "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussion: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussionComment: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
        ],
        listForCommitComment: [
          "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        listForIssue: [
          "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        listForIssueComment: [
          "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        listForPullRequestReviewComment: [
          "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        listForRelease: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        listForTeamDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        listForTeamDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ]
      },
      repos: {
        acceptInvitation: [
          "PATCH /user/repository_invitations/{invitation_id}",
          {},
          {
            renamed: [
              "repos",
              "acceptInvitationForAuthenticatedUser"
            ]
          }
        ],
        acceptInvitationForAuthenticatedUser: [
          "PATCH /user/repository_invitations/{invitation_id}"
        ],
        addAppAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          {
            mapToData: "apps"
          }
        ],
        addCollaborator: [
          "PUT /repos/{owner}/{repo}/collaborators/{username}"
        ],
        addStatusCheckContexts: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          {
            mapToData: "contexts"
          }
        ],
        addTeamAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          {
            mapToData: "teams"
          }
        ],
        addUserAccessRestrictions: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          {
            mapToData: "users"
          }
        ],
        cancelPagesDeployment: [
          "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
        ],
        checkAutomatedSecurityFixes: [
          "GET /repos/{owner}/{repo}/automated-security-fixes"
        ],
        checkCollaborator: [
          "GET /repos/{owner}/{repo}/collaborators/{username}"
        ],
        checkPrivateVulnerabilityReporting: [
          "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        checkVulnerabilityAlerts: [
          "GET /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        codeownersErrors: [
          "GET /repos/{owner}/{repo}/codeowners/errors"
        ],
        compareCommits: [
          "GET /repos/{owner}/{repo}/compare/{base}...{head}"
        ],
        compareCommitsWithBasehead: [
          "GET /repos/{owner}/{repo}/compare/{basehead}"
        ],
        createAttestation: [
          "POST /repos/{owner}/{repo}/attestations"
        ],
        createAutolink: [
          "POST /repos/{owner}/{repo}/autolinks"
        ],
        createCommitComment: [
          "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        createCommitSignatureProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        createCommitStatus: [
          "POST /repos/{owner}/{repo}/statuses/{sha}"
        ],
        createDeployKey: [
          "POST /repos/{owner}/{repo}/keys"
        ],
        createDeployment: [
          "POST /repos/{owner}/{repo}/deployments"
        ],
        createDeploymentBranchPolicy: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        createDeploymentProtectionRule: [
          "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        createDeploymentStatus: [
          "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        createDispatchEvent: [
          "POST /repos/{owner}/{repo}/dispatches"
        ],
        createForAuthenticatedUser: [
          "POST /user/repos"
        ],
        createFork: [
          "POST /repos/{owner}/{repo}/forks"
        ],
        createInOrg: [
          "POST /orgs/{org}/repos"
        ],
        createOrUpdateCustomPropertiesValues: [
          "PATCH /repos/{owner}/{repo}/properties/values"
        ],
        createOrUpdateEnvironment: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        createOrUpdateFileContents: [
          "PUT /repos/{owner}/{repo}/contents/{path}"
        ],
        createOrgRuleset: [
          "POST /orgs/{org}/rulesets"
        ],
        createPagesDeployment: [
          "POST /repos/{owner}/{repo}/pages/deployments"
        ],
        createPagesSite: [
          "POST /repos/{owner}/{repo}/pages"
        ],
        createRelease: [
          "POST /repos/{owner}/{repo}/releases"
        ],
        createRepoRuleset: [
          "POST /repos/{owner}/{repo}/rulesets"
        ],
        createUsingTemplate: [
          "POST /repos/{template_owner}/{template_repo}/generate"
        ],
        createWebhook: [
          "POST /repos/{owner}/{repo}/hooks"
        ],
        declineInvitation: [
          "DELETE /user/repository_invitations/{invitation_id}",
          {},
          {
            renamed: [
              "repos",
              "declineInvitationForAuthenticatedUser"
            ]
          }
        ],
        declineInvitationForAuthenticatedUser: [
          "DELETE /user/repository_invitations/{invitation_id}"
        ],
        delete: [
          "DELETE /repos/{owner}/{repo}"
        ],
        deleteAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        deleteAdminBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        deleteAnEnvironment: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        deleteAutolink: [
          "DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"
        ],
        deleteBranchProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        deleteCommitComment: [
          "DELETE /repos/{owner}/{repo}/comments/{comment_id}"
        ],
        deleteCommitSignatureProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        deleteDeployKey: [
          "DELETE /repos/{owner}/{repo}/keys/{key_id}"
        ],
        deleteDeployment: [
          "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        deleteDeploymentBranchPolicy: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        deleteFile: [
          "DELETE /repos/{owner}/{repo}/contents/{path}"
        ],
        deleteInvitation: [
          "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        deleteOrgRuleset: [
          "DELETE /orgs/{org}/rulesets/{ruleset_id}"
        ],
        deletePagesSite: [
          "DELETE /repos/{owner}/{repo}/pages"
        ],
        deletePullRequestReviewProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        deleteRelease: [
          "DELETE /repos/{owner}/{repo}/releases/{release_id}"
        ],
        deleteReleaseAsset: [
          "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        deleteRepoRuleset: [
          "DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"
        ],
        deleteWebhook: [
          "DELETE /repos/{owner}/{repo}/hooks/{hook_id}"
        ],
        disableAutomatedSecurityFixes: [
          "DELETE /repos/{owner}/{repo}/automated-security-fixes"
        ],
        disableDeploymentProtectionRule: [
          "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        disablePrivateVulnerabilityReporting: [
          "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        disableVulnerabilityAlerts: [
          "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        downloadArchive: [
          "GET /repos/{owner}/{repo}/zipball/{ref}",
          {},
          {
            renamed: [
              "repos",
              "downloadZipballArchive"
            ]
          }
        ],
        downloadTarballArchive: [
          "GET /repos/{owner}/{repo}/tarball/{ref}"
        ],
        downloadZipballArchive: [
          "GET /repos/{owner}/{repo}/zipball/{ref}"
        ],
        enableAutomatedSecurityFixes: [
          "PUT /repos/{owner}/{repo}/automated-security-fixes"
        ],
        enablePrivateVulnerabilityReporting: [
          "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        enableVulnerabilityAlerts: [
          "PUT /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        generateReleaseNotes: [
          "POST /repos/{owner}/{repo}/releases/generate-notes"
        ],
        get: [
          "GET /repos/{owner}/{repo}"
        ],
        getAccessRestrictions: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        getAdminBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        getAllDeploymentProtectionRules: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        getAllEnvironments: [
          "GET /repos/{owner}/{repo}/environments"
        ],
        getAllStatusCheckContexts: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        ],
        getAllTopics: [
          "GET /repos/{owner}/{repo}/topics"
        ],
        getAppsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        ],
        getAutolink: [
          "GET /repos/{owner}/{repo}/autolinks/{autolink_id}"
        ],
        getBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}"
        ],
        getBranchProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        getBranchRules: [
          "GET /repos/{owner}/{repo}/rules/branches/{branch}"
        ],
        getClones: [
          "GET /repos/{owner}/{repo}/traffic/clones"
        ],
        getCodeFrequencyStats: [
          "GET /repos/{owner}/{repo}/stats/code_frequency"
        ],
        getCollaboratorPermissionLevel: [
          "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
        ],
        getCombinedStatusForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/status"
        ],
        getCommit: [
          "GET /repos/{owner}/{repo}/commits/{ref}"
        ],
        getCommitActivityStats: [
          "GET /repos/{owner}/{repo}/stats/commit_activity"
        ],
        getCommitComment: [
          "GET /repos/{owner}/{repo}/comments/{comment_id}"
        ],
        getCommitSignatureProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        getCommunityProfileMetrics: [
          "GET /repos/{owner}/{repo}/community/profile"
        ],
        getContent: [
          "GET /repos/{owner}/{repo}/contents/{path}"
        ],
        getContributorsStats: [
          "GET /repos/{owner}/{repo}/stats/contributors"
        ],
        getCustomDeploymentProtectionRule: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        getCustomPropertiesValues: [
          "GET /repos/{owner}/{repo}/properties/values"
        ],
        getDeployKey: [
          "GET /repos/{owner}/{repo}/keys/{key_id}"
        ],
        getDeployment: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        getDeploymentBranchPolicy: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        getDeploymentStatus: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
        ],
        getEnvironment: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        getLatestPagesBuild: [
          "GET /repos/{owner}/{repo}/pages/builds/latest"
        ],
        getLatestRelease: [
          "GET /repos/{owner}/{repo}/releases/latest"
        ],
        getOrgRuleSuite: [
          "GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"
        ],
        getOrgRuleSuites: [
          "GET /orgs/{org}/rulesets/rule-suites"
        ],
        getOrgRuleset: [
          "GET /orgs/{org}/rulesets/{ruleset_id}"
        ],
        getOrgRulesets: [
          "GET /orgs/{org}/rulesets"
        ],
        getPages: [
          "GET /repos/{owner}/{repo}/pages"
        ],
        getPagesBuild: [
          "GET /repos/{owner}/{repo}/pages/builds/{build_id}"
        ],
        getPagesDeployment: [
          "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
        ],
        getPagesHealthCheck: [
          "GET /repos/{owner}/{repo}/pages/health"
        ],
        getParticipationStats: [
          "GET /repos/{owner}/{repo}/stats/participation"
        ],
        getPullRequestReviewProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        getPunchCardStats: [
          "GET /repos/{owner}/{repo}/stats/punch_card"
        ],
        getReadme: [
          "GET /repos/{owner}/{repo}/readme"
        ],
        getReadmeInDirectory: [
          "GET /repos/{owner}/{repo}/readme/{dir}"
        ],
        getRelease: [
          "GET /repos/{owner}/{repo}/releases/{release_id}"
        ],
        getReleaseAsset: [
          "GET /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        getReleaseByTag: [
          "GET /repos/{owner}/{repo}/releases/tags/{tag}"
        ],
        getRepoRuleSuite: [
          "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
        ],
        getRepoRuleSuites: [
          "GET /repos/{owner}/{repo}/rulesets/rule-suites"
        ],
        getRepoRuleset: [
          "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"
        ],
        getRepoRulesetHistory: [
          "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
        ],
        getRepoRulesetVersion: [
          "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
        ],
        getRepoRulesets: [
          "GET /repos/{owner}/{repo}/rulesets"
        ],
        getStatusChecksProtection: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        getTeamsWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        ],
        getTopPaths: [
          "GET /repos/{owner}/{repo}/traffic/popular/paths"
        ],
        getTopReferrers: [
          "GET /repos/{owner}/{repo}/traffic/popular/referrers"
        ],
        getUsersWithAccessToProtectedBranch: [
          "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        ],
        getViews: [
          "GET /repos/{owner}/{repo}/traffic/views"
        ],
        getWebhook: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}"
        ],
        getWebhookConfigForRepo: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        listActivities: [
          "GET /repos/{owner}/{repo}/activity"
        ],
        listAttestations: [
          "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
        ],
        listAutolinks: [
          "GET /repos/{owner}/{repo}/autolinks"
        ],
        listBranches: [
          "GET /repos/{owner}/{repo}/branches"
        ],
        listBranchesForHeadCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
        ],
        listCollaborators: [
          "GET /repos/{owner}/{repo}/collaborators"
        ],
        listCommentsForCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        listCommitCommentsForRepo: [
          "GET /repos/{owner}/{repo}/comments"
        ],
        listCommitStatusesForRef: [
          "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
        ],
        listCommits: [
          "GET /repos/{owner}/{repo}/commits"
        ],
        listContributors: [
          "GET /repos/{owner}/{repo}/contributors"
        ],
        listCustomDeploymentRuleIntegrations: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
        ],
        listDeployKeys: [
          "GET /repos/{owner}/{repo}/keys"
        ],
        listDeploymentBranchPolicies: [
          "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        listDeploymentStatuses: [
          "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        listDeployments: [
          "GET /repos/{owner}/{repo}/deployments"
        ],
        listForAuthenticatedUser: [
          "GET /user/repos"
        ],
        listForOrg: [
          "GET /orgs/{org}/repos"
        ],
        listForUser: [
          "GET /users/{username}/repos"
        ],
        listForks: [
          "GET /repos/{owner}/{repo}/forks"
        ],
        listInvitations: [
          "GET /repos/{owner}/{repo}/invitations"
        ],
        listInvitationsForAuthenticatedUser: [
          "GET /user/repository_invitations"
        ],
        listLanguages: [
          "GET /repos/{owner}/{repo}/languages"
        ],
        listPagesBuilds: [
          "GET /repos/{owner}/{repo}/pages/builds"
        ],
        listPublic: [
          "GET /repositories"
        ],
        listPullRequestsAssociatedWithCommit: [
          "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
        ],
        listReleaseAssets: [
          "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
        ],
        listReleases: [
          "GET /repos/{owner}/{repo}/releases"
        ],
        listTags: [
          "GET /repos/{owner}/{repo}/tags"
        ],
        listTeams: [
          "GET /repos/{owner}/{repo}/teams"
        ],
        listWebhookDeliveries: [
          "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: [
          "GET /repos/{owner}/{repo}/hooks"
        ],
        merge: [
          "POST /repos/{owner}/{repo}/merges"
        ],
        mergeUpstream: [
          "POST /repos/{owner}/{repo}/merge-upstream"
        ],
        pingWebhook: [
          "POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"
        ],
        redeliverWebhookDelivery: [
          "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeAppAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          {
            mapToData: "apps"
          }
        ],
        removeCollaborator: [
          "DELETE /repos/{owner}/{repo}/collaborators/{username}"
        ],
        removeStatusCheckContexts: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          {
            mapToData: "contexts"
          }
        ],
        removeStatusCheckProtection: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        removeTeamAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          {
            mapToData: "teams"
          }
        ],
        removeUserAccessRestrictions: [
          "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          {
            mapToData: "users"
          }
        ],
        renameBranch: [
          "POST /repos/{owner}/{repo}/branches/{branch}/rename"
        ],
        replaceAllTopics: [
          "PUT /repos/{owner}/{repo}/topics"
        ],
        requestPagesBuild: [
          "POST /repos/{owner}/{repo}/pages/builds"
        ],
        setAdminBranchProtection: [
          "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        setAppAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
          {},
          {
            mapToData: "apps"
          }
        ],
        setStatusCheckContexts: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
          {},
          {
            mapToData: "contexts"
          }
        ],
        setTeamAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
          {},
          {
            mapToData: "teams"
          }
        ],
        setUserAccessRestrictions: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
          {},
          {
            mapToData: "users"
          }
        ],
        testPushWebhook: [
          "POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"
        ],
        transfer: [
          "POST /repos/{owner}/{repo}/transfer"
        ],
        update: [
          "PATCH /repos/{owner}/{repo}"
        ],
        updateBranchProtection: [
          "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        updateCommitComment: [
          "PATCH /repos/{owner}/{repo}/comments/{comment_id}"
        ],
        updateDeploymentBranchPolicy: [
          "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        updateInformationAboutPagesSite: [
          "PUT /repos/{owner}/{repo}/pages"
        ],
        updateInvitation: [
          "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        updateOrgRuleset: [
          "PUT /orgs/{org}/rulesets/{ruleset_id}"
        ],
        updatePullRequestReviewProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        updateRelease: [
          "PATCH /repos/{owner}/{repo}/releases/{release_id}"
        ],
        updateReleaseAsset: [
          "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        updateRepoRuleset: [
          "PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"
        ],
        updateStatusCheckPotection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          {},
          {
            renamed: [
              "repos",
              "updateStatusCheckProtection"
            ]
          }
        ],
        updateStatusCheckProtection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        updateWebhook: [
          "PATCH /repos/{owner}/{repo}/hooks/{hook_id}"
        ],
        updateWebhookConfigForRepo: [
          "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        uploadReleaseAsset: [
          "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
          {
            baseUrl: "https://uploads.github.com"
          }
        ]
      },
      search: {
        code: [
          "GET /search/code"
        ],
        commits: [
          "GET /search/commits"
        ],
        issuesAndPullRequests: [
          "GET /search/issues",
          {},
          {
            deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests"
          }
        ],
        labels: [
          "GET /search/labels"
        ],
        repos: [
          "GET /search/repositories"
        ],
        topics: [
          "GET /search/topics"
        ],
        users: [
          "GET /search/users"
        ]
      },
      secretScanning: {
        createPushProtectionBypass: [
          "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
        ],
        getAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ],
        getScanHistory: [
          "GET /repos/{owner}/{repo}/secret-scanning/scan-history"
        ],
        listAlertsForEnterprise: [
          "GET /enterprises/{enterprise}/secret-scanning/alerts"
        ],
        listAlertsForOrg: [
          "GET /orgs/{org}/secret-scanning/alerts"
        ],
        listAlertsForRepo: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts"
        ],
        listLocationsForAlert: [
          "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
        ],
        updateAlert: [
          "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ]
      },
      securityAdvisories: {
        createFork: [
          "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
        ],
        createPrivateVulnerabilityReport: [
          "POST /repos/{owner}/{repo}/security-advisories/reports"
        ],
        createRepositoryAdvisory: [
          "POST /repos/{owner}/{repo}/security-advisories"
        ],
        createRepositoryAdvisoryCveRequest: [
          "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
        ],
        getGlobalAdvisory: [
          "GET /advisories/{ghsa_id}"
        ],
        getRepositoryAdvisory: [
          "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ],
        listGlobalAdvisories: [
          "GET /advisories"
        ],
        listOrgRepositoryAdvisories: [
          "GET /orgs/{org}/security-advisories"
        ],
        listRepositoryAdvisories: [
          "GET /repos/{owner}/{repo}/security-advisories"
        ],
        updateRepositoryAdvisory: [
          "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ]
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        addOrUpdateProjectPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.teams.addOrUpdateProjectPermissionsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions"
          }
        ],
        addOrUpdateProjectPermissionsLegacy: [
          "PUT /teams/{team_id}/projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.teams.addOrUpdateProjectPermissionsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#add-or-update-team-project-permissions-legacy"
          }
        ],
        addOrUpdateRepoPermissionsInOrg: [
          "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        checkPermissionsForProjectInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.teams.checkPermissionsForProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project"
          }
        ],
        checkPermissionsForProjectLegacy: [
          "GET /teams/{team_id}/projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.teams.checkPermissionsForProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#check-team-permissions-for-a-project-legacy"
          }
        ],
        checkPermissionsForRepoInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        create: [
          "POST /orgs/{org}/teams"
        ],
        createDiscussionCommentInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        createDiscussionInOrg: [
          "POST /orgs/{org}/teams/{team_slug}/discussions"
        ],
        deleteDiscussionCommentInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        deleteDiscussionInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        deleteInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}"
        ],
        getByName: [
          "GET /orgs/{org}/teams/{team_slug}"
        ],
        getDiscussionCommentInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        getDiscussionInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        getMembershipForUserInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        list: [
          "GET /orgs/{org}/teams"
        ],
        listChildInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/teams"
        ],
        listDiscussionCommentsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        listDiscussionsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/discussions"
        ],
        listForAuthenticatedUser: [
          "GET /user/teams"
        ],
        listMembersInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/members"
        ],
        listPendingInvitationsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/invitations"
        ],
        listProjectsInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/projects",
          {},
          {
            deprecated: "octokit.rest.teams.listProjectsInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects"
          }
        ],
        listProjectsLegacy: [
          "GET /teams/{team_id}/projects",
          {},
          {
            deprecated: "octokit.rest.teams.listProjectsLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#list-team-projects-legacy"
          }
        ],
        listReposInOrg: [
          "GET /orgs/{org}/teams/{team_slug}/repos"
        ],
        removeMembershipForUserInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        removeProjectInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.teams.removeProjectInOrg() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team"
          }
        ],
        removeProjectLegacy: [
          "DELETE /teams/{team_id}/projects/{project_id}",
          {},
          {
            deprecated: "octokit.rest.teams.removeProjectLegacy() is deprecated, see https://docs.github.com/rest/teams/teams#remove-a-project-from-a-team-legacy"
          }
        ],
        removeRepoInOrg: [
          "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        updateDiscussionCommentInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        updateDiscussionInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        updateInOrg: [
          "PATCH /orgs/{org}/teams/{team_slug}"
        ]
      },
      users: {
        addEmailForAuthenticated: [
          "POST /user/emails",
          {},
          {
            renamed: [
              "users",
              "addEmailForAuthenticatedUser"
            ]
          }
        ],
        addEmailForAuthenticatedUser: [
          "POST /user/emails"
        ],
        addSocialAccountForAuthenticatedUser: [
          "POST /user/social_accounts"
        ],
        block: [
          "PUT /user/blocks/{username}"
        ],
        checkBlocked: [
          "GET /user/blocks/{username}"
        ],
        checkFollowingForUser: [
          "GET /users/{username}/following/{target_user}"
        ],
        checkPersonIsFollowedByAuthenticated: [
          "GET /user/following/{username}"
        ],
        createGpgKeyForAuthenticated: [
          "POST /user/gpg_keys",
          {},
          {
            renamed: [
              "users",
              "createGpgKeyForAuthenticatedUser"
            ]
          }
        ],
        createGpgKeyForAuthenticatedUser: [
          "POST /user/gpg_keys"
        ],
        createPublicSshKeyForAuthenticated: [
          "POST /user/keys",
          {},
          {
            renamed: [
              "users",
              "createPublicSshKeyForAuthenticatedUser"
            ]
          }
        ],
        createPublicSshKeyForAuthenticatedUser: [
          "POST /user/keys"
        ],
        createSshSigningKeyForAuthenticatedUser: [
          "POST /user/ssh_signing_keys"
        ],
        deleteEmailForAuthenticated: [
          "DELETE /user/emails",
          {},
          {
            renamed: [
              "users",
              "deleteEmailForAuthenticatedUser"
            ]
          }
        ],
        deleteEmailForAuthenticatedUser: [
          "DELETE /user/emails"
        ],
        deleteGpgKeyForAuthenticated: [
          "DELETE /user/gpg_keys/{gpg_key_id}",
          {},
          {
            renamed: [
              "users",
              "deleteGpgKeyForAuthenticatedUser"
            ]
          }
        ],
        deleteGpgKeyForAuthenticatedUser: [
          "DELETE /user/gpg_keys/{gpg_key_id}"
        ],
        deletePublicSshKeyForAuthenticated: [
          "DELETE /user/keys/{key_id}",
          {},
          {
            renamed: [
              "users",
              "deletePublicSshKeyForAuthenticatedUser"
            ]
          }
        ],
        deletePublicSshKeyForAuthenticatedUser: [
          "DELETE /user/keys/{key_id}"
        ],
        deleteSocialAccountForAuthenticatedUser: [
          "DELETE /user/social_accounts"
        ],
        deleteSshSigningKeyForAuthenticatedUser: [
          "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        follow: [
          "PUT /user/following/{username}"
        ],
        getAuthenticated: [
          "GET /user"
        ],
        getById: [
          "GET /user/{account_id}"
        ],
        getByUsername: [
          "GET /users/{username}"
        ],
        getContextForUser: [
          "GET /users/{username}/hovercard"
        ],
        getGpgKeyForAuthenticated: [
          "GET /user/gpg_keys/{gpg_key_id}",
          {},
          {
            renamed: [
              "users",
              "getGpgKeyForAuthenticatedUser"
            ]
          }
        ],
        getGpgKeyForAuthenticatedUser: [
          "GET /user/gpg_keys/{gpg_key_id}"
        ],
        getPublicSshKeyForAuthenticated: [
          "GET /user/keys/{key_id}",
          {},
          {
            renamed: [
              "users",
              "getPublicSshKeyForAuthenticatedUser"
            ]
          }
        ],
        getPublicSshKeyForAuthenticatedUser: [
          "GET /user/keys/{key_id}"
        ],
        getSshSigningKeyForAuthenticatedUser: [
          "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        list: [
          "GET /users"
        ],
        listAttestations: [
          "GET /users/{username}/attestations/{subject_digest}"
        ],
        listBlockedByAuthenticated: [
          "GET /user/blocks",
          {},
          {
            renamed: [
              "users",
              "listBlockedByAuthenticatedUser"
            ]
          }
        ],
        listBlockedByAuthenticatedUser: [
          "GET /user/blocks"
        ],
        listEmailsForAuthenticated: [
          "GET /user/emails",
          {},
          {
            renamed: [
              "users",
              "listEmailsForAuthenticatedUser"
            ]
          }
        ],
        listEmailsForAuthenticatedUser: [
          "GET /user/emails"
        ],
        listFollowedByAuthenticated: [
          "GET /user/following",
          {},
          {
            renamed: [
              "users",
              "listFollowedByAuthenticatedUser"
            ]
          }
        ],
        listFollowedByAuthenticatedUser: [
          "GET /user/following"
        ],
        listFollowersForAuthenticatedUser: [
          "GET /user/followers"
        ],
        listFollowersForUser: [
          "GET /users/{username}/followers"
        ],
        listFollowingForUser: [
          "GET /users/{username}/following"
        ],
        listGpgKeysForAuthenticated: [
          "GET /user/gpg_keys",
          {},
          {
            renamed: [
              "users",
              "listGpgKeysForAuthenticatedUser"
            ]
          }
        ],
        listGpgKeysForAuthenticatedUser: [
          "GET /user/gpg_keys"
        ],
        listGpgKeysForUser: [
          "GET /users/{username}/gpg_keys"
        ],
        listPublicEmailsForAuthenticated: [
          "GET /user/public_emails",
          {},
          {
            renamed: [
              "users",
              "listPublicEmailsForAuthenticatedUser"
            ]
          }
        ],
        listPublicEmailsForAuthenticatedUser: [
          "GET /user/public_emails"
        ],
        listPublicKeysForUser: [
          "GET /users/{username}/keys"
        ],
        listPublicSshKeysForAuthenticated: [
          "GET /user/keys",
          {},
          {
            renamed: [
              "users",
              "listPublicSshKeysForAuthenticatedUser"
            ]
          }
        ],
        listPublicSshKeysForAuthenticatedUser: [
          "GET /user/keys"
        ],
        listSocialAccountsForAuthenticatedUser: [
          "GET /user/social_accounts"
        ],
        listSocialAccountsForUser: [
          "GET /users/{username}/social_accounts"
        ],
        listSshSigningKeysForAuthenticatedUser: [
          "GET /user/ssh_signing_keys"
        ],
        listSshSigningKeysForUser: [
          "GET /users/{username}/ssh_signing_keys"
        ],
        setPrimaryEmailVisibilityForAuthenticated: [
          "PATCH /user/email/visibility",
          {},
          {
            renamed: [
              "users",
              "setPrimaryEmailVisibilityForAuthenticatedUser"
            ]
          }
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
          "PATCH /user/email/visibility"
        ],
        unblock: [
          "DELETE /user/blocks/{username}"
        ],
        unfollow: [
          "DELETE /user/following/{username}"
        ],
        updateAuthenticated: [
          "PATCH /user"
        ]
      }
    };
    endpoints_default = Endpoints;
  }
});

// node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js
function endpointsToMethods(octokit) {
  const newMethods = {};
  for (const scope of endpointMethodsMap.keys()) {
    newMethods[scope] = new Proxy({
      octokit,
      scope,
      cache: {}
    }, handler);
  }
  return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  function withDecorations(...args) {
    let options = requestWithDefaults.endpoint.merge(...args);
    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: void 0
      });
      return requestWithDefaults(options);
    }
    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }
    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }
    if (decorations.renamedParameters) {
      const options2 = requestWithDefaults.endpoint.merge(...args);
      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options2) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
          if (!(alias in options2)) {
            options2[alias] = options2[name];
          }
          delete options2[name];
        }
      }
      return requestWithDefaults(options2);
    }
    return requestWithDefaults(...args);
  }
  __name(withDecorations, "withDecorations");
  return Object.assign(withDecorations, requestWithDefaults);
}
var endpointMethodsMap, handler;
var init_endpoints_to_methods = __esm({
  "node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js"() {
    init_endpoints();
    endpointMethodsMap = /* @__PURE__ */ new Map();
    for (const [scope, endpoints] of Object.entries(endpoints_default)) {
      for (const [methodName, endpoint2] of Object.entries(endpoints)) {
        const [route, defaults, decorations] = endpoint2;
        const [method, url2] = route.split(/ /);
        const endpointDefaults = Object.assign({
          method,
          url: url2
        }, defaults);
        if (!endpointMethodsMap.has(scope)) {
          endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
        }
        endpointMethodsMap.get(scope).set(methodName, {
          scope,
          methodName,
          endpointDefaults,
          decorations
        });
      }
    }
    handler = {
      has({ scope }, methodName) {
        return endpointMethodsMap.get(scope).has(methodName);
      },
      getOwnPropertyDescriptor(target, methodName) {
        return {
          value: this.get(target, methodName),
          // ensures method is in the cache
          configurable: true,
          writable: true,
          enumerable: true
        };
      },
      defineProperty(target, methodName, descriptor2) {
        Object.defineProperty(target.cache, methodName, descriptor2);
        return true;
      },
      deleteProperty(target, methodName) {
        delete target.cache[methodName];
        return true;
      },
      ownKeys({ scope }) {
        return [
          ...endpointMethodsMap.get(scope).keys()
        ];
      },
      set(target, methodName, value) {
        return target.cache[methodName] = value;
      },
      get({ octokit, scope, cache }, methodName) {
        if (cache[methodName]) {
          return cache[methodName];
        }
        const method = endpointMethodsMap.get(scope).get(methodName);
        if (!method) {
          return void 0;
        }
        const { endpointDefaults, decorations } = method;
        if (decorations) {
          cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
        } else {
          cache[methodName] = octokit.request.defaults(endpointDefaults);
        }
        return cache[methodName];
      }
    };
    __name(endpointsToMethods, "endpointsToMethods");
    __name(decorate, "decorate");
  }
});

// node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js
function restEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    rest: api
  };
}
function legacyRestEndpointMethods(octokit) {
  const api = endpointsToMethods(octokit);
  return {
    ...api,
    rest: api
  };
}
var init_dist_src4 = __esm({
  "node_modules/.pnpm/@octokit+plugin-rest-endpoint-methods@13.5.0_@octokit+core@6.1.6/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js"() {
    init_version3();
    init_endpoints_to_methods();
    __name(restEndpointMethods, "restEndpointMethods");
    restEndpointMethods.VERSION = VERSION7;
    __name(legacyRestEndpointMethods, "legacyRestEndpointMethods");
    legacyRestEndpointMethods.VERSION = VERSION7;
  }
});

// node_modules/.pnpm/@octokit+rest@21.1.1/node_modules/@octokit/rest/dist-src/version.js
var VERSION8;
var init_version4 = __esm({
  "node_modules/.pnpm/@octokit+rest@21.1.1/node_modules/@octokit/rest/dist-src/version.js"() {
    VERSION8 = "21.1.1";
  }
});

// node_modules/.pnpm/@octokit+rest@21.1.1/node_modules/@octokit/rest/dist-src/index.js
var dist_src_exports = {};
__export(dist_src_exports, {
  Octokit: () => Octokit2
});
var Octokit2;
var init_dist_src5 = __esm({
  "node_modules/.pnpm/@octokit+rest@21.1.1/node_modules/@octokit/rest/dist-src/index.js"() {
    init_dist_src2();
    init_dist_src3();
    init_dist_bundle5();
    init_dist_src4();
    init_version4();
    Octokit2 = Octokit.plugin(requestLog, legacyRestEndpointMethods, paginateRest).defaults({
      userAgent: `octokit-rest.js/${VERSION8}`
    });
  }
});

// node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug2, "debug");
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend2;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v2) => {
            enableOverride = v2;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      __name(createDebug, "createDebug");
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend2, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      __name(enable, "enable");
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      __name(matchesTemplate, "matchesTemplate");
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error45) {
      }
    }
    __name(save, "save");
    function load() {
      let r2;
      try {
        r2 = exports2.storage.getItem("debug") || exports2.storage.getItem("DEBUG");
      } catch (error45) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error45) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error45) {
        return "[UnexpectedJSONParseError]: " + error45.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@8.1.1/node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var flagForceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    function envForceColor() {
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          return 1;
        }
        if (env.FORCE_COLOR === "false") {
          return 0;
        }
        return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    __name(envForceColor, "envForceColor");
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    __name(translateLevel, "translateLevel");
    function supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
      const noFlagForceColor = envForceColor();
      if (noFlagForceColor !== void 0) {
        flagForceColor = noFlagForceColor;
      }
      const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
      if (forceColor === 0) {
        return 0;
      }
      if (sniffFlags) {
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if ([
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI",
          "GITHUB_ACTIONS",
          "BUILDKITE",
          "DRONE"
        ].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    __name(supportsColor, "supportsColor");
    function getSupportLevel(stream, options = {}) {
      const level = supportsColor(stream, {
        streamIsTTY: stream && stream.isTTY,
        ...options
      });
      return translateLevel(level);
    }
    __name(getSupportLevel, "getSupportLevel");
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel({
        isTTY: tty.isatty(1)
      }),
      stderr: getSupportLevel({
        isTTY: tty.isatty(2)
      })
    };
  }
});

// node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [
      6,
      2,
      3,
      4,
      5,
      1
    ];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error45) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k2) => {
        return k2.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    __name(log, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug2.inspectOpts[keys[i2]] = exports2.inspectOpts[keys[i2]];
      }
    }
    __name(init, "init");
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v2) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v2, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/debug@4.4.3_supports-color@8.1.1/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/alea.js"(exports2, module2) {
    (function(global2, module1, define1) {
      function Alea(seed) {
        var me2 = this, mash = Mash();
        me2.next = function() {
          var t2 = 2091639 * me2.s0 + me2.c * 23283064365386963e-26;
          me2.s0 = me2.s1;
          me2.s1 = me2.s2;
          return me2.s2 = t2 - (me2.c = t2 | 0);
        };
        me2.c = 1;
        me2.s0 = mash(" ");
        me2.s1 = mash(" ");
        me2.s2 = mash(" ");
        me2.s0 -= mash(seed);
        if (me2.s0 < 0) {
          me2.s0 += 1;
        }
        me2.s1 -= mash(seed);
        if (me2.s1 < 0) {
          me2.s1 += 1;
        }
        me2.s2 -= mash(seed);
        if (me2.s2 < 0) {
          me2.s2 += 1;
        }
        mash = null;
      }
      __name(Alea, "Alea");
      function copy(f2, t2) {
        t2.c = f2.c;
        t2.s0 = f2.s0;
        t2.s1 = f2.s1;
        t2.s2 = f2.s2;
        return t2;
      }
      __name(copy, "copy");
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      __name(impl, "impl");
      function Mash() {
        var n2 = 4022871197;
        var mash = /* @__PURE__ */ __name(function(data) {
          data = String(data);
          for (var i2 = 0; i2 < data.length; i2++) {
            n2 += data.charCodeAt(i2);
            var h2 = 0.02519603282416938 * n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            h2 *= n2;
            n2 = h2 >>> 0;
            h2 -= n2;
            n2 += h2 * 4294967296;
          }
          return (n2 >>> 0) * 23283064365386963e-26;
        }, "mash");
        return mash;
      }
      __name(Mash, "Mash");
      if (module1 && module1.exports) {
        module1.exports = impl;
      } else if (define1 && define1.amd) {
        define1(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor128.js"(exports2, module2) {
    (function(global2, module1, define1) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.x = 0;
        me2.y = 0;
        me2.z = 0;
        me2.w = 0;
        me2.next = function() {
          var t2 = me2.x ^ me2.x << 11;
          me2.x = me2.y;
          me2.y = me2.z;
          me2.z = me2.w;
          return me2.w ^= me2.w >>> 19 ^ t2 ^ t2 >>> 8;
        };
        if (seed === (seed | 0)) {
          me2.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me2.x ^= strseed.charCodeAt(k2) | 0;
          me2.next();
        }
      }
      __name(XorGen, "XorGen");
      function copy(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        return t2;
      }
      __name(copy, "copy");
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = /* @__PURE__ */ __name(function() {
          return (xg.next() >>> 0) / 4294967296;
        }, "prng");
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      __name(impl, "impl");
      if (module1 && module1.exports) {
        module1.exports = impl;
      } else if (define1 && define1.amd) {
        define1(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorwow.js"(exports2, module2) {
    (function(global2, module1, define1) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.next = function() {
          var t2 = me2.x ^ me2.x >>> 2;
          me2.x = me2.y;
          me2.y = me2.z;
          me2.z = me2.w;
          me2.w = me2.v;
          return (me2.d = me2.d + 362437 | 0) + (me2.v = me2.v ^ me2.v << 4 ^ (t2 ^ t2 << 1)) | 0;
        };
        me2.x = 0;
        me2.y = 0;
        me2.z = 0;
        me2.w = 0;
        me2.v = 0;
        if (seed === (seed | 0)) {
          me2.x = seed;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 64; k2++) {
          me2.x ^= strseed.charCodeAt(k2) | 0;
          if (k2 == strseed.length) {
            me2.d = me2.x << 10 ^ me2.x >>> 4;
          }
          me2.next();
        }
      }
      __name(XorGen, "XorGen");
      function copy(f2, t2) {
        t2.x = f2.x;
        t2.y = f2.y;
        t2.z = f2.z;
        t2.w = f2.w;
        t2.v = f2.v;
        t2.d = f2.d;
        return t2;
      }
      __name(copy, "copy");
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = /* @__PURE__ */ __name(function() {
          return (xg.next() >>> 0) / 4294967296;
        }, "prng");
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      __name(impl, "impl");
      if (module1 && module1.exports) {
        module1.exports = impl;
      } else if (define1 && define1.amd) {
        define1(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xorshift7.js"(exports2, module2) {
    (function(global2, module1, define1) {
      function XorGen(seed) {
        var me2 = this;
        me2.next = function() {
          var X2 = me2.x, i2 = me2.i, t2, v2, w2;
          t2 = X2[i2];
          t2 ^= t2 >>> 7;
          v2 = t2 ^ t2 << 24;
          t2 = X2[i2 + 1 & 7];
          v2 ^= t2 ^ t2 >>> 10;
          t2 = X2[i2 + 3 & 7];
          v2 ^= t2 ^ t2 >>> 3;
          t2 = X2[i2 + 4 & 7];
          v2 ^= t2 ^ t2 << 7;
          t2 = X2[i2 + 7 & 7];
          t2 = t2 ^ t2 << 13;
          v2 ^= t2 ^ t2 << 9;
          X2[i2] = v2;
          me2.i = i2 + 1 & 7;
          return v2;
        };
        function init(me3, seed2) {
          var j2, w2, X2 = [];
          if (seed2 === (seed2 | 0)) {
            w2 = X2[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j2 = 0; j2 < seed2.length; ++j2) {
              X2[j2 & 7] = X2[j2 & 7] << 15 ^ seed2.charCodeAt(j2) + X2[j2 + 1 & 7] << 13;
            }
          }
          while (X2.length < 8) X2.push(0);
          for (j2 = 0; j2 < 8 && X2[j2] === 0; ++j2) ;
          if (j2 == 8) w2 = X2[7] = -1;
          else w2 = X2[j2];
          me3.x = X2;
          me3.i = 0;
          for (j2 = 256; j2 > 0; --j2) {
            me3.next();
          }
        }
        __name(init, "init");
        init(me2, seed);
      }
      __name(XorGen, "XorGen");
      function copy(f2, t2) {
        t2.x = f2.x.slice();
        t2.i = f2.i;
        return t2;
      }
      __name(copy, "copy");
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = /* @__PURE__ */ __name(function() {
          return (xg.next() >>> 0) / 4294967296;
        }, "prng");
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      __name(impl, "impl");
      if (module1 && module1.exports) {
        module1.exports = impl;
      } else if (define1 && define1.amd) {
        define1(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/xor4096.js"(exports2, module2) {
    (function(global2, module1, define1) {
      function XorGen(seed) {
        var me2 = this;
        me2.next = function() {
          var w2 = me2.w, X2 = me2.X, i2 = me2.i, t2, v2;
          me2.w = w2 = w2 + 1640531527 | 0;
          v2 = X2[i2 + 34 & 127];
          t2 = X2[i2 = i2 + 1 & 127];
          v2 ^= v2 << 13;
          t2 ^= t2 << 17;
          v2 ^= v2 >>> 15;
          t2 ^= t2 >>> 12;
          v2 = X2[i2] = v2 ^ t2;
          me2.i = i2;
          return v2 + (w2 ^ w2 >>> 16) | 0;
        };
        function init(me3, seed2) {
          var t2, v2, i2, j2, w2, X2 = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v2 = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v2 = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i2 = 0, j2 = -32; j2 < limit; ++j2) {
            if (seed2) v2 ^= seed2.charCodeAt((j2 + 32) % seed2.length);
            if (j2 === 0) w2 = v2;
            v2 ^= v2 << 10;
            v2 ^= v2 >>> 15;
            v2 ^= v2 << 4;
            v2 ^= v2 >>> 13;
            if (j2 >= 0) {
              w2 = w2 + 1640531527 | 0;
              t2 = X2[j2 & 127] ^= v2 + w2;
              i2 = 0 == t2 ? i2 + 1 : 0;
            }
          }
          if (i2 >= 128) {
            X2[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i2 = 127;
          for (j2 = 4 * 128; j2 > 0; --j2) {
            v2 = X2[i2 + 34 & 127];
            t2 = X2[i2 = i2 + 1 & 127];
            v2 ^= v2 << 13;
            t2 ^= t2 << 17;
            v2 ^= v2 >>> 15;
            t2 ^= t2 >>> 12;
            X2[i2] = v2 ^ t2;
          }
          me3.w = w2;
          me3.X = X2;
          me3.i = i2;
        }
        __name(init, "init");
        init(me2, seed);
      }
      __name(XorGen, "XorGen");
      function copy(f2, t2) {
        t2.i = f2.i;
        t2.w = f2.w;
        t2.X = f2.X.slice();
        return t2;
      }
      __name(copy, "copy");
      ;
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = /* @__PURE__ */ __name(function() {
          return (xg.next() >>> 0) / 4294967296;
        }, "prng");
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      __name(impl, "impl");
      if (module1 && module1.exports) {
        module1.exports = impl;
      } else if (define1 && define1.amd) {
        define1(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/lib/tychei.js"(exports2, module2) {
    (function(global2, module1, define1) {
      function XorGen(seed) {
        var me2 = this, strseed = "";
        me2.next = function() {
          var b2 = me2.b, c2 = me2.c, d2 = me2.d, a2 = me2.a;
          b2 = b2 << 25 ^ b2 >>> 7 ^ c2;
          c2 = c2 - d2 | 0;
          d2 = d2 << 24 ^ d2 >>> 8 ^ a2;
          a2 = a2 - b2 | 0;
          me2.b = b2 = b2 << 20 ^ b2 >>> 12 ^ c2;
          me2.c = c2 = c2 - d2 | 0;
          me2.d = d2 << 16 ^ c2 >>> 16 ^ a2;
          return me2.a = a2 - b2 | 0;
        };
        me2.a = 0;
        me2.b = 0;
        me2.c = 2654435769 | 0;
        me2.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me2.a = seed / 4294967296 | 0;
          me2.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k2 = 0; k2 < strseed.length + 20; k2++) {
          me2.b ^= strseed.charCodeAt(k2) | 0;
          me2.next();
        }
      }
      __name(XorGen, "XorGen");
      function copy(f2, t2) {
        t2.a = f2.a;
        t2.b = f2.b;
        t2.c = f2.c;
        t2.d = f2.d;
        return t2;
      }
      __name(copy, "copy");
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = /* @__PURE__ */ __name(function() {
          return (xg.next() >>> 0) / 4294967296;
        }, "prng");
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      __name(impl, "impl");
      if (module1 && module1.exports) {
        module1.exports = impl;
      } else if (define1 && define1.amd) {
        define1(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/seedrandom.js"(exports2, module2) {
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? {
          entropy: true
        } : options || {};
        var shortseed = mixkey(flatten(options.entropy ? [
          seed,
          tostring(pool)
        ] : seed == null ? autoseed() : seed, 3), key);
        var arc4 = new ARC4(key);
        var prng = /* @__PURE__ */ __name(function() {
          var n2 = arc4.g(chunks), d2 = startdenom, x2 = 0;
          while (n2 < significance) {
            n2 = (n2 + x2) * width;
            d2 *= width;
            x2 = arc4.g(1);
          }
          while (n2 >= overflow) {
            n2 /= 2;
            d2 /= 2;
            x2 >>>= 1;
          }
          return (n2 + x2) / d2;
        }, "prng");
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else return prng2;
        })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
      }
      __name(seedrandom2, "seedrandom");
      function ARC4(key) {
        var t2, keylen = key.length, me2 = this, i2 = 0, j2 = me2.i = me2.j = 0, s2 = me2.S = [];
        if (!keylen) {
          key = [
            keylen++
          ];
        }
        while (i2 < width) {
          s2[i2] = i2++;
        }
        for (i2 = 0; i2 < width; i2++) {
          s2[i2] = s2[j2 = mask & j2 + key[i2 % keylen] + (t2 = s2[i2])];
          s2[j2] = t2;
        }
        (me2.g = function(count) {
          var t3, r2 = 0, i3 = me2.i, j3 = me2.j, s3 = me2.S;
          while (count--) {
            t3 = s3[i3 = mask & i3 + 1];
            r2 = r2 * width + s3[mask & (s3[i3] = s3[j3 = mask & j3 + t3]) + (s3[j3] = t3)];
          }
          me2.i = i3;
          me2.j = j3;
          return r2;
        })(width);
      }
      __name(ARC4, "ARC4");
      function copy(f2, t2) {
        t2.i = f2.i;
        t2.j = f2.j;
        t2.S = f2.S.slice();
        return t2;
      }
      __name(copy, "copy");
      ;
      function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e2) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      __name(flatten, "flatten");
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j2 = 0;
        while (j2 < stringseed.length) {
          key[mask & j2] = mask & (smear ^= key[mask & j2] * 19) + stringseed.charCodeAt(j2++);
        }
        return tostring(key);
      }
      __name(mixkey, "mixkey");
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e2) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [
            +/* @__PURE__ */ new Date(),
            global2,
            plugins,
            global2.screen,
            tostring(pool)
          ];
        }
      }
      __name(autoseed, "autoseed");
      function tostring(a2) {
        return String.fromCharCode.apply(0, a2);
      }
      __name(tostring, "tostring");
      mixkey(math.random(), pool);
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = seedrandom2;
        try {
          nodecrypto = require("crypto");
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports2,
      [],
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/.pnpm/seedrandom@3.0.5/node_modules/seedrandom/index.js"(exports2, module2) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module2.exports = sr;
  }
});

// virtual-entry.js
var virtual_entry_exports = {};
__export(virtual_entry_exports, {
  POST: () => stepEntrypoint
});
module.exports = __toCommonJS(virtual_entry_exports);

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/private.js
var registeredSteps = /* @__PURE__ */ new Map();
function registerStepFunction(stepId, stepFn) {
  registeredSteps.set(stepId, stepFn);
}
__name(registerStepFunction, "registerStepFunction");
function getStepFunction(stepId) {
  return registeredSteps.get(stepId);
}
__name(getStepFunction, "getStepFunction");

// node_modules/.pnpm/workflow@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0_next@15.0.3_react-dom@19.0.0_react@19_953f1560e5b5900bbc2c66daccad0466/node_modules/workflow/dist/internal/builtins.js
async function __builtin_response_array_buffer(res) {
  return res.arrayBuffer();
}
__name(__builtin_response_array_buffer, "__builtin_response_array_buffer");
async function __builtin_response_json(res) {
  return res.json();
}
__name(__builtin_response_json, "__builtin_response_json");
async function __builtin_response_text(res) {
  return res.text();
}
__name(__builtin_response_text, "__builtin_response_text");
registerStepFunction("__builtin_response_array_buffer", __builtin_response_array_buffer);
registerStepFunction("__builtin_response_json", __builtin_response_json);
registerStepFunction("__builtin_response_text", __builtin_response_text);

// node_modules/.pnpm/@workflow+errors@4.0.1-beta.1/node_modules/@workflow/errors/dist/index.js
var import_ms = __toESM(require_ms(), 1);
var BASE_URL = "https://useworkflow.dev/err";
var WorkflowError = class extends Error {
  static {
    __name(this, "WorkflowError");
  }
  cause;
  constructor(message, options) {
    const msgDocs = options?.slug ? `${message}

Learn more: ${BASE_URL}/${options.slug}` : message;
    super(msgDocs, {
      cause: options?.cause
    });
    this.cause = options?.cause;
    if (options?.cause instanceof Error) {
      this.stack = `${this.stack}
Caused by: ${options.cause.stack}`;
    }
  }
};
var WorkflowAPIError = class extends WorkflowError {
  static {
    __name(this, "WorkflowAPIError");
  }
  status;
  code;
  url;
  constructor(message, options) {
    super(message, {
      cause: options?.cause
    });
    this.name = "WorkflowAPIError";
    this.status = options?.status;
    this.code = options?.code;
    this.url = options?.url;
  }
};
var WorkflowRuntimeError = class extends WorkflowError {
  static {
    __name(this, "WorkflowRuntimeError");
  }
  constructor(message, options) {
    super(message, {
      ...options
    });
    this.name = "WorkflowRuntimeError";
  }
};
var WorkflowRunNotFoundError = class extends WorkflowError {
  static {
    __name(this, "WorkflowRunNotFoundError");
  }
  runId;
  constructor(runId) {
    super(`Workflow run "${runId}" not found`, {});
    this.name = "WorkflowRunNotFoundError";
    this.runId = runId;
  }
};
var FatalError = class extends Error {
  static {
    __name(this, "FatalError");
  }
  fatal = true;
  constructor(message) {
    super(message);
    this.name = "FatalError";
  }
};
var RetryableError = class extends Error {
  static {
    __name(this, "RetryableError");
  }
  /**
   * The Date when the step should be retried.
   */
  retryAfter;
  constructor(message, options = {}) {
    super(message);
    this.name = "RetryableError";
    let retryAfterSeconds;
    if (typeof options.retryAfter === "string") {
      retryAfterSeconds = (0, import_ms.default)(options.retryAfter) / 1e3;
    } else if (typeof options.retryAfter === "number") {
      retryAfterSeconds = options.retryAfter;
    } else if (options.retryAfter instanceof Date) {
      retryAfterSeconds = (options.retryAfter.getTime() - Date.now()) / 1e3;
    } else {
      retryAfterSeconds = 1;
    }
    this.retryAfter = new Date(Date.now() + retryAfterSeconds * 1e3);
  }
};

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/runtime/resume-hook.js
var import_functions = __toESM(require_functions(), 1);

// node_modules/.pnpm/devalue@5.4.2/node_modules/devalue/src/utils.js
var DevalueError = class extends Error {
  static {
    __name(this, "DevalueError");
  }
  /**
  * @param {string} message
  * @param {string[]} keys
  */
  constructor(message, keys) {
    super(message);
    this.name = "DevalueError";
    this.path = keys.join("");
  }
};
function is_primitive(thing) {
  return Object(thing) !== thing;
}
__name(is_primitive, "is_primitive");
var object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getPrototypeOf(proto) === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
__name(is_plain_object, "is_plain_object");
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
__name(get_type, "get_type");
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
__name(get_escaped_char, "get_escaped_char");
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i2 = 0; i2 < len; i2 += 1) {
    const char = str[i2];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i2) + replacement;
      last_pos = i2 + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
__name(stringify_string, "stringify_string");
function enumerable_symbols(object2) {
  return Object.getOwnPropertySymbols(object2).filter((symbol2) => Object.getOwnPropertyDescriptor(object2, symbol2).enumerable);
}
__name(enumerable_symbols, "enumerable_symbols");
var is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
function stringify_key(key) {
  return is_identifier.test(key) ? "." + key : "[" + JSON.stringify(key) + "]";
}
__name(stringify_key, "stringify_key");

// node_modules/.pnpm/devalue@5.4.2/node_modules/devalue/src/base64.js
function encode64(arraybuffer) {
  const dv = new DataView(arraybuffer);
  let binaryString = "";
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    binaryString += String.fromCharCode(dv.getUint8(i2));
  }
  return binaryToAscii(binaryString);
}
__name(encode64, "encode64");
function decode64(string4) {
  const binaryString = asciiToBinary(string4);
  const arraybuffer = new ArrayBuffer(binaryString.length);
  const dv = new DataView(arraybuffer);
  for (let i2 = 0; i2 < arraybuffer.byteLength; i2++) {
    dv.setUint8(i2, binaryString.charCodeAt(i2));
  }
  return arraybuffer;
}
__name(decode64, "decode64");
var KEY_STRING = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
function asciiToBinary(data) {
  if (data.length % 4 === 0) {
    data = data.replace(/==?$/, "");
  }
  let output = "";
  let buffer = 0;
  let accumulatedBits = 0;
  for (let i2 = 0; i2 < data.length; i2++) {
    buffer <<= 6;
    buffer |= KEY_STRING.indexOf(data[i2]);
    accumulatedBits += 6;
    if (accumulatedBits === 24) {
      output += String.fromCharCode((buffer & 16711680) >> 16);
      output += String.fromCharCode((buffer & 65280) >> 8);
      output += String.fromCharCode(buffer & 255);
      buffer = accumulatedBits = 0;
    }
  }
  if (accumulatedBits === 12) {
    buffer >>= 4;
    output += String.fromCharCode(buffer);
  } else if (accumulatedBits === 18) {
    buffer >>= 2;
    output += String.fromCharCode((buffer & 65280) >> 8);
    output += String.fromCharCode(buffer & 255);
  }
  return output;
}
__name(asciiToBinary, "asciiToBinary");
function binaryToAscii(str) {
  let out = "";
  for (let i2 = 0; i2 < str.length; i2 += 3) {
    const groupsOfSix = [
      void 0,
      void 0,
      void 0,
      void 0
    ];
    groupsOfSix[0] = str.charCodeAt(i2) >> 2;
    groupsOfSix[1] = (str.charCodeAt(i2) & 3) << 4;
    if (str.length > i2 + 1) {
      groupsOfSix[1] |= str.charCodeAt(i2 + 1) >> 4;
      groupsOfSix[2] = (str.charCodeAt(i2 + 1) & 15) << 2;
    }
    if (str.length > i2 + 2) {
      groupsOfSix[2] |= str.charCodeAt(i2 + 2) >> 6;
      groupsOfSix[3] = str.charCodeAt(i2 + 2) & 63;
    }
    for (let j2 = 0; j2 < groupsOfSix.length; j2++) {
      if (typeof groupsOfSix[j2] === "undefined") {
        out += "=";
      } else {
        out += KEY_STRING[groupsOfSix[j2]];
      }
    }
  }
  return out;
}
__name(binaryToAscii, "binaryToAscii");

// node_modules/.pnpm/devalue@5.4.2/node_modules/devalue/src/constants.js
var UNDEFINED = -1;
var HOLE = -2;
var NAN = -3;
var POSITIVE_INFINITY = -4;
var NEGATIVE_INFINITY = -5;
var NEGATIVE_ZERO = -6;

// node_modules/.pnpm/devalue@5.4.2/node_modules/devalue/src/parse.js
function parse(serialized, revivers) {
  return unflatten(JSON.parse(serialized), revivers);
}
__name(parse, "parse");
function unflatten(parsed, revivers) {
  if (typeof parsed === "number") return hydrate(parsed, true);
  if (!Array.isArray(parsed) || parsed.length === 0) {
    throw new Error("Invalid input");
  }
  const values = (
    /** @type {any[]} */
    parsed
  );
  const hydrated = Array(values.length);
  function hydrate(index, standalone = false) {
    if (index === UNDEFINED) return void 0;
    if (index === NAN) return NaN;
    if (index === POSITIVE_INFINITY) return Infinity;
    if (index === NEGATIVE_INFINITY) return -Infinity;
    if (index === NEGATIVE_ZERO) return -0;
    if (standalone || typeof index !== "number") {
      throw new Error(`Invalid input`);
    }
    if (index in hydrated) return hydrated[index];
    const value = values[index];
    if (!value || typeof value !== "object") {
      hydrated[index] = value;
    } else if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const type = value[0];
        const reviver = revivers?.[type];
        if (reviver) {
          let i2 = value[1];
          if (typeof i2 !== "number") {
            i2 = values.push(value[1]) - 1;
          }
          return hydrated[index] = reviver(hydrate(i2));
        }
        switch (type) {
          case "Date":
            hydrated[index] = new Date(value[1]);
            break;
          case "Set":
            const set2 = /* @__PURE__ */ new Set();
            hydrated[index] = set2;
            for (let i2 = 1; i2 < value.length; i2 += 1) {
              set2.add(hydrate(value[i2]));
            }
            break;
          case "Map":
            const map2 = /* @__PURE__ */ new Map();
            hydrated[index] = map2;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              map2.set(hydrate(value[i2]), hydrate(value[i2 + 1]));
            }
            break;
          case "RegExp":
            hydrated[index] = new RegExp(value[1], value[2]);
            break;
          case "Object":
            hydrated[index] = Object(value[1]);
            break;
          case "BigInt":
            hydrated[index] = BigInt(value[1]);
            break;
          case "null":
            const obj = /* @__PURE__ */ Object.create(null);
            hydrated[index] = obj;
            for (let i2 = 1; i2 < value.length; i2 += 2) {
              obj[value[i2]] = hydrate(value[i2 + 1]);
            }
            break;
          case "Int8Array":
          case "Uint8Array":
          case "Uint8ClampedArray":
          case "Int16Array":
          case "Uint16Array":
          case "Int32Array":
          case "Uint32Array":
          case "Float32Array":
          case "Float64Array":
          case "BigInt64Array":
          case "BigUint64Array": {
            const TypedArrayConstructor = globalThis[type];
            const typedArray = new TypedArrayConstructor(hydrate(value[1]));
            hydrated[index] = value[2] !== void 0 ? typedArray.subarray(value[2], value[3]) : typedArray;
            break;
          }
          case "ArrayBuffer": {
            const base643 = value[1];
            const arraybuffer = decode64(base643);
            hydrated[index] = arraybuffer;
            break;
          }
          case "Temporal.Duration":
          case "Temporal.Instant":
          case "Temporal.PlainDate":
          case "Temporal.PlainTime":
          case "Temporal.PlainDateTime":
          case "Temporal.PlainMonthDay":
          case "Temporal.PlainYearMonth":
          case "Temporal.ZonedDateTime": {
            const temporalName = type.slice(9);
            hydrated[index] = Temporal[temporalName].from(value[1]);
            break;
          }
          case "URL": {
            const url2 = new URL(value[1]);
            hydrated[index] = url2;
            break;
          }
          case "URLSearchParams": {
            const url2 = new URLSearchParams(value[1]);
            hydrated[index] = url2;
            break;
          }
          default:
            throw new Error(`Unknown type ${type}`);
        }
      } else {
        const array2 = new Array(value.length);
        hydrated[index] = array2;
        for (let i2 = 0; i2 < value.length; i2 += 1) {
          const n2 = value[i2];
          if (n2 === HOLE) continue;
          array2[i2] = hydrate(n2);
        }
      }
    } else {
      const object2 = {};
      hydrated[index] = object2;
      for (const key in value) {
        if (key === "__proto__") {
          throw new Error("Cannot parse an object with a `__proto__` property");
        }
        const n2 = value[key];
        object2[key] = hydrate(n2);
      }
    }
    return hydrated[index];
  }
  __name(hydrate, "hydrate");
  return hydrate(0);
}
__name(unflatten, "unflatten");

// node_modules/.pnpm/devalue@5.4.2/node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  if (reducers) {
    for (const key of Object.getOwnPropertyNames(reducers)) {
      custom2.push({
        key,
        fn: reducers[key]
      });
    }
  }
  const keys = [];
  let p2 = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (thing === void 0) return UNDEFINED;
    if (Number.isNaN(thing)) return NAN;
    if (thing === Infinity) return POSITIVE_INFINITY;
    if (thing === -Infinity) return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO;
    if (indexes.has(thing)) return indexes.get(thing);
    const index2 = p2++;
    indexes.set(thing, index2);
    for (const { key, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index2] = `["${key}",${flatten(value2)}]`;
        return index2;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "URL":
          str = `["URL",${stringify_string(thing.toString())}]`;
          break;
        case "URLSearchParams":
          str = `["URLSearchParams",${stringify_string(thing.toString())}]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i2 = 0; i2 < thing.length; i2 += 1) {
            if (i2 > 0) str += ",";
            if (i2 in thing) {
              keys.push(`[${i2}]`);
              str += flatten(thing[i2]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key, value2] of thing) {
            keys.push(`.get(${is_primitive(key) ? stringify_primitive(key) : "..."})`);
            str += `,${flatten(key)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "BigInt64Array":
        case "BigUint64Array": {
          const typedArray = thing;
          str = '["' + type + '",' + flatten(typedArray.buffer);
          const a2 = thing.byteOffset;
          const b2 = a2 + thing.byteLength;
          if (a2 > 0 || b2 !== typedArray.buffer.byteLength) {
            const m2 = +/(\d+)/.exec(type)[1] / 8;
            str += `,${a2 / m2},${b2 / m2}`;
          }
          str += "]";
          break;
        }
        case "ArrayBuffer": {
          const arraybuffer = thing;
          const base643 = encode64(arraybuffer);
          str = `["ArrayBuffer","${base643}"]`;
          break;
        }
        case "Temporal.Duration":
        case "Temporal.Instant":
        case "Temporal.PlainDate":
        case "Temporal.PlainTime":
        case "Temporal.PlainDateTime":
        case "Temporal.PlainMonthDay":
        case "Temporal.PlainYearMonth":
        case "Temporal.ZonedDateTime":
          str = `["${type}",${stringify_string(thing.toString())}]`;
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(`Cannot stringify arbitrary non-POJOs`, keys);
          }
          if (enumerable_symbols(thing).length > 0) {
            throw new DevalueError(`Cannot stringify POJOs with symbolic keys`, keys);
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key in thing) {
              keys.push(stringify_key(key));
              str += `,${stringify_string(key)},${flatten(thing[key])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key in thing) {
              if (started) str += ",";
              started = true;
              keys.push(stringify_key(key));
              str += `${stringify_string(key)}:${flatten(thing[key])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index2] = str;
    return index2;
  }
  __name(flatten, "flatten");
  const index = flatten(value);
  if (index < 0) return `${index}`;
  return `[${stringified.join(",")}]`;
}
__name(stringify, "stringify");
function stringify_primitive(thing) {
  const type = typeof thing;
  if (type === "string") return stringify_string(thing);
  if (thing instanceof String) return stringify_string(thing.toString());
  if (thing === void 0) return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0) return NEGATIVE_ZERO.toString();
  if (type === "bigint") return `["BigInt","${thing}"]`;
  return String(thing);
}
__name(stringify_primitive, "stringify_primitive");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/runtime/world.js
var import_node_module = require("node:module");
var import_node_path4 = __toESM(require("node:path"), 1);

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/util.js
function once(fn) {
  const result = {
    get value() {
      const value = fn();
      Object.defineProperty(result, "value", {
        value
      });
      return value;
    }
  };
  return result;
}
__name(once, "once");

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/config.js
var getDataDirFromEnv = /* @__PURE__ */ __name(() => {
  return process.env.WORKFLOW_EMBEDDED_DATA_DIR || ".workflow-data";
}, "getDataDirFromEnv");
var DEFAULT_RESOLVE_DATA_OPTION = "all";
var getPortFromEnv = /* @__PURE__ */ __name(() => {
  const port = process.env.PORT;
  if (port) {
    return Number(port);
  }
  return 3e3;
}, "getPortFromEnv");
var config = once(() => {
  const dataDir = getDataDirFromEnv();
  const port = getPortFromEnv();
  return {
    dataDir,
    port
  };
});

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/queue.js
var import_promises = require("node:timers/promises");

// node_modules/.pnpm/mixpart@0.0.5-alpha.0/node_modules/mixpart/dist/index.mjs
var MultipartParseError = class extends Error {
  static {
    __name(this, "MultipartParseError");
  }
  constructor(message) {
    super(message);
    this.name = "MultipartParseError";
  }
};
function createSearch(pattern) {
  const needle = new TextEncoder().encode(pattern);
  return (haystack, start2 = 0) => Buffer.prototype.indexOf.call(haystack, needle, start2);
}
__name(createSearch, "createSearch");
function createPartialTailSearch(pattern) {
  const needle = new TextEncoder().encode(pattern);
  const byteIndexes = {};
  for (let i2 = 0; i2 < needle.length; ++i2) {
    const byte = needle[i2];
    if (byteIndexes[byte] === void 0) byteIndexes[byte] = [];
    byteIndexes[byte].push(i2);
  }
  return function(haystack) {
    const haystackEnd = haystack.length - 1;
    if (haystack[haystackEnd] in byteIndexes) {
      const indexes = byteIndexes[haystack[haystackEnd]];
      for (let i2 = indexes.length - 1; i2 >= 0; --i2) {
        for (let j2 = indexes[i2], k2 = haystackEnd; j2 >= 0 && haystack[k2] === needle[j2]; --j2, --k2) {
          if (j2 === 0) return k2;
        }
      }
    }
    return -1;
  };
}
__name(createPartialTailSearch, "createPartialTailSearch");
function parseHeaders(headerBytes) {
  const headerText = new TextDecoder("iso-8859-1").decode(headerBytes);
  const lines = headerText.trim().split(/\r?\n/);
  const headerInit = [];
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex > 0) {
      const name = line.slice(0, colonIndex).trim();
      const value = line.slice(colonIndex + 1).trim();
      headerInit.push([
        name,
        value
      ]);
    }
  }
  return new Headers(headerInit);
}
__name(parseHeaders, "parseHeaders");
function extractBoundary(contentType) {
  const boundaryMatch = contentType.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!boundaryMatch) {
    throw new MultipartParseError("No boundary found in Content-Type header");
  }
  return boundaryMatch[1] ?? boundaryMatch[2];
}
__name(extractBoundary, "extractBoundary");
var AsyncMessageQueue = class {
  static {
    __name(this, "AsyncMessageQueue");
  }
  queue = [];
  waiters = [];
  finished = false;
  cancelled = false;
  error = null;
  /**
  * Producer: Enqueue a message for consumption
  */
  enqueue(message) {
    if (this.finished || this.cancelled) return;
    if (this.waiters.length > 0) {
      const waiter = this.waiters.shift();
      waiter.resolve(message);
    } else {
      this.queue.push(message);
    }
  }
  /**
  * Producer: Signal completion (with optional error)
  */
  finish(error45) {
    if (this.finished) return;
    this.finished = true;
    this.error = error45 || null;
    while (this.waiters.length > 0) {
      const waiter = this.waiters.shift();
      if (error45) {
        waiter.reject(error45);
      } else {
        waiter.resolve(null);
      }
    }
  }
  /**
  * Consumer: Cancel the queue (stops accepting new messages and notifies waiters)
  */
  cancel() {
    if (this.cancelled || this.finished) return;
    this.cancelled = true;
    while (this.waiters.length > 0) {
      const waiter = this.waiters.shift();
      waiter.resolve(null);
    }
  }
  /**
  * Consumer: Dequeue next message (or null if finished/cancelled)
  */
  async dequeue() {
    if (this.queue.length > 0) {
      return this.queue.shift();
    }
    if (this.finished || this.cancelled) {
      if (this.error) throw this.error;
      return null;
    }
    return new Promise((resolve, reject) => {
      this.waiters.push({
        resolve,
        reject
      });
    });
  }
  /**
  * Check if the queue is in a terminal state
  */
  get isTerminal() {
    return this.finished || this.cancelled;
  }
};
async function* parseMultipartStream(response, options) {
  if (!response.body) {
    throw new MultipartParseError("Response body is null");
  }
  const contentType = response.headers.get("content-type");
  if (!contentType) {
    throw new MultipartParseError("Missing Content-Type header");
  }
  const boundary = extractBoundary(contentType);
  const parser = new StreamingMultipartParser(boundary, options);
  yield* parser.parseStream(response.body);
}
__name(parseMultipartStream, "parseMultipartStream");
var StreamingMultipartParser = class {
  static {
    __name(this, "StreamingMultipartParser");
  }
  boundary;
  findOpeningBoundary;
  openingBoundaryLength;
  findBoundary;
  findPartialTailBoundary;
  boundaryLength;
  findDoubleNewline;
  // Safety limits
  maxHeaderSize;
  maxBoundaryBuffer;
  state = 0;
  buffer = null;
  currentHeaders = new Headers();
  currentPayloadController = null;
  constructor(boundary, options = {}) {
    this.boundary = boundary;
    this.findOpeningBoundary = createSearch(`--${boundary}`);
    this.openingBoundaryLength = 2 + boundary.length;
    this.findBoundary = createSearch(`\r
--${boundary}`);
    this.findPartialTailBoundary = createPartialTailSearch(`\r
--${boundary}`);
    this.boundaryLength = 4 + boundary.length;
    this.findDoubleNewline = createSearch("\r\n\r\n");
    this.maxHeaderSize = options.maxHeaderSize ?? 65536;
    this.maxBoundaryBuffer = options.maxBoundaryBuffer ?? 8192;
  }
  async *parseStream(stream) {
    const reader = stream.getReader();
    const messageQueue = new AsyncMessageQueue();
    const producer = this.startProducer(reader, messageQueue);
    try {
      yield* this.consumeMessages(messageQueue);
    } finally {
      messageQueue.cancel();
      this.closeCurrentPayload();
      try {
        await reader.cancel();
      } catch (error45) {
      }
      await producer;
    }
  }
  /**
  * Producer: Continuously read chunks and parse messages
  */
  async startProducer(reader, messageQueue) {
    try {
      while (!messageQueue.isTerminal) {
        let result;
        try {
          result = await reader.read();
        } catch (readError) {
          if (readError instanceof Error && (readError.name === "AbortError" || readError.constructor.name === "AbortError" || readError.name === "TimeoutError" || readError.constructor.name === "TimeoutError")) {
            break;
          }
          throw readError;
        }
        const { done, value } = result;
        if (done) {
          if (this.buffer !== null && this.buffer.length > 0) {
            const messages2 = this.write(new Uint8Array(0));
            for (const message of messages2) {
              if (messageQueue.isTerminal) break;
              messageQueue.enqueue(message);
            }
          }
          if (this.state !== 4) {
            if (this.state === 0) {
              throw new MultipartParseError("Invalid multipart stream: missing initial boundary");
            }
            throw new MultipartParseError("Unexpected end of stream");
          }
          break;
        }
        if (!(value instanceof Uint8Array)) {
          throw new MultipartParseError(`Invalid chunk type: expected Uint8Array, got ${typeof value}`);
        }
        const messages = this.write(value);
        for (const message of messages) {
          if (messageQueue.isTerminal) break;
          messageQueue.enqueue(message);
        }
      }
      if (!messageQueue.isTerminal) {
        messageQueue.finish();
      }
    } catch (error45) {
      this.closeCurrentPayload(error45);
      if (!messageQueue.isTerminal) {
        messageQueue.finish(error45);
      }
    } finally {
      try {
        reader.releaseLock();
      } catch (error45) {
      }
    }
  }
  /**
  * Consumer: Yield messages from the queue
  */
  async *consumeMessages(messageQueue) {
    while (true) {
      const message = await messageQueue.dequeue();
      if (message === null) {
        break;
      }
      yield message;
    }
  }
  /**
  * Process a chunk of data through the state machine and return any complete messages.
  *
  * Returns an array because a single chunk can contain multiple complete messages
  * when small messages with headers + body + boundary all fit in one network chunk.
  * All messages must be captured and queued to maintain proper message ordering.
  */
  write(chunk) {
    const newMessages = [];
    if (this.state === 4) {
      throw new MultipartParseError("Unexpected data after end of stream");
    }
    let index = 0;
    let chunkLength = chunk.length;
    if (this.buffer !== null) {
      const newSize = this.buffer.length + chunkLength;
      const maxAllowedSize = this.state === 2 ? this.maxHeaderSize : this.maxBoundaryBuffer;
      if (newSize > maxAllowedSize) {
        throw new MultipartParseError(`Buffer size limit exceeded: ${newSize} bytes > ${maxAllowedSize} bytes. This may indicate malformed multipart data with ${this.state === 2 ? "oversized headers" : "invalid boundaries"}.`);
      }
      const newChunk = new Uint8Array(newSize);
      newChunk.set(this.buffer, 0);
      newChunk.set(chunk, this.buffer.length);
      chunk = newChunk;
      chunkLength = chunk.length;
      this.buffer = null;
    }
    if (chunkLength === 0 && this.state === 0) {
      throw new MultipartParseError("Invalid multipart stream: missing initial boundary");
    }
    while (true) {
      if (this.state === 3) {
        if (chunkLength - index < this.boundaryLength) {
          const remainingData = chunk.subarray(index);
          if (remainingData.length > this.maxBoundaryBuffer) {
            throw new MultipartParseError(`Boundary buffer limit exceeded: ${remainingData.length} > ${this.maxBoundaryBuffer}`);
          }
          this.buffer = remainingData;
          break;
        }
        const boundaryIndex = this.findBoundary(chunk, index);
        if (boundaryIndex === -1) {
          const partialTailIndex = this.findPartialTailBoundary(chunk);
          if (partialTailIndex === -1) {
            this.writeBody(index === 0 ? chunk : chunk.subarray(index));
          } else {
            this.writeBody(chunk.subarray(index, partialTailIndex));
            const partialBoundary = chunk.subarray(partialTailIndex);
            if (partialBoundary.length > this.maxBoundaryBuffer) {
              throw new MultipartParseError(`Partial boundary too large: ${partialBoundary.length} > ${this.maxBoundaryBuffer}`);
            }
            this.buffer = partialBoundary;
          }
          break;
        }
        this.writeBody(chunk.subarray(index, boundaryIndex));
        this.finishMessage();
        index = boundaryIndex + this.boundaryLength;
        this.state = 1;
      }
      if (this.state === 1) {
        if (chunkLength - index < 2) {
          const remainingData = chunk.subarray(index);
          if (remainingData.length > this.maxBoundaryBuffer) {
            throw new MultipartParseError(`After-boundary buffer limit exceeded: ${remainingData.length} > ${this.maxBoundaryBuffer}`);
          }
          this.buffer = remainingData;
          break;
        }
        if (chunk[index] === 45 && chunk[index + 1] === 45) {
          this.state = 4;
          break;
        }
        if (chunk[index] === 13 && chunk[index + 1] === 10) {
          index += 2;
        } else if (chunk[index] === 10) {
          index += 1;
        } else {
          throw new MultipartParseError(`Invalid character after boundary: expected CRLF or LF, got 0x${chunk[index].toString(16)}`);
        }
        this.state = 2;
      }
      if (this.state === 2) {
        if (chunkLength - index < 4) {
          const remainingData = chunk.subarray(index);
          if (remainingData.length > this.maxHeaderSize) {
            throw new MultipartParseError(`Header buffer limit exceeded: ${remainingData.length} > ${this.maxHeaderSize}`);
          }
          this.buffer = remainingData;
          break;
        }
        let headerEndIndex = this.findDoubleNewline(chunk, index);
        let headerEndOffset = 4;
        if (headerEndIndex === -1) {
          const lfDoubleNewline = createSearch("\n\n");
          headerEndIndex = lfDoubleNewline(chunk, index);
          headerEndOffset = 2;
        }
        if (headerEndIndex === -1) {
          const headerData = chunk.subarray(index);
          if (headerData.length > this.maxHeaderSize) {
            throw new MultipartParseError(`Headers too large: ${headerData.length} > ${this.maxHeaderSize} bytes`);
          }
          this.buffer = headerData;
          break;
        }
        const headerBytes = chunk.subarray(index, headerEndIndex);
        this.currentHeaders = parseHeaders(headerBytes);
        const message = this.createStreamingMessage();
        newMessages.push(message);
        index = headerEndIndex + headerEndOffset;
        this.state = 3;
        continue;
      }
      if (this.state === 0) {
        if (chunkLength < this.openingBoundaryLength) {
          if (chunk.length > this.maxBoundaryBuffer) {
            throw new MultipartParseError(`Initial chunk too large for boundary detection: ${chunk.length} > ${this.maxBoundaryBuffer}`);
          }
          this.buffer = chunk;
          break;
        }
        const boundaryIndex = this.findOpeningBoundary(chunk);
        if (boundaryIndex !== 0) {
          throw new MultipartParseError("Invalid multipart stream: missing initial boundary");
        }
        index = this.openingBoundaryLength;
        this.state = 1;
      }
    }
    return newMessages;
  }
  createStreamingMessage() {
    const headers = new Headers(this.currentHeaders);
    const payload = new ReadableStream({
      start: /* @__PURE__ */ __name((controller) => {
        this.currentPayloadController = controller;
      }, "start")
    });
    this.currentHeaders = new Headers();
    return {
      headers,
      payload
    };
  }
  writeBody(chunk) {
    if (this.currentPayloadController) {
      this.currentPayloadController.enqueue(chunk);
    }
  }
  finishMessage() {
    if (this.currentPayloadController) {
      this.currentPayloadController.close();
      this.currentPayloadController = null;
    }
  }
  /**
  * Close current payload controller if open (used during cleanup)
  * If an error is provided, forwards it to the payload consumer
  */
  closeCurrentPayload(error45) {
    if (this.currentPayloadController) {
      try {
        if (error45) {
          this.currentPayloadController.error(error45);
        } else {
          this.currentPayloadController.close();
        }
      } catch (controllerError) {
      }
      this.currentPayloadController = null;
    }
  }
};

// node_modules/.pnpm/@vercel+queue@0.0.0-alpha.23/node_modules/@vercel/queue/dist/index.mjs
async function streamToBuffer(stream) {
  let totalLength = 0;
  const reader = stream.getReader();
  const chunks = [];
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      totalLength += value.length;
    }
  } finally {
    reader.releaseLock();
  }
  return Buffer.concat(chunks, totalLength);
}
__name(streamToBuffer, "streamToBuffer");
var JsonTransport = class {
  static {
    __name(this, "JsonTransport");
  }
  contentType = "application/json";
  replacer;
  reviver;
  constructor(options = {}) {
    this.replacer = options.replacer;
    this.reviver = options.reviver;
  }
  serialize(value) {
    return Buffer.from(JSON.stringify(value, this.replacer), "utf8");
  }
  async deserialize(stream) {
    const buffer = await streamToBuffer(stream);
    return JSON.parse(buffer.toString("utf8"), this.reviver);
  }
};
var devRouteHandlers = /* @__PURE__ */ new Map();
var wildcardRouteHandlers = /* @__PURE__ */ new Map();
function clearDevHandlers() {
  devRouteHandlers.clear();
  wildcardRouteHandlers.clear();
}
__name(clearDevHandlers, "clearDevHandlers");
if (process.env.NODE_ENV === "test" || process.env.VITEST) {
  globalThis.__clearDevHandlers = clearDevHandlers;
}

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config2,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse3,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config2,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse2,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k2 in _2.prototype) {
      if (!(k2 in inst)) Object.defineProperty(inst, k2, {
        value: _2.prototype[k2].bind(inst)
      });
    }
    inst._zod.constr = _2;
    inst._zod.def = def;
  }
  __name(init, "init");
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
    static {
      __name(this, "Definition");
    }
  }
  Object.defineProperty(Definition, "name", {
    value: name
  });
  function _2(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  __name(_2, "_");
  Object.defineProperty(_2, "init", {
    value: init
  });
  Object.defineProperty(_2, Symbol.hasInstance, {
    value: /* @__PURE__ */ __name((inst) => {
      if (params?.Parent && inst instanceof params.Parent) return true;
      return inst?._zod?.traits?.has(name);
    }, "value")
  });
  Object.defineProperty(_2, "name", {
    value: name
  });
  return _2;
}
__name($constructor, "$constructor");
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  static {
    __name(this, "$ZodAsyncError");
  }
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  static {
    __name(this, "$ZodEncodeError");
  }
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config2(newConfig) {
  if (newConfig) Object.assign(globalConfig, newConfig);
  return globalConfig;
}
__name(config2, "config");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
__name(assertEqual, "assertEqual");
function assertNotEqual(val) {
  return val;
}
__name(assertNotEqual, "assertNotEqual");
function assertIs(_arg) {
}
__name(assertIs, "assertIs");
function assertNever(_x) {
  throw new Error();
}
__name(assertNever, "assertNever");
function assert(_2) {
}
__name(assert, "assert");
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values = Object.entries(entries).filter(([k2, _2]) => numericValues.indexOf(+k2) === -1).map(([_2, v2]) => v2);
  return values;
}
__name(getEnumValues, "getEnumValues");
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
__name(joinValues, "joinValues");
function jsonStringifyReplacer(_2, value) {
  if (typeof value === "bigint") return value.toString();
  return value;
}
__name(jsonStringifyReplacer, "jsonStringifyReplacer");
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", {
          value
        });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
__name(cached, "cached");
function nullish(input) {
  return input === null || input === void 0;
}
__name(nullish, "nullish");
function cleanRegex(source) {
  const start2 = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start2, end);
}
__name(cleanRegex, "cleanRegex");
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
__name(floatSafeRemainder, "floatSafeRemainder");
var EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v2) {
      Object.defineProperty(object2, key, {
        value: v2
      });
    },
    configurable: true
  });
}
__name(defineLazy, "defineLazy");
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
__name(objectClone, "objectClone");
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
__name(assignProp, "assignProp");
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
__name(mergeDefs, "mergeDefs");
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
__name(cloneDef, "cloneDef");
function getElementAtPath(obj, path4) {
  if (!path4) return obj;
  return path4.reduce((acc, key) => acc?.[key], obj);
}
__name(getElementAtPath, "getElementAtPath");
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i2 = 0; i2 < keys.length; i2++) {
      resolvedObj[keys[i2]] = results[i2];
    }
    return resolvedObj;
  });
}
__name(promiseAllObject, "promiseAllObject");
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i2 = 0; i2 < length; i2++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
__name(randomString, "randomString");
function esc(str) {
  return JSON.stringify(str);
}
__name(esc, "esc");
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
__name(isObject, "isObject");
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F2 = Function;
    new F2("");
    return true;
  } catch (_2) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject(o2) === false) return false;
  const ctor = o2.constructor;
  if (ctor === void 0) return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
__name(isPlainObject, "isPlainObject");
function shallowClone(o2) {
  if (isPlainObject(o2)) return {
    ...o2
  };
  if (Array.isArray(o2)) return [
    ...o2
  ];
  return o2;
}
__name(shallowClone, "shallowClone");
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
__name(numKeys, "numKeys");
var getParsedType = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t2}`);
  }
}, "getParsedType");
var propertyKeyTypes = /* @__PURE__ */ new Set([
  "string",
  "number",
  "symbol"
]);
var primitiveTypes = /* @__PURE__ */ new Set([
  "string",
  "number",
  "bigint",
  "boolean",
  "symbol",
  "undefined"
]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegex, "escapeRegex");
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent) cl._zod.parent = inst;
  return cl;
}
__name(clone, "clone");
function normalizeParams(_params) {
  const params = _params;
  if (!params) return {};
  if (typeof params === "string") return {
    error: /* @__PURE__ */ __name(() => params, "error")
  };
  if (params?.message !== void 0) {
    if (params?.error !== void 0) throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string") return {
    ...params,
    error: /* @__PURE__ */ __name(() => params.error, "error")
  };
  return params;
}
__name(normalizeParams, "normalizeParams");
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_2, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_2, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_2, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_2, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_2) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_2, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_2, prop, descriptor2) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor2);
    }
  });
}
__name(createTransparentProxy, "createTransparentProxy");
function stringifyPrimitive(value) {
  if (typeof value === "bigint") return value.toString() + "n";
  if (typeof value === "string") return `"${value}"`;
  return `${value}`;
}
__name(stringifyPrimitive, "stringifyPrimitive");
function optionalKeys(shape) {
  return Object.keys(shape).filter((k2) => {
    return shape[k2]._zod.optin === "optional" && shape[k2]._zod.optout === "optional";
  });
}
__name(optionalKeys, "optionalKeys");
var NUMBER_FORMAT_RANGES = {
  safeint: [
    Number.MIN_SAFE_INTEGER,
    Number.MAX_SAFE_INTEGER
  ],
  int32: [
    -2147483648,
    2147483647
  ],
  uint32: [
    0,
    4294967295
  ],
  float32: [
    -34028234663852886e22,
    34028234663852886e22
  ],
  float64: [
    -Number.MAX_VALUE,
    Number.MAX_VALUE
  ]
};
var BIGINT_FORMAT_RANGES = {
  int64: [
    /* @__PURE__ */ BigInt("-9223372036854775808"),
    /* @__PURE__ */ BigInt("9223372036854775807")
  ],
  uint64: [
    /* @__PURE__ */ BigInt(0),
    /* @__PURE__ */ BigInt("18446744073709551615")
  ]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key]) continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(pick, "pick");
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {
        ...schema._zod.def.shape
      };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key]) continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(omit, "omit");
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = {
        ...schema._zod.def.shape,
        ...shape
      };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(extend, "extend");
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = {
        ...schema._zod.def.shape,
        ...shape
      };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
__name(safeExtend, "safeExtend");
function merge(a2, b2) {
  const def = mergeDefs(a2._zod.def, {
    get shape() {
      const _shape = {
        ...a2._zod.def.shape,
        ...b2._zod.def.shape
      };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b2._zod.def.catchall;
    },
    checks: []
  });
  return clone(a2, def);
}
__name(merge, "merge");
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = {
        ...oldShape
      };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key]) continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(partial, "partial");
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = {
        ...oldShape
      };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key]) continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
__name(required, "required");
function aborted(x2, startIndex = 0) {
  if (x2.aborted === true) return true;
  for (let i2 = startIndex; i2 < x2.issues.length; i2++) {
    if (x2.issues[i2]?.continue !== true) {
      return true;
    }
  }
  return false;
}
__name(aborted, "aborted");
function prefixIssues(path4, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path4);
    return iss;
  });
}
__name(prefixIssues, "prefixIssues");
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
__name(unwrapMessage, "unwrapMessage");
function finalizeIssue(iss, ctx, config3) {
  const full = {
    ...iss,
    path: iss.path ?? []
  };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config3.customError?.(iss)) ?? unwrapMessage(config3.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
__name(finalizeIssue, "finalizeIssue");
function getSizableOrigin(input) {
  if (input instanceof Set) return "set";
  if (input instanceof Map) return "map";
  if (input instanceof File) return "file";
  return "unknown";
}
__name(getSizableOrigin, "getSizableOrigin");
function getLengthableOrigin(input) {
  if (Array.isArray(input)) return "array";
  if (typeof input === "string") return "string";
  return "unknown";
}
__name(getLengthableOrigin, "getLengthableOrigin");
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return {
    ...iss
  };
}
__name(issue, "issue");
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k2, _2]) => {
    return Number.isNaN(Number.parseInt(k2, 10));
  }).map((el) => el[1]);
}
__name(cleanEnum, "cleanEnum");
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i2 = 0; i2 < binaryString.length; i2++) {
    bytes[i2] = binaryString.charCodeAt(i2);
  }
  return bytes;
}
__name(base64ToUint8Array, "base64ToUint8Array");
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    binaryString += String.fromCharCode(bytes[i2]);
  }
  return btoa(binaryString);
}
__name(uint8ArrayToBase64, "uint8ArrayToBase64");
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
__name(base64urlToUint8Array, "base64urlToUint8Array");
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
__name(uint8ArrayToBase64url, "uint8ArrayToBase64url");
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i2 = 0; i2 < cleanHex.length; i2 += 2) {
    bytes[i2 / 2] = Number.parseInt(cleanHex.slice(i2, i2 + 2), 16);
  }
  return bytes;
}
__name(hexToUint8Array, "hexToUint8Array");
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b2) => b2.toString(16).padStart(2, "0")).join("");
}
__name(uint8ArrayToHex, "uint8ArrayToHex");
var Class = class {
  static {
    __name(this, "Class");
  }
  constructor(..._args) {
  }
};

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/errors.js
var initializer = /* @__PURE__ */ __name((inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: /* @__PURE__ */ __name(() => inst.message, "value"),
    enumerable: false
  });
}, "initializer");
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, {
  Parent: Error
});
function flattenError(error45, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error45.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return {
    formErrors,
    fieldErrors
  };
}
__name(flattenError, "flattenError");
function formatError(error45, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = {
    _errors: []
  };
  const processError = /* @__PURE__ */ __name((error46) => {
    for (const issue2 of error46.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({
          issues
        }));
      } else if (issue2.code === "invalid_key") {
        processError({
          issues: issue2.issues
        });
      } else if (issue2.code === "invalid_element") {
        processError({
          issues: issue2.issues
        });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i2 = 0;
        while (i2 < issue2.path.length) {
          const el = issue2.path[i2];
          const terminal = i2 === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || {
              _errors: []
            };
          } else {
            curr[el] = curr[el] || {
              _errors: []
            };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i2++;
        }
      }
    }
  }, "processError");
  processError(error45);
  return fieldErrors;
}
__name(formatError, "formatError");
function treeifyError(error45, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = {
    errors: []
  };
  const processError = /* @__PURE__ */ __name((error46, path4 = []) => {
    var _a, _b;
    for (const issue2 of error46.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({
          issues
        }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({
          issues: issue2.issues
        }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({
          issues: issue2.issues
        }, issue2.path);
      } else {
        const fullpath = [
          ...path4,
          ...issue2.path
        ];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i2 = 0;
        while (i2 < fullpath.length) {
          const el = fullpath[i2];
          const terminal = i2 === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = {
              errors: []
            });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = {
              errors: []
            });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i2++;
        }
      }
    }
  }, "processError");
  processError(error45);
  return result;
}
__name(treeifyError, "treeifyError");
function toDotPath(_path) {
  const segs = [];
  const path4 = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path4) {
    if (typeof seg === "number") segs.push(`[${seg}]`);
    else if (typeof seg === "symbol") segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length) segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
__name(toDotPath, "toDotPath");
function prettifyError(error45) {
  const lines = [];
  const issues = [
    ...error45.issues
  ].sort((a2, b2) => (a2.path ?? []).length - (b2.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length) lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
__name(prettifyError, "prettifyError");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/parse.js
var _parse = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    async: false
  }) : {
    async: false
  };
  const result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
}, "_parse");
var parse2 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    async: true
  }) : {
    async: true
  };
  let result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
}, "_parseAsync");
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? {
    ..._ctx,
    async: false
  } : {
    async: false
  };
  const result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  } : {
    success: true,
    data: result.value
  };
}, "_safeParse");
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    async: true
  }) : {
    async: true
  };
  let result = schema._zod.run({
    value,
    issues: []
  }, ctx);
  if (result instanceof Promise) result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  } : {
    success: true,
    data: result.value
  };
}, "_safeParseAsync");
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    direction: "backward"
  }) : {
    direction: "backward"
  };
  return _parse(_Err)(schema, value, ctx);
}, "_encode");
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
}, "_decode");
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    direction: "backward"
  }) : {
    direction: "backward"
  };
  return _parseAsync(_Err)(schema, value, ctx);
}, "_encodeAsync");
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
}, "_decodeAsync");
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    direction: "backward"
  }) : {
    direction: "backward"
  };
  return _safeParse(_Err)(schema, value, ctx);
}, "_safeEncode");
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = /* @__PURE__ */ __name((_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
}, "_safeDecode");
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, {
    direction: "backward"
  }) : {
    direction: "backward"
  };
  return _safeParseAsync(_Err)(schema, value, ctx);
}, "_safeEncodeAsync");
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = /* @__PURE__ */ __name((_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
}, "_safeDecodeAsync");
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = /* @__PURE__ */ __name((version2) => {
  if (!version2) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
}, "uuid");
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
__name(emoji, "emoji");
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
__name(timeSource, "timeSource");
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
__name(time, "time");
function datetime(args) {
  const time3 = timeSource({
    precision: args.precision
  });
  const opts = [
    "Z"
  ];
  if (args.local) opts.push("");
  if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
__name(datetime, "datetime");
var string = /* @__PURE__ */ __name((params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
}, "string");
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
__name(fixedBase64, "fixedBase64");
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
__name(fixedBase64url, "fixedBase64url");
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive) bag.maximum = def.value;
      else bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive) bag.minimum = def.value;
      else bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value) throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple) return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt) bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum) return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum) return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size) return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? {
        code: "too_big",
        maximum: def.size
      } : {
        code: "too_small",
        minimum: def.size
      },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr) inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum) return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr) inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum) return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length) return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? {
        code: "too_big",
        maximum: def.length
      } : {
        code: "too_small",
        minimum: def.length
      },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern) (_a = inst._zod).check ?? (_a.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? {
        pattern: def.pattern.toString()
      } : {},
      inst,
      continue: !def.abort
    });
  });
  else (_b = inst._zod).check ?? (_b.check = () => {
  });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix)) return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
__name(handleCheckPropertyResult, "handleCheckPropertyResult");
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type)) return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/doc.js
var Doc = class {
  static {
    __name(this, "Doc");
  }
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this) this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, {
        execution: "sync"
      });
      arg(this, {
        execution: "async"
      });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x2) => x2);
    const minIndent = Math.min(...lines.map((x2) => x2.length - x2.trimStart().length));
    const dedented = lines.map((x2) => x2.slice(minIndent)).map((x2) => " ".repeat(this.indent * 2) + x2);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F2 = Function;
    const args = this?.args;
    const content = this?.content ?? [
      ``
    ];
    const lines = [
      ...content.map((x2) => `  ${x2}`)
    ];
    return new F2(...args, lines.join("\n"));
  }
};

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 11
};

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [
    ...inst._zod.def.checks ?? []
  ];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = /* @__PURE__ */ __name((payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun) continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _2 = ch._zod.check(payload);
        if (_2 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _2 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _2;
            const nextLen = payload.issues.length;
            if (nextLen === currLen) return;
            if (!isAborted) isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen) continue;
          if (!isAborted) isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    }, "runChecks");
    const handleCanaryResult = /* @__PURE__ */ __name((canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    }, "handleCanaryResult");
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({
          value: payload.value,
          issues: []
        }, {
          ...ctx,
          skipChecks: true
        });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: /* @__PURE__ */ __name((value) => {
      try {
        const r2 = safeParse(inst, value);
        return r2.success ? {
          value: r2.data
        } : {
          issues: r2.error?.issues
        };
      } catch (_2) {
        return safeParseAsync(inst, value).then((r2) => r2.success ? {
          value: r2.data
        } : {
          issues: r2.error?.issues
        });
      }
    }, "validate"),
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [
    ...inst?._zod.bag?.patterns ?? []
  ].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _2) => {
    if (def.coerce) try {
      payload.value = String(payload.value);
    } catch (_3) {
    }
    if (typeof payload.value === "string") return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === void 0) throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_2) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2) throw new Error();
      const [address, prefix] = parts;
      if (!prefix) throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix) throw new Error();
      if (prefixNum < 0 || prefixNum > 128) throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "") return true;
  if (data.length % 4 !== 0) return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
__name(isValidBase64, "isValidBase64");
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data)) return false;
  const base643 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
__name(isValidBase64URL, "isValidBase64URL");
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3) return false;
    const [header] = tokensParts;
    if (!header) return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT") return false;
    if (!parsedHeader.alg) return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
    return true;
  } catch {
    return false;
  }
}
__name(isValidJWT, "isValidJWT");
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg)) return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value)) return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) try {
      payload.value = Number(payload.value);
    } catch (_2) {
    }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? {
        received
      } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) try {
      payload.value = Boolean(payload.value);
    } catch (_2) {
    }
    const input = payload.value;
    if (typeof input === "boolean") return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) try {
      payload.value = BigInt(payload.value);
    } catch (_2) {
    }
    if (typeof payload.value === "bigint") return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol") return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([
    void 0
  ]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined") return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([
    null
  ]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null) return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined") return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate) return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? {
        received: "Invalid Date"
      } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleArrayResult, "handleArrayResult");
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i2 = 0; i2 < input.length; i2++) {
      const item = input[i2];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i2)));
      } else {
        handleArrayResult(result, payload, i2);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
__name(handlePropertyResult, "handlePropertyResult");
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k2 of keys) {
    if (!def.shape?.[k2]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k2}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
__name(normalizeDef, "normalizeDef");
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t2 = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key)) continue;
    if (t2 === "never") {
      unrecognized.push(key);
      continue;
    }
    const r2 = _catchall.run({
      value: input[key],
      issues: []
    }, ctx);
    if (r2 instanceof Promise) {
      proms.push(r2.then((r3) => handlePropertyResult(r3, payload, key, input)));
    } else {
      handlePropertyResult(r2, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length) return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
__name(handleCatchall, "handleCatchall");
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: /* @__PURE__ */ __name(() => {
        const newSh = {
          ...sh
        };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }, "get")
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v2 of field.values) propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r2 = el._zod.run({
        value: input[key],
        issues: []
      }, ctx);
      if (r2 instanceof Promise) {
        proms.push(r2.then((r3) => handlePropertyResult(r3, payload, key, input)));
      } else {
        handlePropertyResult(r2, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = /* @__PURE__ */ __name((shape) => {
    const doc = new Doc([
      "shape",
      "payload",
      "ctx"
    ]);
    const normalized = _normalized.value;
    const parseStr = /* @__PURE__ */ __name((key) => {
      const k2 = esc(key);
      return `shape[${k2}]._zod.run({ value: input[${k2}], issues: [] }, ctx)`;
    }, "parseStr");
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k2 = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k2}, ...iss.path] : [${k2}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k2} in input) {
            newResult[${k2}] = undefined;
          }
        } else {
          newResult[${k2}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, "generateFastpass");
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass) fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall) return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r2) => !aborted(r2));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config2())))
  });
  return final;
}
__name(handleUnionResults, "handleUnionResults");
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0) return result;
        results.push(result);
      }
    }
    if (!async) return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k2, v2] of Object.entries(pv)) {
        if (!propValues[k2]) propValues[k2] = /* @__PURE__ */ new Set();
        for (const val of v2) {
          propValues[k2].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o2 of opts) {
      const values = o2._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);
      for (const v2 of values) {
        if (map2.has(v2)) {
          throw new Error(`Duplicate discriminator value "${String(v2)}"`);
        }
        map2.set(v2, o2);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [
        def.discriminator
      ],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({
      value: input,
      issues: []
    }, ctx);
    const right = def.right._zod.run({
      value: input,
      issues: []
    }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([
        left,
        right
      ]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b2) {
  if (a2 === b2) {
    return {
      valid: true,
      data: a2
    };
  }
  if (a2 instanceof Date && b2 instanceof Date && +a2 === +b2) {
    return {
      valid: true,
      data: a2
    };
  }
  if (isPlainObject(a2) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = {
      ...a2,
      ...b2
    };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [
            key,
            ...sharedValue.mergeErrorPath
          ]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return {
      valid: true,
      data: newObj
    };
  }
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length) {
      return {
        valid: false,
        mergeErrorPath: []
      };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [
            index,
            ...sharedValue.mergeErrorPath
          ]
        };
      }
      newArray.push(sharedValue.data);
    }
    return {
      valid: true,
      data: newArray
    };
  }
  return {
    valid: false,
    mergeErrorPath: []
  };
}
__name(mergeValues, "mergeValues");
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result)) return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
__name(handleIntersectionResults, "handleIntersectionResults");
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [
    ...items
  ].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? {
            code: "too_big",
            maximum: items.length
          } : {
            code: "too_small",
            minimum: items.length
          },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i2 = -1;
    for (const item of items) {
      i2++;
      if (i2 >= input.length) {
        if (i2 >= optStart) continue;
      }
      const result = item._zod.run({
        value: input[i2],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
      } else {
        handleTupleResult(result, payload, i2);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i2++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i2)));
        } else {
          handleTupleResult(result, payload, i2);
        }
      }
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
__name(handleTupleResult, "handleTupleResult");
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({
            value: input[key],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__") continue;
        const keyResult = def.keyType._zod.run({
          value: key,
          issues: []
        }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2())),
            input: key,
            path: [
              key
            ],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({
          value: input[key],
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({
        value: key,
        issues: []
      }, ctx);
      const valueResult = def.valueType._zod.run({
        value,
        issues: []
      }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([
          keyResult,
          valueResult
        ]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
__name(handleMapResult, "handleMapResult");
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else handleSetResult(result, payload);
    }
    if (proms.length) return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
__name(handleSetResult, "handleSetResult");
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k2) => propertyKeyTypes.has(typeof k2)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? escapeRegex(o2.toString()) : String(o2)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File) return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return {
      issues: [],
      value: void 0
    };
  }
  return result;
}
__name(handleOptionalResult, "handleOptionalResult");
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([
      ...def.innerType._zod.values,
      void 0
    ]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) return result.then((r2) => handleOptionalResult(r2, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([
      ...def.innerType._zod.values,
      null
    ]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null) return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
__name(handleDefaultResult, "handleDefaultResult");
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([
      ...v2
    ].filter((x2) => x2 !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
__name(handleNonOptionalResult, "handleNonOptionalResult");
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config2()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next2, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next2._zod.run({
    value: left.value,
    issues: left.issues
  }, ctx);
}
__name(handlePipeResult, "handlePipeResult");
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
__name(handleCodecAResult, "handleCodecAResult");
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({
    value,
    issues: left.issues
  }, ctx);
}
__name(handleCodecTxResult, "handleCodecTxResult");
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
__name(handleReadonlyResult, "handleReadonlyResult");
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[
          ...part._zod.traits
        ].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start2 = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start2, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse2(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse2(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F2 = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F2({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F2({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F2 = inst.constructor;
    return new F2({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({
      value: inner,
      issues: []
    }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? void 0);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? void 0);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _2) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r2 = def.fn(input);
    if (r2 instanceof Promise) {
      return r2.then((r3) => handleRefineResult(r3, payload, input, inst));
    }
    handleRefineResult(r2, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [
        ...inst._zod.def.path ?? []
      ],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params) _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
__name(handleRefineResult, "handleRefineResult");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ar.js
var error = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u062D\u0631\u0641",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    },
    file: {
      unit: "\u0628\u0627\u064A\u062A",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    },
    array: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    },
    set: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0645\u062F\u062E\u0644",
    email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
    url: "\u0631\u0627\u0628\u0637",
    emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
    ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
    ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
    cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
    cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
    base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
    base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
    json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
    e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
    jwt: "JWT",
    template_literal: "\u0645\u062F\u062E\u0644"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
        return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
        if (_issue.format === "ends_with") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
}, "error");
function ar_default() {
  return {
    localeError: error()
  };
}
__name(ar_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/az.js
var error2 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "simvol",
      verb: "olmal\u0131d\u0131r"
    },
    file: {
      unit: "bayt",
      verb: "olmal\u0131d\u0131r"
    },
    array: {
      unit: "element",
      verb: "olmal\u0131d\u0131r"
    },
    set: {
      unit: "element",
      verb: "olmal\u0131d\u0131r"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
        if (_issue.format === "ends_with") return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
        if (_issue.format === "includes") return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
        if (_issue.format === "regex") return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
        return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return `Yanl\u0131\u015F d\u0259y\u0259r`;
    }
  };
}, "error");
function az_default() {
  return {
    localeError: error2()
  };
}
__name(az_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getBelarusianPlural, "getBelarusianPlural");
var error3 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E"
      },
      verb: "\u043C\u0435\u0446\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0456\u045E";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0443\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0430\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0447\u0430\u0441",
    duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
    cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
    base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
    json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
    e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0443\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
      default:
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
    }
  };
}, "error");
function be_default() {
  return {
    localeError: error3()
  };
}
__name(be_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ca.js
var error4 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "car\xE0cters",
      verb: "contenir"
    },
    file: {
      unit: "bytes",
      verb: "contenir"
    },
    array: {
      unit: "elements",
      verb: "contenir"
    },
    set: {
      unit: "elements",
      verb: "contenir"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entrada",
    email: "adre\xE7a electr\xF2nica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adre\xE7a IPv4",
    ipv6: "adre\xE7a IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType7(issue2.input)}`;
      // return `Tipus invÃ lid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex") return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
        return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      // Could also be "Tipus d'uniÃ³ invÃ lid" but "Entrada invÃ lida" is more general
      case "invalid_element":
        return `Element inv\xE0lid a ${issue2.origin}`;
      default:
        return `Entrada inv\xE0lida`;
    }
  };
}, "error");
function ca_default() {
  return {
    localeError: error4()
  };
}
__name(ca_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/cs.js
var error5 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "znak\u016F",
      verb: "m\xEDt"
    },
    file: {
      unit: "bajt\u016F",
      verb: "m\xEDt"
    },
    array: {
      unit: "prvk\u016F",
      verb: "m\xEDt"
    },
    set: {
      unit: "prvk\u016F",
      verb: "m\xEDt"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
      }
      case "string": {
        return "\u0159et\u011Bzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "regul\xE1rn\xED v\xFDraz",
    email: "e-mailov\xE1 adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a \u010Das ve form\xE1tu ISO",
    date: "datum ve form\xE1tu ISO",
    time: "\u010Das ve form\xE1tu ISO",
    duration: "doba trv\xE1n\xED ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
    base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
    json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
    e164: "\u010D\xEDslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
        }
        return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex") return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
        return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${issue2.origin}`;
      default:
        return `Neplatn\xFD vstup`;
    }
  };
}, "error");
function cs_default() {
  return {
    localeError: error5()
  };
}
__name(cs_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/da.js
var error6 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "tegn",
      verb: "havde"
    },
    file: {
      unit: "bytes",
      verb: "havde"
    },
    array: {
      unit: "elementer",
      verb: "indeholdt"
    },
    set: {
      unit: "elementer",
      verb: "indeholdt"
    }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "s\xE6t",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  __name(getTypeName, "getTypeName");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkesl\xE6t",
    date: "ISO-dato",
    time: "ISO-klokkesl\xE6t",
    duration: "ISO-varighed",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType7(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex") return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8gle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig v\xE6rdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
}, "error");
function da_default() {
  return {
    localeError: error6()
  };
}
__name(da_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/de.js
var error7 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "Zeichen",
      verb: "zu haben"
    },
    file: {
      unit: "Bytes",
      verb: "zu haben"
    },
    array: {
      unit: "Elemente",
      verb: "zu haben"
    },
    set: {
      unit: "Elemente",
      verb: "zu haben"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with") return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes") return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex") return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${issue2.origin}`;
      default:
        return `Ung\xFCltige Eingabe`;
    }
  };
}, "error");
function de_default() {
  return {
    localeError: error7()
  };
}
__name(de_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/en.js
var parsedType = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error8 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "characters",
      verb: "to have"
    },
    file: {
      unit: "bytes",
      verb: "to have"
    },
    array: {
      unit: "items",
      verb: "to have"
    },
    set: {
      unit: "items",
      verb: "to have"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex") return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
}, "error");
function en_default() {
  return {
    localeError: error8()
  };
}
__name(en_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/eo.js
var parsedType2 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error9 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "karaktrojn",
      verb: "havi"
    },
    file: {
      unit: "bajtojn",
      verb: "havi"
    },
    array: {
      unit: "elementojn",
      verb: "havi"
    },
    set: {
      unit: "elementojn",
      verb: "havi"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emo\u011Dio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-da\u016Dro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex") return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida \u015Dlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
}, "error");
function eo_default() {
  return {
    localeError: error9()
  };
}
__name(eo_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/es.js
var error10 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "caracteres",
      verb: "tener"
    },
    file: {
      unit: "bytes",
      verb: "tener"
    },
    array: {
      unit: "elementos",
      verb: "tener"
    },
    set: {
      unit: "elementos",
      verb: "tener"
    }
  };
  const TypeNames = {
    string: "texto",
    number: "n\xFAmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "n\xFAmero grande",
    symbol: "s\xEDmbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funci\xF3n",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeraci\xF3n",
    union: "uni\xF3n",
    literal: "literal",
    promise: "promesa",
    void: "vac\xEDo",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  __name(getTypeName, "getTypeName");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entrada",
    email: "direcci\xF3n de correo electr\xF3nico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duraci\xF3n ISO",
    ipv4: "direcci\xF3n IPv4",
    ipv6: "direcci\xF3n IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType7(issue2.input))}`;
      // return `Entrada invÃ¡lida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex") return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
        return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada inv\xE1lida`;
    }
  };
}, "error");
function es_default() {
  return {
    localeError: error10()
  };
}
__name(es_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/fa.js
var error11 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    },
    file: {
      unit: "\u0628\u0627\u06CC\u062A",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    },
    array: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    },
    set: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u0627\u06CC\u0647";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u06CC",
    email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
    url: "URL",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
    time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
    ipv4: "IPv4 \u0622\u062F\u0631\u0633",
    ipv6: "IPv6 \u0622\u062F\u0631\u0633",
    cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
    cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
    base64: "base64-encoded \u0631\u0634\u062A\u0647",
    base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
    json_string: "JSON \u0631\u0634\u062A\u0647",
    e164: "E.164 \u0639\u062F\u062F",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u06CC"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType7(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
        }
        return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
        }
        return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
        }
        if (_issue.format === "ends_with") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
        }
        if (_issue.format === "includes") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
        }
        if (_issue.format === "regex") {
          return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
      case "invalid_union":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
      default:
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
    }
  };
}, "error");
function fa_default() {
  return {
    localeError: error11()
  };
}
__name(fa_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/fi.js
var error12 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "merkki\xE4",
      subject: "merkkijonon"
    },
    file: {
      unit: "tavua",
      subject: "tiedoston"
    },
    array: {
      unit: "alkiota",
      subject: "listan"
    },
    set: {
      unit: "alkiota",
      subject: "joukon"
    },
    number: {
      unit: "",
      subject: "luvun"
    },
    bigint: {
      unit: "",
      subject: "suuren kokonaisluvun"
    },
    int: {
      unit: "",
      subject: "kokonaisluvun"
    },
    date: {
      unit: "",
      subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "s\xE4\xE4nn\xF6llinen lauseke",
    email: "s\xE4hk\xF6postiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen sy\xF6te`;
    }
  };
}, "error");
function fi_default() {
  return {
    localeError: error12()
  };
}
__name(fi_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/fr.js
var error13 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "caract\xE8res",
      verb: "avoir"
    },
    file: {
      unit: "octets",
      verb: "avoir"
    },
    array: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    },
    set: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType7(issue2.input)} re\xE7u`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex") return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_default() {
  return {
    localeError: error13()
  };
}
__name(fr_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/fr-CA.js
var error14 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "caract\xE8res",
      verb: "avoir"
    },
    file: {
      unit: "octets",
      verb: "avoir"
    },
    array: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    },
    set: {
      unit: "\xE9l\xE9ments",
      verb: "avoir"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "entr\xE9e",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dur\xE9e ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "cha\xEEne encod\xE9e en base64",
    base64url: "cha\xEEne encod\xE9e en base64url",
    json_string: "cha\xEEne JSON",
    e164: "num\xE9ro E.164",
    jwt: "JWT",
    template_literal: "entr\xE9e"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u2264" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u2265" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex") return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entr\xE9e invalide`;
    }
  };
}, "error");
function fr_CA_default() {
  return {
    localeError: error14()
  };
}
__name(fr_CA_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/he.js
var error15 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    },
    file: {
      unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    },
    array: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    },
    set: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u05E7\u05DC\u05D8",
    email: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
    url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
    emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
    date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
    time: "\u05D6\u05DE\u05DF ISO",
    duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
    ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
    ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
    cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
    cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
    base64: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
    base64url: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
    json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
    e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
    jwt: "JWT",
    template_literal: "\u05E7\u05DC\u05D8"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${issue2.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${parsedType7(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${issue2.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${issue2.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${issue2.origin}`;
      default:
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
    }
  };
}, "error");
function he_default() {
  return {
    localeError: error15()
  };
}
__name(he_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/hu.js
var error16 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "karakter",
      verb: "legyen"
    },
    file: {
      unit: "byte",
      verb: "legyen"
    },
    array: {
      unit: "elem",
      verb: "legyen"
    },
    set: {
      unit: "elem",
      verb: "legyen"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "sz\xE1m";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "t\xF6mb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "bemenet",
    email: "email c\xEDm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO id\u0151b\xE9lyeg",
    date: "ISO d\xE1tum",
    time: "ISO id\u0151",
    duration: "ISO id\u0151intervallum",
    ipv4: "IPv4 c\xEDm",
    ipv6: "IPv6 c\xEDm",
    cidrv4: "IPv4 tartom\xE1ny",
    cidrv6: "IPv6 tartom\xE1ny",
    base64: "base64-k\xF3dolt string",
    base64url: "base64url-k\xF3dolt string",
    json_string: "JSON string",
    e164: "E.164 sz\xE1m",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType7(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
        if (_issue.format === "ends_with") return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
        if (_issue.format === "includes") return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
        if (_issue.format === "regex") return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
        return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
      default:
        return `\xC9rv\xE9nytelen bemenet`;
    }
  };
}, "error");
function hu_default() {
  return {
    localeError: error16()
  };
}
__name(hu_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/id.js
var error17 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "karakter",
      verb: "memiliki"
    },
    file: {
      unit: "byte",
      verb: "memiliki"
    },
    array: {
      unit: "item",
      verb: "memiliki"
    },
    set: {
      unit: "item",
      verb: "memiliki"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes") return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex") return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
}, "error");
function id_default() {
  return {
    localeError: error17()
  };
}
__name(id_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/is.js
var parsedType3 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "n\xFAmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error18 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "stafi",
      verb: "a\xF0 hafa"
    },
    file: {
      unit: "b\xE6ti",
      verb: "a\xF0 hafa"
    },
    array: {
      unit: "hluti",
      verb: "a\xF0 hafa"
    },
    set: {
      unit: "hluti",
      verb: "a\xF0 hafa"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl\xF3\xF0",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og t\xEDmi",
    date: "ISO dagsetning",
    time: "ISO t\xEDmi",
    duration: "ISO t\xEDmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 t\xF6lugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType3(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
        if (_issue.format === "regex") return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill \xED ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi \xED ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
}, "error");
function is_default() {
  return {
    localeError: error18()
  };
}
__name(is_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/it.js
var error19 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "caratteri",
      verb: "avere"
    },
    file: {
      unit: "byte",
      verb: "avere"
    },
    array: {
      unit: "elementi",
      verb: "avere"
    },
    set: {
      unit: "elementi",
      verb: "avere"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType7(issue2.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex") return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
}, "error");
function it_default() {
  return {
    localeError: error19()
  };
}
__name(it_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ja.js
var error20 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u6587\u5B57",
      verb: "\u3067\u3042\u308B"
    },
    file: {
      unit: "\u30D0\u30A4\u30C8",
      verb: "\u3067\u3042\u308B"
    },
    array: {
      unit: "\u8981\u7D20",
      verb: "\u3067\u3042\u308B"
    },
    set: {
      unit: "\u8981\u7D20",
      verb: "\u3067\u3042\u308B"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u914D\u5217";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u5165\u529B\u5024",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
    url: "URL",
    emoji: "\u7D75\u6587\u5B57",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u6642",
    date: "ISO\u65E5\u4ED8",
    time: "ISO\u6642\u523B",
    duration: "ISO\u671F\u9593",
    ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
    ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
    cidrv4: "IPv4\u7BC4\u56F2",
    cidrv6: "IPv6\u7BC4\u56F2",
    base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
    json_string: "JSON\u6587\u5B57\u5217",
    e164: "E.164\u756A\u53F7",
    jwt: "JWT",
    template_literal: "\u5165\u529B\u5024"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType7(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
        return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "ends_with") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "includes") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        if (_issue.format === "regex") return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
        return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return `\u7121\u52B9\u306A\u5165\u529B`;
    }
  };
}, "error");
function ja_default() {
  return {
    localeError: error20()
  };
}
__name(ja_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ka.js
var parsedType4 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
  };
  return typeMap[t2] ?? t2;
}, "parsedType");
var error21 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1"
    },
    file: {
      unit: "\u10D1\u10D0\u10D8\u10E2\u10D8",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1"
    },
    array: {
      unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1"
    },
    set: {
      unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8",
      verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
    email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    url: "URL",
    emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
    date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
    time: "\u10D3\u10E0\u10DD",
    duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
    ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
    cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
    base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
    e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
    jwt: "JWT",
    template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
        }
        if (_issue.format === "ends_with") return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
        if (_issue.format === "includes") return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
        if (_issue.format === "regex") return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
      case "unrecognized_keys":
        return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
      case "invalid_union":
        return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
      case "invalid_element":
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
      default:
        return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
    }
  };
}, "error");
function ka_default() {
  return {
    localeError: error21()
  };
}
__name(ka_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/km.js
var error22 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    },
    file: {
      unit: "\u1794\u17C3",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    },
    array: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    },
    set: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u17A2\u17B6\u179A\u17C1 (Array)";
        }
        if (data === null) {
          return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
    url: "URL",
    emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
    date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
    time: "\u1798\u17C9\u17C4\u1784 ISO",
    duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
    ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
    cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
    base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
    base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
    json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
    e164: "\u179B\u17C1\u1781 E.164",
    jwt: "JWT",
    template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
        return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
        return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
        return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      case "invalid_union":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
      default:
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
    }
  };
}, "error");
function km_default() {
  return {
    localeError: error22()
  };
}
__name(km_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
__name(kh_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ko.js
var error23 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\uBB38\uC790",
      verb: "to have"
    },
    file: {
      unit: "\uBC14\uC774\uD2B8",
      verb: "to have"
    },
    array: {
      unit: "\uAC1C",
      verb: "to have"
    },
    set: {
      unit: "\uAC1C",
      verb: "to have"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\uC785\uB825",
    email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
    url: "URL",
    emoji: "\uC774\uBAA8\uC9C0",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
    date: "ISO \uB0A0\uC9DC",
    time: "ISO \uC2DC\uAC04",
    duration: "ISO \uAE30\uAC04",
    ipv4: "IPv4 \uC8FC\uC18C",
    ipv6: "IPv6 \uC8FC\uC18C",
    cidrv4: "IPv4 \uBC94\uC704",
    cidrv6: "IPv6 \uBC94\uC704",
    base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
    json_string: "JSON \uBB38\uC790\uC5F4",
    e164: "E.164 \uBC88\uD638",
    jwt: "JWT",
    template_literal: "\uC785\uB825"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType7(issue2.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
        const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
        const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "\uC694\uC18C";
        if (sizing) {
          return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
        }
        if (_issue.format === "ends_with") return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "includes") return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
        if (_issue.format === "regex") return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
        return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
      case "invalid_union":
        return `\uC798\uBABB\uB41C \uC785\uB825`;
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
      default:
        return `\uC798\uBABB\uB41C \uC785\uB825`;
    }
  };
}, "error");
function ko_default() {
  return {
    localeError: error23()
  };
}
__name(ko_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/lt.js
var parsedType5 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  return parsedTypeFromType(t2, data);
}, "parsedType");
var parsedTypeFromType = /* @__PURE__ */ __name((t2, data = void 0) => {
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
    }
    case "bigint": {
      return "sveikasis skai\u010Dius";
    }
    case "string": {
      return "eilut\u0117";
    }
    case "boolean": {
      return "login\u0117 reik\u0161m\u0117";
    }
    case "undefined":
    case "void": {
      return "neapibr\u0117\u017Eta reik\u0161m\u0117";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === void 0) return "ne\u017Einomas objektas";
      if (data === null) return "nulin\u0117 reik\u0161m\u0117";
      if (Array.isArray(data)) return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    //Zod types below
    case "null": {
      return "nulin\u0117 reik\u0161m\u0117";
    }
  }
  return t2;
}, "parsedTypeFromType");
var capitalizeFirstCharacter = /* @__PURE__ */ __name((text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
}, "capitalizeFirstCharacter");
function getUnitTypeFromNumber(number4) {
  const abs2 = Math.abs(number4);
  const last = abs2 % 10;
  const last2 = abs2 % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0) return "many";
  if (last === 1) return "one";
  return "few";
}
__name(getUnitTypeFromNumber, "getUnitTypeFromNumber");
var error24 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
          notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
          notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi b\u016Bti ne didesnis kaip",
          notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
        },
        bigger: {
          inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
          notInclusive: "turi b\u016Bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element\u0105",
        few: "elementus",
        many: "element\u0173"
      },
      verb: {
        smaller: {
          inclusive: "turi tur\u0117ti ne daugiau kaip",
          notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
        },
        bigger: {
          inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
          notInclusive: "turi tur\u0117ti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null) return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "\u012Fvestis",
    email: "el. pa\u0161to adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm\u0117",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 u\u017Ekoduota eilut\u0117",
    base64url: "base64url u\u017Ekoduota eilut\u0117",
    json_string: "JSON eilut\u0117",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "\u012Fvestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType5(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb) return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb) return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
        const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
        if (_issue.format === "regex") return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga \u012Fvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
      }
      default:
        return "Klaidinga \u012Fvestis";
    }
  };
}, "error");
function lt_default() {
  return {
    localeError: error24()
  };
}
__name(lt_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/mk.js
var error25 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u0437\u043D\u0430\u0446\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    },
    file: {
      unit: "\u0431\u0430\u0458\u0442\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    },
    array: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    },
    set: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043D\u0438\u0437\u0430";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u043D\u0435\u0441",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u045F\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
    date: "ISO \u0434\u0430\u0442\u0443\u043C",
    time: "ISO \u0432\u0440\u0435\u043C\u0435",
    duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
    cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
    cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
    base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
    json_string: "JSON \u043D\u0438\u0437\u0430",
    e164: "E.164 \u0431\u0440\u043E\u0458",
    jwt: "JWT",
    template_literal: "\u0432\u043D\u0435\u0441"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType7(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
      default:
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
    }
  };
}, "error");
function mk_default() {
  return {
    localeError: error25()
  };
}
__name(mk_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ms.js
var error26 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "aksara",
      verb: "mempunyai"
    },
    file: {
      unit: "bait",
      verb: "mempunyai"
    },
    array: {
      unit: "elemen",
      verb: "mempunyai"
    },
    set: {
      unit: "elemen",
      verb: "mempunyai"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes") return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex") return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
}, "error");
function ms_default() {
  return {
    localeError: error26()
  };
}
__name(ms_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/nl.js
var error27 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "tekens"
    },
    file: {
      unit: "bytes"
    },
    array: {
      unit: "elementen"
    },
    set: {
      unit: "elementen"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with") return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes") return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex") return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
}, "error");
function nl_default() {
  return {
    localeError: error27()
  };
}
__name(nl_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/no.js
var error28 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "tegn",
      verb: "\xE5 ha"
    },
    file: {
      unit: "bytes",
      verb: "\xE5 ha"
    },
    array: {
      unit: "elementer",
      verb: "\xE5 inneholde"
    },
    set: {
      unit: "elementer",
      verb: "\xE5 inneholde"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omr\xE5de",
    ipv6: "IPv6-omr\xE5de",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
        if (_issue.format === "regex") return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
}, "error");
function no_default() {
  return {
    localeError: error28()
  };
}
__name(no_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ota.js
var error29 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "harf",
      verb: "olmal\u0131d\u0131r"
    },
    file: {
      unit: "bayt",
      verb: "olmal\u0131d\u0131r"
    },
    array: {
      unit: "unsur",
      verb: "olmal\u0131d\u0131r"
    },
    set: {
      unit: "unsur",
      verb: "olmal\u0131d\u0131r"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "giren",
    email: "epostag\xE2h",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO heng\xE2m\u0131",
    date: "ISO tarihi",
    time: "ISO zaman\u0131",
    duration: "ISO m\xFCddeti",
    ipv4: "IPv4 ni\u015F\xE2n\u0131",
    ipv6: "IPv6 ni\u015F\xE2n\u0131",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-\u015Fifreli metin",
    base64url: "base64url-\u015Fifreli metin",
    json_string: "JSON metin",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
      // return `FÃ¢sit giren: umulan ${issue.expected}, alÄ±nan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
        return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
        }
        return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
        if (_issue.format === "ends_with") return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes") return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
        if (_issue.format === "regex") return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
        return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return `K\u0131ymet tan\u0131namad\u0131.`;
    }
  };
}, "error");
function ota_default() {
  return {
    localeError: error29()
  };
}
__name(ota_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ps.js
var error30 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A"
    },
    file: {
      unit: "\u0628\u0627\u06CC\u067C\u0633",
      verb: "\u0648\u0644\u0631\u064A"
    },
    array: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A"
    },
    set: {
      unit: "\u062A\u0648\u06A9\u064A",
      verb: "\u0648\u0644\u0631\u064A"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0627\u0631\u06D0";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0648\u0631\u0648\u062F\u064A",
    email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
    date: "\u0646\u06D0\u067C\u0647",
    time: "\u0648\u062E\u062A",
    duration: "\u0645\u0648\u062F\u0647",
    ipv4: "\u062F IPv4 \u067E\u062A\u0647",
    ipv6: "\u062F IPv6 \u067E\u062A\u0647",
    cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
    cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
    base64: "base64-encoded \u0645\u062A\u0646",
    base64url: "base64url-encoded \u0645\u062A\u0646",
    json_string: "JSON \u0645\u062A\u0646",
    e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
    jwt: "JWT",
    template_literal: "\u0648\u0631\u0648\u062F\u064A"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType7(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
        }
        return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
        }
        return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
        }
        if (_issue.format === "ends_with") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
        }
        if (_issue.format === "includes") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
        }
        if (_issue.format === "regex") {
          return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
      }
      case "not_multiple_of":
        return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
      case "unrecognized_keys":
        return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      case "invalid_union":
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
      case "invalid_element":
        return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
      default:
        return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
    }
  };
}, "error");
function ps_default() {
  return {
    localeError: error30()
  };
}
__name(ps_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/pl.js
var error31 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "znak\xF3w",
      verb: "mie\u0107"
    },
    file: {
      unit: "bajt\xF3w",
      verb: "mie\u0107"
    },
    array: {
      unit: "element\xF3w",
      verb: "mie\u0107"
    },
    set: {
      unit: "element\xF3w",
      verb: "mie\u0107"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "wyra\u017Cenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
    base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
    json_string: "ci\u0105g znak\xF3w w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wej\u015Bcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
        }
        return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
        if (_issue.format === "regex") return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
        return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
      default:
        return `Nieprawid\u0142owe dane wej\u015Bciowe`;
    }
  };
}, "error");
function pl_default() {
  return {
    localeError: error31()
  };
}
__name(pl_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/pt.js
var error32 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "caracteres",
      verb: "ter"
    },
    file: {
      unit: "bytes",
      verb: "ter"
    },
    array: {
      unit: "itens",
      verb: "ter"
    },
    set: {
      unit: "itens",
      verb: "ter"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\xFAmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "padr\xE3o",
    email: "endere\xE7o de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "dura\xE7\xE3o ISO",
    ipv4: "endere\xE7o IPv4",
    ipv6: "endere\xE7o IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "n\xFAmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex") return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${issue2.origin}`;
      default:
        return `Campo inv\xE1lido`;
    }
  };
}, "error");
function pt_default() {
  return {
    localeError: error32()
  };
}
__name(pt_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
__name(getRussianPlural, "getRussianPlural");
var error33 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
      },
      verb: "\u0438\u043C\u0435\u0442\u044C"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u0432\u043E\u0434",
    email: "email \u0430\u0434\u0440\u0435\u0441",
    url: "URL",
    emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
    date: "ISO \u0434\u0430\u0442\u0430",
    time: "ISO \u0432\u0440\u0435\u043C\u044F",
    duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
    ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
    ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
    cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
    base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
    base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
    json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0432\u043E\u0434"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
    }
  };
}, "error");
function ru_default() {
  return {
    localeError: error33()
  };
}
__name(ru_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/sl.js
var error34 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "znakov",
      verb: "imeti"
    },
    file: {
      unit: "bajtov",
      verb: "imeti"
    },
    array: {
      unit: "elementov",
      verb: "imeti"
    },
    set: {
      unit: "elementov",
      verb: "imeti"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "vnos",
    email: "e-po\u0161tni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in \u010Das",
    date: "ISO datum",
    time: "ISO \u010Das",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 \u0161tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex") return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
}, "error");
function sl_default() {
  return {
    localeError: error34()
  };
}
__name(sl_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/sv.js
var error35 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "tecken",
      verb: "att ha"
    },
    file: {
      unit: "bytes",
      verb: "att ha"
    },
    array: {
      unit: "objekt",
      verb: "att inneh\xE5lla"
    },
    set: {
      unit: "objekt",
      verb: "att inneh\xE5lla"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "regulj\xE4rt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad str\xE4ng",
    base64url: "base64url-kodad str\xE4ng",
    json_string: "JSON-str\xE4ng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
        if (_issue.format === "regex") return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
}, "error");
function sv_default() {
  return {
    localeError: error35()
  };
}
__name(sv_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ta.js
var error36 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    },
    file: {
      unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    },
    array: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    },
    set: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0B85\u0BA3\u0BBF";
        }
        if (data === null) {
          return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
    email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
    time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
    duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
    ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
    cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
    base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
    json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
    e164: "E.164 \u0B8E\u0BA3\u0BCD",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        }
        return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "ends_with") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "includes") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        if (_issue.format === "regex") return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
    }
  };
}, "error");
function ta_default() {
  return {
    localeError: error36()
  };
}
__name(ta_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/th.js
var error37 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    },
    file: {
      unit: "\u0E44\u0E1A\u0E15\u0E4C",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    },
    array: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    },
    set: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
        }
        if (data === null) {
          return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
    url: "URL",
    emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
    time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
    ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
    ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
    cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
    cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
    base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
    base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
    json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
    e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
    jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
    template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
        return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with") return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
        if (_issue.format === "regex") return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
        return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
      default:
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
    }
  };
}, "error");
function th_default() {
  return {
    localeError: error37()
  };
}
__name(th_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/tr.js
var parsedType6 = /* @__PURE__ */ __name((data) => {
  const t2 = typeof data;
  switch (t2) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t2;
}, "parsedType");
var error38 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "karakter",
      verb: "olmal\u0131"
    },
    file: {
      unit: "bayt",
      verb: "olmal\u0131"
    },
    array: {
      unit: "\xF6\u011Fe",
      verb: "olmal\u0131"
    },
    set: {
      unit: "\xF6\u011Fe",
      verb: "olmal\u0131"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO s\xFCre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral\u0131\u011F\u0131",
    cidrv6: "IPv6 aral\u0131\u011F\u0131",
    base64: "base64 ile \u015Fifrelenmi\u015F metin",
    base64url: "base64url ile \u015Fifrelenmi\u015F metin",
    json_string: "JSON dizesi",
    e164: "E.164 say\u0131s\u0131",
    jwt: "JWT",
    template_literal: "\u015Eablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
        return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
        if (_issue.format === "ends_with") return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes") return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
        if (_issue.format === "regex") return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
        return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
      case "invalid_union":
        return "Ge\xE7ersiz de\u011Fer";
      case "invalid_element":
        return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
      default:
        return `Ge\xE7ersiz de\u011Fer`;
    }
  };
}, "error");
function tr_default() {
  return {
    localeError: error38()
  };
}
__name(tr_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/uk.js
var error39 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    },
    file: {
      unit: "\u0431\u0430\u0439\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    },
    array: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    },
    set: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u043C\u0430\u0441\u0438\u0432";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
    url: "URL",
    emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
    date: "\u0434\u0430\u0442\u0430 ISO",
    time: "\u0447\u0430\u0441 ISO",
    duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
    ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
    ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
    cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
    cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
    base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
    base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
    json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
    e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
    jwt: "JWT",
    template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType7(issue2.input)}`;
      // return `ÐÐµÐ¿ÑÐ°Ð²Ð¸Ð»ÑÐ½Ñ Ð²ÑÑÐ´Ð½Ñ Ð´Ð°Ð½Ñ: Ð¾ÑÑÐºÑÑÑÑÑÑ ${issue.expected}, Ð¾ÑÑÐ¸Ð¼Ð°Ð½Ð¾ ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
      default:
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
    }
  };
}, "error");
function uk_default() {
  return {
    localeError: error39()
  };
}
__name(uk_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
__name(ua_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/ur.js
var error40 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u062D\u0631\u0648\u0641",
      verb: "\u06C1\u0648\u0646\u0627"
    },
    file: {
      unit: "\u0628\u0627\u0626\u0679\u0633",
      verb: "\u06C1\u0648\u0646\u0627"
    },
    array: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627"
    },
    set: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u0622\u0631\u06D2";
        }
        if (data === null) {
          return "\u0646\u0644";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0627\u0646 \u067E\u0679",
    email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
    emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
    uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
    uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
    nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
    ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
    xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
    ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
    datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
    date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
    time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
    duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
    ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
    cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
    cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
    base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
    json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
    e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
    jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
    template_literal: "\u0627\u0646 \u067E\u0679"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType7(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
        return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
        }
        return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        }
        if (_issue.format === "ends_with") return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "includes") return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        if (_issue.format === "regex") return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
        return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
      case "invalid_key":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
    }
  };
}, "error");
function ur_default() {
  return {
    localeError: error40()
  };
}
__name(ur_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/vi.js
var error41 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "k\xFD t\u1EF1",
      verb: "c\xF3"
    },
    file: {
      unit: "byte",
      verb: "c\xF3"
    },
    array: {
      unit: "ph\u1EA7n t\u1EED",
      verb: "c\xF3"
    },
    set: {
      unit: "ph\u1EA7n t\u1EED",
      verb: "c\xF3"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s\u1ED1";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "m\u1EA3ng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u0111\u1EA7u v\xE0o",
    email: "\u0111\u1ECBa ch\u1EC9 email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ng\xE0y gi\u1EDD ISO",
    date: "ng\xE0y ISO",
    time: "gi\u1EDD ISO",
    duration: "kho\u1EA3ng th\u1EDDi gian ISO",
    ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
    ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
    cidrv4: "d\u1EA3i IPv4",
    cidrv6: "d\u1EA3i IPv6",
    base64: "chu\u1ED7i m\xE3 h\xF3a base64",
    base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
    json_string: "chu\u1ED7i JSON",
    e164: "s\u1ED1 E.164",
    jwt: "JWT",
    template_literal: "\u0111\u1EA7u v\xE0o"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
        return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
        return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
        if (_issue.format === "includes") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
        if (_issue.format === "regex") return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
      default:
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
    }
  };
}, "error");
function vi_default() {
  return {
    localeError: error41()
  };
}
__name(vi_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/zh-CN.js
var error42 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u5B57\u7B26",
      verb: "\u5305\u542B"
    },
    file: {
      unit: "\u5B57\u8282",
      verb: "\u5305\u542B"
    },
    array: {
      unit: "\u9879",
      verb: "\u5305\u542B"
    },
    set: {
      unit: "\u9879",
      verb: "\u5305\u542B"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "\u6570\u7EC4";
        }
        if (data === null) {
          return "\u7A7A\u503C(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u8F93\u5165",
    email: "\u7535\u5B50\u90AE\u4EF6",
    url: "URL",
    emoji: "\u8868\u60C5\u7B26\u53F7",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO\u65E5\u671F\u65F6\u95F4",
    date: "ISO\u65E5\u671F",
    time: "ISO\u65F6\u95F4",
    duration: "ISO\u65F6\u957F",
    ipv4: "IPv4\u5730\u5740",
    ipv6: "IPv6\u5730\u5740",
    cidrv4: "IPv4\u7F51\u6BB5",
    cidrv6: "IPv6\u7F51\u6BB5",
    base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
    base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
    json_string: "JSON\u5B57\u7B26\u4E32",
    e164: "E.164\u53F7\u7801",
    jwt: "JWT",
    template_literal: "\u8F93\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
        return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
        return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
        if (_issue.format === "ends_with") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
        if (_issue.format === "includes") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
        return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return `\u65E0\u6548\u8F93\u5165`;
    }
  };
}, "error");
function zh_CN_default() {
  return {
    localeError: error42()
  };
}
__name(zh_CN_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/zh-TW.js
var error43 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\u5B57\u5143",
      verb: "\u64C1\u6709"
    },
    file: {
      unit: "\u4F4D\u5143\u7D44",
      verb: "\u64C1\u6709"
    },
    array: {
      unit: "\u9805\u76EE",
      verb: "\u64C1\u6709"
    },
    set: {
      unit: "\u9805\u76EE",
      verb: "\u64C1\u6709"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u8F38\u5165",
    email: "\u90F5\u4EF6\u5730\u5740",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO \u65E5\u671F\u6642\u9593",
    date: "ISO \u65E5\u671F",
    time: "ISO \u6642\u9593",
    duration: "ISO \u671F\u9593",
    ipv4: "IPv4 \u4F4D\u5740",
    ipv6: "IPv6 \u4F4D\u5740",
    cidrv4: "IPv4 \u7BC4\u570D",
    cidrv6: "IPv6 \u7BC4\u570D",
    base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
    base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
    json_string: "JSON \u5B57\u4E32",
    e164: "E.164 \u6578\u503C",
    jwt: "JWT",
    template_literal: "\u8F38\u5165"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
        return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
        return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
        }
        if (_issue.format === "ends_with") return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
        if (_issue.format === "includes") return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
        return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
      case "invalid_key":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
    }
  };
}, "error");
function zh_TW_default() {
  return {
    localeError: error43()
  };
}
__name(zh_TW_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/yo.js
var error44 = /* @__PURE__ */ __name(() => {
  const Sizable = {
    string: {
      unit: "\xE0mi",
      verb: "n\xED"
    },
    file: {
      unit: "bytes",
      verb: "n\xED"
    },
    array: {
      unit: "nkan",
      verb: "n\xED"
    },
    set: {
      unit: "nkan",
      verb: "n\xED"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  __name(getSizing, "getSizing");
  const parsedType7 = /* @__PURE__ */ __name((data) => {
    const t2 = typeof data;
    switch (t2) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop\u1ECD";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t2;
  }, "parsedType");
  const Nouns = {
    regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
    email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "\xE0k\xF3k\xF2 ISO",
    date: "\u1ECDj\u1ECD\u0301 ISO",
    time: "\xE0k\xF3k\xF2 ISO",
    duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
    ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
    ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
    cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
    cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
    base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
    base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
    json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
    e164: "n\u1ECD\u0301mb\xE0 E.164",
    jwt: "JWT",
    template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1) return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
        if (_issue.format === "ends_with") return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
        if (_issue.format === "includes") return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
        if (_issue.format === "regex") return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
        return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      case "invalid_union":
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
      case "invalid_element":
        return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
      default:
        return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
    }
  };
}, "error");
function yo_default() {
  return {
    localeError: error44()
  };
}
__name(yo_default, "default");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  static {
    __name(this, "$ZodRegistry");
  }
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = {
        ...this.get(p2) ?? {}
      };
      delete pm.id;
      const f2 = {
        ...pm,
        ...this._map.get(schema)
      };
      return Object.keys(f2).length ? f2 : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
__name(registry, "registry");
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
__name(_string, "_string");
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedString, "_coercedString");
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_email, "_email");
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_guid, "_guid");
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_uuid, "_uuid");
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
__name(_uuidv4, "_uuidv4");
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
__name(_uuidv6, "_uuidv6");
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
__name(_uuidv7, "_uuidv7");
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_url, "_url");
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_emoji2, "_emoji");
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_nanoid, "_nanoid");
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid, "_cuid");
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cuid2, "_cuid2");
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ulid, "_ulid");
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_xid, "_xid");
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ksuid, "_ksuid");
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv4, "_ipv4");
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_ipv6, "_ipv6");
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv4, "_cidrv4");
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_cidrv6, "_cidrv6");
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64, "_base64");
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_base64url, "_base64url");
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_e164, "_e164");
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
__name(_jwt, "_jwt");
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoDateTime, "_isoDateTime");
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDate, "_isoDate");
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
__name(_isoTime, "_isoTime");
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
__name(_isoDuration, "_isoDuration");
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_number, "_number");
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
__name(_coercedNumber, "_coercedNumber");
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
__name(_int, "_int");
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
__name(_float32, "_float32");
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
__name(_float64, "_float64");
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
__name(_int32, "_int32");
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
__name(_uint32, "_uint32");
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
__name(_boolean, "_boolean");
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBoolean, "_coercedBoolean");
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
__name(_bigint, "_bigint");
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedBigint, "_coercedBigint");
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
__name(_int64, "_int64");
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
__name(_uint64, "_uint64");
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
__name(_symbol, "_symbol");
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
__name(_undefined2, "_undefined");
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
__name(_null2, "_null");
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
__name(_any, "_any");
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
__name(_unknown, "_unknown");
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
__name(_never, "_never");
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
__name(_void, "_void");
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
__name(_date, "_date");
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
__name(_coercedDate, "_coercedDate");
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
__name(_nan, "_nan");
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
__name(_lt, "_lt");
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
__name(_lte, "_lte");
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
__name(_gt, "_gt");
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
__name(_gte, "_gte");
function _positive(params) {
  return _gt(0, params);
}
__name(_positive, "_positive");
function _negative(params) {
  return _lt(0, params);
}
__name(_negative, "_negative");
function _nonpositive(params) {
  return _lte(0, params);
}
__name(_nonpositive, "_nonpositive");
function _nonnegative(params) {
  return _gte(0, params);
}
__name(_nonnegative, "_nonnegative");
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
__name(_multipleOf, "_multipleOf");
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
__name(_maxSize, "_maxSize");
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minSize, "_minSize");
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
__name(_size, "_size");
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
__name(_maxLength, "_maxLength");
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
__name(_minLength, "_minLength");
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
__name(_length, "_length");
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
__name(_regex, "_regex");
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
__name(_lowercase, "_lowercase");
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
__name(_uppercase, "_uppercase");
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
__name(_includes, "_includes");
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
__name(_startsWith, "_startsWith");
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
__name(_endsWith, "_endsWith");
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
__name(_property, "_property");
function _mime(types2, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types2,
    ...normalizeParams(params)
  });
}
__name(_mime, "_mime");
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
__name(_overwrite, "_overwrite");
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
__name(_normalize, "_normalize");
function _trim() {
  return _overwrite((input) => input.trim());
}
__name(_trim, "_trim");
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
__name(_toLowerCase, "_toLowerCase");
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
__name(_toUpperCase, "_toUpperCase");
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
__name(_array, "_array");
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
__name(_union, "_union");
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
__name(_discriminatedUnion, "_discriminatedUnion");
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
__name(_intersection, "_intersection");
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
__name(_tuple, "_tuple");
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_record, "_record");
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
__name(_map, "_map");
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
__name(_set, "_set");
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [
    v2,
    v2
  ])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
__name(_enum, "_enum");
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
__name(_nativeEnum, "_nativeEnum");
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [
      value
    ],
    ...normalizeParams(params)
  });
}
__name(_literal, "_literal");
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
__name(_file, "_file");
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
__name(_transform, "_transform");
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
__name(_optional, "_optional");
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
__name(_nullable, "_nullable");
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
__name(_default, "_default");
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
__name(_nonoptional, "_nonoptional");
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
__name(_success, "_success");
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch, "_catch");
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
__name(_pipe, "_pipe");
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
__name(_readonly, "_readonly");
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
__name(_templateLiteral, "_templateLiteral");
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
__name(_lazy, "_lazy");
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
__name(_promise, "_promise");
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
__name(_custom, "_custom");
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
__name(_refine, "_refine");
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
__name(_superRefine, "_superRefine");
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
__name(_check, "_check");
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? [
    "true",
    "1",
    "yes",
    "on",
    "y",
    "enabled"
  ];
  let falsyArray = params.falsy ?? [
    "false",
    "0",
    "no",
    "off",
    "n",
    "disabled"
  ];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
    falsyArray = falsyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({
    type: "string",
    error: params.error
  });
  const booleanSchema = new _Boolean({
    type: "boolean",
    error: params.error
  });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: /* @__PURE__ */ __name((input, payload) => {
      let data = input;
      if (params.case !== "sensitive") data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [
            ...truthySet,
            ...falsySet
          ],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    }, "transform"),
    reverseTransform: /* @__PURE__ */ __name((input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }, "reverseTransform"),
    error: params.error
  });
  return codec2;
}
__name(_stringbool, "_stringbool");
function _stringFormat(Class2, format2, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format: format2,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
__name(_stringFormat, "_stringFormat");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  static {
    __name(this, "JSONSchemaGenerator");
  }
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = {
    path: [],
    schemaPath: []
  }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = {
      schema: {},
      count: 1,
      cycle: void 0,
      path: _params.path
    };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [
          ..._params.schemaPath,
          schema
        ],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format: format2, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number") json2.minLength = minimum;
            if (typeof maximum === "number") json2.maxLength = maximum;
            if (format2) {
              json2.format = formatMap[format2] ?? format2;
              if (json2.format === "") delete json2.format;
            }
            if (contentEncoding) json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [
                ...patterns
              ];
              if (regexes.length === 1) json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? {
                      type: "string"
                    } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format: format2, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format2 === "string" && format2.includes("int")) json2.type = "integer";
            else json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum) delete json2.minimum;
                else delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum) delete json2.maximum;
                else delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number") json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [
                null
              ];
            } else _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number") json2.minItems = minimum;
            if (typeof maximum === "number") json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, {
              ...params,
              path: [
                ...params.path,
                "items"
              ]
            });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [
                  ...params.path,
                  "properties",
                  key
                ]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([
              ...allKeys
            ].filter((key) => {
              const v2 = def.shape[key]._zod;
              if (this.io === "input") {
                return v2.optin === void 0;
              } else {
                return v2.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output") json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [
                  ...params.path,
                  "additionalProperties"
                ]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const options = def.options.map((x2, i2) => this.process(x2, {
              ...params,
              path: [
                ...params.path,
                "anyOf",
                i2
              ]
            }));
            json2.anyOf = options;
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a2 = this.process(def.left, {
              ...params,
              path: [
                ...params.path,
                "allOf",
                0
              ]
            });
            const b2 = this.process(def.right, {
              ...params,
              path: [
                ...params.path,
                "allOf",
                1
              ]
            });
            const isSimpleIntersection = /* @__PURE__ */ __name((val) => "allOf" in val && Object.keys(val).length === 1, "isSimpleIntersection");
            const allOf = [
              ...isSimpleIntersection(a2) ? a2.allOf : [
                a2
              ],
              ...isSimpleIntersection(b2) ? b2.allOf : [
                b2
              ]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x2, i2) => this.process(x2, {
              ...params,
              path: [
                ...params.path,
                prefixPath,
                i2
              ]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [
                ...params.path,
                restPath,
                ...this.target === "openapi-3.0" ? [
                  def.items.length
                ] : []
              ]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number") json2.minItems = minimum;
            if (typeof maximum === "number") json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [
                  ...params.path,
                  "propertyNames"
                ]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [
                ...params.path,
                "additionalProperties"
              ]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v2) => typeof v2 === "number")) json2.type = "number";
            if (values.every((v2) => typeof v2 === "string")) json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [
                  val
                ];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v2) => typeof v2 === "number")) json2.type = "number";
              if (vals.every((v2) => typeof v2 === "string")) json2.type = "string";
              if (vals.every((v2) => typeof v2 === "boolean")) json2.type = "string";
              if (vals.every((v2) => v2 === null)) json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0) file2.minLength = minimum;
            if (maximum !== void 0) file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m2) => {
                  const mFile = {
                    ...file2,
                    contentMediaType: m2
                  };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [
                inner,
                {
                  type: "null"
                }
              ];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input") _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern) throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta) Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault) (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root) throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = /* @__PURE__ */ __name((entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return {
            ref: uriGenerator(externalId)
          };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return {
          defId: id,
          ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}`
        };
      }
      if (entry[1] === root) {
        return {
          ref: "#"
        };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return {
        defId,
        ref: defUriPrefix + defId
      };
    }, "makeURI");
    const extractToDef = /* @__PURE__ */ __name((entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = {
        ...seen.schema
      };
      if (defId) seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    }, "extractToDef");
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = /* @__PURE__ */ __name((zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = {
        ...schema2
      };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent) this.override({
        zodSchema,
        jsonSchema: schema2,
        path: seen.path ?? []
      });
    }, "flattenRef");
    for (const entry of [
      ...this.seen.entries()
    ].reverse()) {
      flattenRef(entry[0], {
        target: this.target
      });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id) throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_2, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return {
      schemas
    };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
__name(toJSONSchema, "toJSONSchema");
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? {
    seen: /* @__PURE__ */ new Set()
  };
  if (ctx.seen.has(_schema)) return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx)) return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx)) return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx)) return true;
      }
      if (def.rest && isTransforming(def.rest, ctx)) return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
__name(isTransforming, "isTransforming");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
__name(datetime2, "datetime");
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
__name(date2, "date");
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
__name(time2, "time");
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
__name(duration2, "duration");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/errors.js
var initializer2 = /* @__PURE__ */ __name((inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: /* @__PURE__ */ __name((mapper) => formatError(inst, mapper), "value")
    },
    flatten: {
      value: /* @__PURE__ */ __name((mapper) => flattenError(inst, mapper), "value")
    },
    addIssue: {
      value: /* @__PURE__ */ __name((issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }, "value")
    },
    addIssues: {
      value: /* @__PURE__ */ __name((issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }, "value")
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
}, "initializer");
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", {
    value: def
  });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? {
          _zod: {
            check: ch,
            def: {
              check: "custom"
            },
            onattach: []
          }
        } : ch)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, {
    callee: inst.parse
  });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, {
    callee: inst.parseAsync
  });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([
    inst,
    arg
  ]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, {
      description
    });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
__name(string2, "string");
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
__name(email2, "email");
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
__name(guid2, "guid");
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
__name(uuid2, "uuid");
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
__name(uuidv4, "uuidv4");
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
__name(uuidv6, "uuidv6");
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
__name(uuidv7, "uuidv7");
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
__name(url, "url");
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
__name(httpUrl, "httpUrl");
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
__name(emoji2, "emoji");
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
__name(nanoid2, "nanoid");
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
__name(cuid3, "cuid");
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
__name(cuid22, "cuid2");
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
__name(ulid2, "ulid");
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
__name(xid2, "xid");
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
__name(ksuid2, "ksuid");
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
__name(ipv42, "ipv4");
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
__name(ipv62, "ipv6");
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
__name(cidrv42, "cidrv4");
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
__name(cidrv62, "cidrv6");
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
__name(base642, "base64");
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
__name(base64url2, "base64url");
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
__name(e1642, "e164");
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
__name(jwt, "jwt");
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format2, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format2, fnOrRegex, _params);
}
__name(stringFormat, "stringFormat");
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
__name(hostname2, "hostname");
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
__name(hex2, "hex");
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format2 = `${alg}_${enc}`;
  const regex = regexes_exports[format2];
  if (!regex) throw new Error(`Unrecognized hash format: ${format2}`);
  return _stringFormat(ZodCustomStringFormat, format2, regex, params);
}
__name(hash, "hash");
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
__name(number2, "number");
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
__name(int, "int");
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
__name(float32, "float32");
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
__name(float64, "float64");
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
__name(int32, "int32");
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
__name(uint32, "uint32");
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
__name(boolean2, "boolean");
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
__name(bigint2, "bigint");
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
__name(int64, "int64");
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
__name(uint64, "uint64");
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
__name(symbol, "symbol");
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
__name(_undefined3, "_undefined");
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
__name(_null3, "_null");
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
__name(any, "any");
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
__name(unknown, "unknown");
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
__name(never, "never");
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
__name(_void2, "_void");
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
__name(date3, "date");
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
__name(array, "array");
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
__name(keyof, "keyof");
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({
    ...inst._zod.def,
    catchall
  });
  inst.passthrough = () => inst.clone({
    ...inst._zod.def,
    catchall: unknown()
  });
  inst.loose = () => inst.clone({
    ...inst._zod.def,
    catchall: unknown()
  });
  inst.strict = () => inst.clone({
    ...inst._zod.def,
    catchall: never()
  });
  inst.strip = () => inst.clone({
    ...inst._zod.def,
    catchall: void 0
  });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
__name(object, "object");
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
__name(strictObject, "strictObject");
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
__name(looseObject, "looseObject");
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
__name(union, "union");
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
__name(discriminatedUnion, "discriminatedUnion");
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
__name(intersection, "intersection");
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
__name(tuple, "tuple");
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(record, "record");
function partialRecord(keyType, valueType, params) {
  const k2 = clone(keyType);
  k2._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k2,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(partialRecord, "partialRecord");
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(map, "map");
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
__name(set, "set");
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = {
      ...def.entries
    };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [
    v2,
    v2
  ])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
__name(_enum2, "_enum");
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
__name(nativeEnum, "nativeEnum");
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [
      value
    ],
    ...util_exports.normalizeParams(params)
  });
}
__name(literal, "literal");
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types2, params) => inst.check(_mime(Array.isArray(types2) ? types2 : [
    types2
  ], params));
});
function file(params) {
  return _file(ZodFile, params);
}
__name(file, "file");
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
__name(transform, "transform");
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
__name(optional, "optional");
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
__name(nullable, "nullable");
function nullish2(innerType) {
  return optional(nullable(innerType));
}
__name(nullish2, "nullish");
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
__name(_default2, "_default");
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
__name(prefault, "prefault");
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
__name(nonoptional, "nonoptional");
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
__name(success, "success");
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
__name(_catch2, "_catch");
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
__name(nan, "nan");
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
__name(pipe, "pipe");
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
__name(codec, "codec");
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
__name(readonly, "readonly");
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
__name(templateLiteral, "templateLiteral");
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
__name(lazy, "lazy");
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
__name(promise, "promise");
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
__name(_function, "_function");
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
__name(check, "check");
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
__name(custom, "custom");
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
__name(refine, "refine");
function superRefine(fn) {
  return _superRefine(fn);
}
__name(superRefine, "superRefine");
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: /* @__PURE__ */ __name((data) => data instanceof cls, "fn"),
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
__name(_instanceof, "_instanceof");
var stringbool = /* @__PURE__ */ __name((...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args), "stringbool");
function json(params) {
  const jsonSchema = lazy(() => {
    return union([
      string2(params),
      number2(),
      boolean2(),
      _null3(),
      array(jsonSchema),
      record(string2(), jsonSchema)
    ]);
  });
  return jsonSchema;
}
__name(json, "json");
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
__name(preprocess, "preprocess");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config2({
    customError: map2
  });
}
__name(setErrorMap, "setErrorMap");
function getErrorMap() {
  return config2().customError;
}
__name(getErrorMap, "getErrorMap");
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
__name(string3, "string");
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
__name(number3, "number");
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
__name(boolean3, "boolean");
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
__name(bigint3, "bigint");
function date4(params) {
  return _coercedDate(ZodDate, params);
}
__name(date4, "date");

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/external.js
config2(en_default());

// node_modules/.pnpm/zod@4.1.11/node_modules/zod/index.js
var zod_default = external_exports;

// node_modules/.pnpm/@workflow+world@4.0.1-beta.2_zod@4.1.11/node_modules/@workflow/world/dist/events.js
var EventTypeSchema = external_exports.enum([
  "step_completed",
  "step_failed",
  "step_retrying",
  "step_started",
  "hook_created",
  "hook_received",
  "hook_disposed",
  "workflow_completed",
  "workflow_failed",
  "workflow_started"
]);
var BaseEventSchema = external_exports.object({
  eventType: EventTypeSchema,
  correlationId: external_exports.string().optional()
});
var StepCompletedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("step_completed"),
  correlationId: external_exports.string(),
  eventData: external_exports.object({
    result: external_exports.any()
  })
});
var StepFailedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("step_failed"),
  correlationId: external_exports.string(),
  eventData: external_exports.object({
    error: external_exports.any(),
    stack: external_exports.string().optional(),
    fatal: external_exports.boolean().optional()
  })
});
var StepRetryingEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("step_retrying"),
  correlationId: external_exports.string(),
  eventData: external_exports.object({
    attempt: external_exports.number().min(1)
  })
});
var StepStartedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("step_started"),
  correlationId: external_exports.string()
});
var HookCreatedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("hook_created"),
  correlationId: external_exports.string()
});
var HookReceivedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("hook_received"),
  correlationId: external_exports.string(),
  eventData: external_exports.object({
    payload: external_exports.any()
  })
});
var HookDisposedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("hook_disposed"),
  correlationId: external_exports.string()
});
var WorkflowCompletedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("workflow_completed")
});
var WorkflowFailedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("workflow_failed"),
  eventData: external_exports.object({
    error: external_exports.any()
  })
});
var WorkflowStartedEventSchema = BaseEventSchema.extend({
  eventType: external_exports.literal("workflow_started")
});
var CreateEventSchema = external_exports.discriminatedUnion("eventType", [
  StepCompletedEventSchema,
  StepFailedEventSchema,
  StepRetryingEventSchema,
  StepStartedEventSchema,
  HookCreatedEventSchema,
  HookReceivedEventSchema,
  HookDisposedEventSchema,
  WorkflowCompletedEventSchema,
  WorkflowFailedEventSchema,
  WorkflowStartedEventSchema
]);
var EventSchema = CreateEventSchema.and(external_exports.object({
  runId: external_exports.string(),
  eventId: external_exports.string(),
  createdAt: external_exports.coerce.date()
}));

// node_modules/.pnpm/@workflow+world@4.0.1-beta.2_zod@4.1.11/node_modules/@workflow/world/dist/shared.js
var zodJsonSchema = external_exports.lazy(() => {
  return external_exports.union([
    external_exports.string(),
    external_exports.number(),
    external_exports.boolean(),
    external_exports.null(),
    external_exports.array(zodJsonSchema),
    external_exports.record(external_exports.string(), zodJsonSchema)
  ]);
});
var PaginatedResponseSchema = /* @__PURE__ */ __name((dataSchema) => external_exports.object({
  data: external_exports.array(dataSchema),
  cursor: external_exports.string().nullable(),
  hasMore: external_exports.boolean()
}), "PaginatedResponseSchema");

// node_modules/.pnpm/@workflow+world@4.0.1-beta.2_zod@4.1.11/node_modules/@workflow/world/dist/hooks.js
var HookSchema = external_exports.object({
  runId: external_exports.string(),
  hookId: external_exports.string(),
  token: external_exports.string(),
  ownerId: external_exports.string(),
  projectId: external_exports.string(),
  environment: external_exports.string(),
  metadata: zodJsonSchema.optional(),
  createdAt: external_exports.coerce.date()
});

// node_modules/.pnpm/@workflow+world@4.0.1-beta.2_zod@4.1.11/node_modules/@workflow/world/dist/queue.js
var QueuePrefix = external_exports.union([
  external_exports.literal("__wkf_step_"),
  external_exports.literal("__wkf_workflow_")
]);
var ValidQueueName = external_exports.templateLiteral([
  QueuePrefix,
  external_exports.string()
]);
var MessageId = external_exports.string().brand().describe("A stored queue message ID");
var TraceCarrierSchema = external_exports.record(external_exports.string(), external_exports.string());
var WorkflowInvokePayloadSchema = external_exports.object({
  runId: external_exports.string(),
  traceCarrier: TraceCarrierSchema.optional()
});
var StepInvokePayloadSchema = external_exports.object({
  workflowName: external_exports.string(),
  workflowRunId: external_exports.string(),
  workflowStartedAt: external_exports.number(),
  stepId: external_exports.string(),
  traceCarrier: TraceCarrierSchema.optional()
});
var QueuePayloadSchema = external_exports.union([
  WorkflowInvokePayloadSchema,
  StepInvokePayloadSchema
]);

// node_modules/.pnpm/@workflow+world@4.0.1-beta.2_zod@4.1.11/node_modules/@workflow/world/dist/runs.js
var WorkflowRunStatusSchema = external_exports.enum([
  "pending",
  "running",
  "completed",
  "failed",
  "paused",
  "cancelled"
]);
var WorkflowRunSchema = external_exports.object({
  runId: external_exports.string(),
  deploymentId: external_exports.string(),
  status: WorkflowRunStatusSchema,
  workflowName: external_exports.string(),
  executionContext: external_exports.record(external_exports.string(), external_exports.any()).optional(),
  input: external_exports.array(external_exports.any()),
  output: external_exports.any().optional(),
  error: external_exports.string().optional(),
  errorCode: external_exports.string().optional(),
  startedAt: external_exports.coerce.date().optional(),
  completedAt: external_exports.coerce.date().optional(),
  createdAt: external_exports.coerce.date(),
  updatedAt: external_exports.coerce.date()
});

// node_modules/.pnpm/@workflow+world@4.0.1-beta.2_zod@4.1.11/node_modules/@workflow/world/dist/steps.js
var StepStatusSchema = external_exports.enum([
  "pending",
  "running",
  "completed",
  "failed",
  "cancelled"
]);
var StepSchema = external_exports.object({
  runId: external_exports.string(),
  stepId: external_exports.string(),
  stepName: external_exports.string(),
  status: StepStatusSchema,
  input: external_exports.array(external_exports.any()),
  output: external_exports.any().optional(),
  error: external_exports.string().optional(),
  errorCode: external_exports.string().optional(),
  attempt: external_exports.number(),
  startedAt: external_exports.coerce.date().optional(),
  completedAt: external_exports.coerce.date().optional(),
  createdAt: external_exports.coerce.date(),
  updatedAt: external_exports.coerce.date()
});

// node_modules/.pnpm/ulid@3.0.1/node_modules/ulid/dist/node/index.js
var import_node_crypto = __toESM(require("node:crypto"), 1);
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = 32;
var RANDOM_LEN = 16;
var TIME_LEN = 10;
var TIME_MAX = 281474976710655;
var ULIDErrorCode;
(function(ULIDErrorCode2) {
  ULIDErrorCode2["Base32IncorrectEncoding"] = "B32_ENC_INVALID";
  ULIDErrorCode2["DecodeTimeInvalidCharacter"] = "DEC_TIME_CHAR";
  ULIDErrorCode2["DecodeTimeValueMalformed"] = "DEC_TIME_MALFORMED";
  ULIDErrorCode2["EncodeTimeNegative"] = "ENC_TIME_NEG";
  ULIDErrorCode2["EncodeTimeSizeExceeded"] = "ENC_TIME_SIZE_EXCEED";
  ULIDErrorCode2["EncodeTimeValueMalformed"] = "ENC_TIME_MALFORMED";
  ULIDErrorCode2["PRNGDetectFailure"] = "PRNG_DETECT";
  ULIDErrorCode2["ULIDInvalid"] = "ULID_INVALID";
  ULIDErrorCode2["Unexpected"] = "UNEXPECTED";
  ULIDErrorCode2["UUIDInvalid"] = "UUID_INVALID";
})(ULIDErrorCode || (ULIDErrorCode = {}));
var ULIDError = class extends Error {
  static {
    __name(this, "ULIDError");
  }
  constructor(errorCode, message) {
    super(`${message} (${errorCode})`);
    this.name = "ULIDError";
    this.code = errorCode;
  }
};
function randomChar(prng) {
  const randomPosition = Math.floor(prng() * ENCODING_LEN) % ENCODING_LEN;
  return ENCODING.charAt(randomPosition);
}
__name(randomChar, "randomChar");
function replaceCharAt(str, index, char) {
  if (index > str.length - 1) {
    return str;
  }
  return str.substr(0, index) + char + str.substr(index + 1);
}
__name(replaceCharAt, "replaceCharAt");
function incrementBase32(str) {
  let done = void 0, index = str.length, char, charIndex, output = str;
  const maxCharIndex = ENCODING_LEN - 1;
  while (!done && index-- >= 0) {
    char = output[index];
    charIndex = ENCODING.indexOf(char);
    if (charIndex === -1) {
      throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, "Incorrectly encoded string");
    }
    if (charIndex === maxCharIndex) {
      output = replaceCharAt(output, index, ENCODING[0]);
      continue;
    }
    done = replaceCharAt(output, index, ENCODING[charIndex + 1]);
  }
  if (typeof done === "string") {
    return done;
  }
  throw new ULIDError(ULIDErrorCode.Base32IncorrectEncoding, "Failed incrementing string");
}
__name(incrementBase32, "incrementBase32");
function decodeTime(id) {
  if (id.length !== TIME_LEN + RANDOM_LEN) {
    throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, "Malformed ULID");
  }
  const time3 = id.substr(0, TIME_LEN).toUpperCase().split("").reverse().reduce((carry, char, index) => {
    const encodingIndex = ENCODING.indexOf(char);
    if (encodingIndex === -1) {
      throw new ULIDError(ULIDErrorCode.DecodeTimeInvalidCharacter, `Time decode error: Invalid character: ${char}`);
    }
    return carry += encodingIndex * Math.pow(ENCODING_LEN, index);
  }, 0);
  if (time3 > TIME_MAX) {
    throw new ULIDError(ULIDErrorCode.DecodeTimeValueMalformed, `Malformed ULID: timestamp too large: ${time3}`);
  }
  return time3;
}
__name(decodeTime, "decodeTime");
function detectPRNG(root) {
  const rootLookup = detectRoot();
  const globalCrypto = rootLookup && (rootLookup.crypto || rootLookup.msCrypto) || (typeof import_node_crypto.default !== "undefined" ? import_node_crypto.default : null);
  if (typeof globalCrypto?.getRandomValues === "function") {
    return () => {
      const buffer = new Uint8Array(1);
      globalCrypto.getRandomValues(buffer);
      return buffer[0] / 255;
    };
  } else if (typeof globalCrypto?.randomBytes === "function") {
    return () => globalCrypto.randomBytes(1).readUInt8() / 255;
  } else if (import_node_crypto.default?.randomBytes) {
    return () => import_node_crypto.default.randomBytes(1).readUInt8() / 255;
  }
  throw new ULIDError(ULIDErrorCode.PRNGDetectFailure, "Failed to find a reliable PRNG");
}
__name(detectPRNG, "detectPRNG");
function detectRoot() {
  if (inWebWorker()) return self;
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  return null;
}
__name(detectRoot, "detectRoot");
function encodeRandom(len, prng) {
  let str = "";
  for (; len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
__name(encodeRandom, "encodeRandom");
function encodeTime(now, len = TIME_LEN) {
  if (isNaN(now)) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be a number: ${now}`);
  } else if (now > TIME_MAX) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${TIME_MAX}: ${now}`);
  } else if (now < 0) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeNegative, `Time must be positive: ${now}`);
  } else if (Number.isInteger(now) === false) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be an integer: ${now}`);
  }
  let mod, str = "";
  for (let currentLen = len; currentLen > 0; currentLen--) {
    mod = now % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now = (now - mod) / ENCODING_LEN;
  }
  return str;
}
__name(encodeTime, "encodeTime");
function inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
__name(inWebWorker, "inWebWorker");
function monotonicFactory(prng) {
  const currentPRNG = prng || detectPRNG();
  let lastTime = 0, lastRandom;
  return /* @__PURE__ */ __name(function _ulid2(seedTime) {
    const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;
    if (seed <= lastTime) {
      const incrementedRandom = lastRandom = incrementBase32(lastRandom);
      return encodeTime(lastTime, TIME_LEN) + incrementedRandom;
    }
    lastTime = seed;
    const newRandom = lastRandom = encodeRandom(RANDOM_LEN, currentPRNG);
    return encodeTime(seed, TIME_LEN) + newRandom;
  }, "_ulid");
}
__name(monotonicFactory, "monotonicFactory");

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/queue.js
function createQueue(port) {
  const transport = new JsonTransport();
  const generateId = monotonicFactory();
  const inflightMessages = /* @__PURE__ */ new Map();
  const queue = /* @__PURE__ */ __name(async (queueName, message, opts) => {
    const cleanup = [];
    if (opts?.idempotencyKey) {
      const existing = inflightMessages.get(opts.idempotencyKey);
      if (existing) {
        return {
          messageId: existing
        };
      }
    }
    const body = transport.serialize(message);
    let pathname;
    if (queueName.startsWith("__wkf_step_")) {
      pathname = `step`;
    } else if (queueName.startsWith("__wkf_workflow_")) {
      pathname = `flow`;
    } else {
      throw new Error("Unknown queue name prefix");
    }
    const messageId = MessageId.parse(`msg_${generateId()}`);
    if (opts?.idempotencyKey) {
      const key = opts.idempotencyKey;
      inflightMessages.set(key, messageId);
      cleanup.push(() => {
        inflightMessages.delete(key);
      });
    }
    (async () => {
      let defaultRetriesLeft = 3;
      for (let attempt = 0; defaultRetriesLeft > 0; attempt++) {
        defaultRetriesLeft--;
        const response = await fetch(`http://localhost:${port}/.well-known/workflow/v1/${pathname}`, {
          method: "POST",
          duplex: "half",
          headers: {
            "x-vqs-queue-name": queueName,
            "x-vqs-message-id": messageId,
            "x-vqs-message-attempt": String(attempt + 1)
          },
          body
        });
        if (response.ok) {
          return;
        }
        const text = await response.text();
        if (response.status === 503) {
          try {
            const retryIn = Number(JSON.parse(text).retryIn);
            await (0, import_promises.setTimeout)(retryIn * 1e3);
            defaultRetriesLeft++;
            continue;
          } catch {
          }
        }
        console.error(`[embedded world] Failed to queue message`, {
          queueName,
          text,
          status: response.status,
          headers: Object.fromEntries(response.headers.entries()),
          body: body.toString()
        });
      }
      console.error(`[embedded world] Reached max retries of embedded world queue implementation`);
    })().finally(() => {
      for (const fn of cleanup) {
        fn();
      }
    });
    return {
      messageId
    };
  }, "queue");
  const HeaderParser = zod_default.object({
    "x-vqs-queue-name": ValidQueueName,
    "x-vqs-message-id": MessageId,
    "x-vqs-message-attempt": zod_default.coerce.number()
  });
  const createQueueHandler = /* @__PURE__ */ __name((prefix, handler2) => {
    return async (req) => {
      const headers = HeaderParser.safeParse(Object.fromEntries(req.headers));
      if (!headers.success || !req.body) {
        return Response.json({
          error: "Missing required headers"
        }, {
          status: 400
        });
      }
      const queueName = headers.data["x-vqs-queue-name"];
      const messageId = headers.data["x-vqs-message-id"];
      const attempt = headers.data["x-vqs-message-attempt"];
      if (!queueName.startsWith(prefix)) {
        return Response.json({
          error: "Unhandled queue"
        }, {
          status: 400
        });
      }
      const body = await new JsonTransport().deserialize(req.body);
      try {
        const response = await handler2(body, {
          attempt,
          queueName,
          messageId
        });
        const retryIn = typeof response === "undefined" ? null : response.timeoutSeconds;
        if (retryIn) {
          return Response.json({
            retryIn
          }, {
            status: 503
          });
        }
        return Response.json({
          ok: true
        });
      } catch (error45) {
        return Response.json(String(error45), {
          status: 500
        });
      }
    };
  }, "createQueueHandler");
  const getDeploymentId = /* @__PURE__ */ __name(async () => {
    return "dpl_embedded";
  }, "getDeploymentId");
  return {
    queue,
    createQueueHandler,
    getDeploymentId
  };
}
__name(createQueue, "createQueue");

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/storage.js
var import_node_path2 = __toESM(require("node:path"), 1);

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/fs.js
var import_node_fs = require("node:fs");
var import_node_path = __toESM(require("node:path"), 1);
var ulid3 = monotonicFactory(() => Math.random());
var Ulid = external_exports.string().ulid();
function ulidToDate(maybeUlid) {
  const ulid4 = Ulid.safeParse(maybeUlid);
  if (!ulid4.success) {
    return null;
  }
  return new Date(decodeTime(ulid4.data));
}
__name(ulidToDate, "ulidToDate");
async function ensureDir(dirPath) {
  try {
    await import_node_fs.promises.mkdir(dirPath, {
      recursive: true
    });
  } catch (_error) {
  }
}
__name(ensureDir, "ensureDir");
async function writeJSON(filePath, data, opts) {
  return write(filePath, JSON.stringify(data, null, 2), opts);
}
__name(writeJSON, "writeJSON");
async function write(filePath, data, opts) {
  if (!opts?.overwrite) {
    try {
      await import_node_fs.promises.access(filePath);
      throw new WorkflowAPIError(`File ${filePath} already exists and 'overwrite' is false`, {
        status: 409
      });
    } catch (error45) {
      if (error45.code !== "ENOENT") {
        throw error45;
      }
    }
  }
  const tempPath = `${filePath}.tmp.${ulid3()}`;
  try {
    await ensureDir(import_node_path.default.dirname(filePath));
    await import_node_fs.promises.writeFile(tempPath, data);
    await import_node_fs.promises.rename(tempPath, filePath);
  } catch (error45) {
    await import_node_fs.promises.unlink(tempPath).catch(() => {
    });
    throw error45;
  }
}
__name(write, "write");
async function readJSON(filePath, decoder) {
  try {
    const content = await import_node_fs.promises.readFile(filePath, "utf-8");
    return decoder.parse(JSON.parse(content));
  } catch (error45) {
    if (error45.code === "ENOENT") return null;
    throw error45;
  }
}
__name(readJSON, "readJSON");
async function readBuffer(filePath) {
  const content = await import_node_fs.promises.readFile(filePath);
  return content;
}
__name(readBuffer, "readBuffer");
async function deleteJSON(filePath) {
  try {
    await import_node_fs.promises.unlink(filePath);
  } catch (error45) {
    if (error45.code !== "ENOENT") throw error45;
  }
}
__name(deleteJSON, "deleteJSON");
async function listJSONFiles(dirPath) {
  try {
    const files = await import_node_fs.promises.readdir(dirPath);
    return files.filter((f2) => f2.endsWith(".json")).map((f2) => f2.replace(".json", ""));
  } catch (error45) {
    if (error45.code === "ENOENT") return [];
    throw error45;
  }
}
__name(listJSONFiles, "listJSONFiles");
function parseCursor(cursor) {
  if (!cursor) return null;
  const parts = cursor.split("|");
  return {
    timestamp: new Date(parts[0]),
    id: parts[1] || null
  };
}
__name(parseCursor, "parseCursor");
function createCursor(timestamp, id) {
  return id ? `${timestamp.toISOString()}|${id}` : timestamp.toISOString();
}
__name(createCursor, "createCursor");
async function paginatedFileSystemQuery(config3) {
  const { directory, schema, filePrefix, filter, sortOrder = "desc", limit = 20, cursor, getCreatedAt, getId } = config3;
  const fileIds = await listJSONFiles(directory);
  const relevantFileIds = filePrefix ? fileIds.filter((fileId) => fileId.startsWith(filePrefix)) : fileIds;
  const parsedCursor = parseCursor(cursor);
  let candidateFileIds = relevantFileIds;
  if (parsedCursor) {
    candidateFileIds = relevantFileIds.filter((fileId) => {
      const filenameDate = getCreatedAt(`${fileId}.json`);
      if (filenameDate) {
        const cursorTime = parsedCursor.timestamp.getTime();
        const fileTime = filenameDate.getTime();
        if (parsedCursor.id) {
          return sortOrder === "desc" ? fileTime <= cursorTime : fileTime >= cursorTime;
        } else {
          return sortOrder === "desc" ? fileTime < cursorTime : fileTime > cursorTime;
        }
      }
      return false;
    });
  } else {
    candidateFileIds = relevantFileIds.filter((fileId) => {
      return getCreatedAt(`${fileId}.json`) !== null;
    });
  }
  const validItems = [];
  for (const fileId of candidateFileIds) {
    const filePath = import_node_path.default.join(directory, `${fileId}.json`);
    const item = await readJSON(filePath, schema);
    if (item) {
      if (filter && !filter(item)) continue;
      if (parsedCursor) {
        const itemTime = item.createdAt.getTime();
        const cursorTime = parsedCursor.timestamp.getTime();
        if (sortOrder === "desc") {
          if (itemTime > cursorTime) continue;
          if (itemTime === cursorTime && parsedCursor.id && getId) {
            const itemId = getId(item);
            if (itemId >= parsedCursor.id) continue;
          }
        } else {
          if (itemTime < cursorTime) continue;
          if (itemTime === cursorTime && parsedCursor.id && getId) {
            const itemId = getId(item);
            if (itemId <= parsedCursor.id) continue;
          }
        }
      }
      validItems.push(item);
    }
  }
  validItems.sort((a2, b2) => {
    const aTime = a2.createdAt.getTime();
    const bTime = b2.createdAt.getTime();
    const timeComparison = sortOrder === "asc" ? aTime - bTime : bTime - aTime;
    if (timeComparison === 0 && getId) {
      const aId = getId(a2);
      const bId = getId(b2);
      return sortOrder === "asc" ? aId.localeCompare(bId) : bId.localeCompare(aId);
    }
    return timeComparison;
  });
  const hasMore = validItems.length > limit;
  const items = hasMore ? validItems.slice(0, limit) : validItems;
  const nextCursor = hasMore && items.length > 0 ? createCursor(items[items.length - 1].createdAt, getId?.(items[items.length - 1])) : null;
  return {
    data: items,
    cursor: nextCursor,
    hasMore
  };
}
__name(paginatedFileSystemQuery, "paginatedFileSystemQuery");

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/storage.js
var monotonicUlid = monotonicFactory(() => Math.random());
function filterRunData(run, resolveData) {
  if (resolveData === "none") {
    return {
      ...run,
      input: [],
      output: void 0
    };
  }
  return run;
}
__name(filterRunData, "filterRunData");
function filterStepData(step, resolveData) {
  if (resolveData === "none") {
    return {
      ...step,
      input: [],
      output: void 0
    };
  }
  return step;
}
__name(filterStepData, "filterStepData");
function filterEventData(event, resolveData) {
  if (resolveData === "none") {
    const { eventData: _eventData, ...rest } = event;
    return rest;
  }
  return event;
}
__name(filterEventData, "filterEventData");
function filterHookData(hook2, resolveData) {
  if (resolveData === "none") {
    const { metadata: _metadata, ...rest } = hook2;
    return rest;
  }
  return hook2;
}
__name(filterHookData, "filterHookData");
var getObjectCreatedAt = /* @__PURE__ */ __name((idPrefix) => (filename) => {
  const replaceRegex = new RegExp(`^${idPrefix}_`, "g");
  const dashIndex = filename.indexOf("-");
  if (dashIndex === -1) {
    const ulid5 = filename.replace(/\.json$/, "").replace(replaceRegex, "");
    return ulidToDate(ulid5);
  }
  if (idPrefix === "step") {
    const runId = filename.substring(0, dashIndex);
    const ulid5 = runId.replace(/^wrun_/, "");
    return ulidToDate(ulid5);
  }
  const id = filename.substring(dashIndex + 1).replace(/\.json$/, "");
  const ulid4 = id.replace(replaceRegex, "");
  return ulidToDate(ulid4);
}, "getObjectCreatedAt");
function createStorage(basedir) {
  return {
    runs: {
      async create(data) {
        const runId = `wrun_${monotonicUlid()}`;
        const now = /* @__PURE__ */ new Date();
        const result = {
          runId,
          deploymentId: data.deploymentId,
          status: "pending",
          workflowName: data.workflowName,
          executionContext: data.executionContext,
          input: data.input || [],
          output: void 0,
          error: void 0,
          errorCode: void 0,
          startedAt: void 0,
          completedAt: void 0,
          createdAt: now,
          updatedAt: now
        };
        const runPath = import_node_path2.default.join(basedir, "runs", `${runId}.json`);
        await writeJSON(runPath, result);
        return result;
      },
      async get(id, params) {
        const runPath = import_node_path2.default.join(basedir, "runs", `${id}.json`);
        const run = await readJSON(runPath, WorkflowRunSchema);
        if (!run) {
          throw new WorkflowRunNotFoundError(id);
        }
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        return filterRunData(run, resolveData);
      },
      async update(id, data) {
        const runPath = import_node_path2.default.join(basedir, "runs", `${id}.json`);
        const run = await readJSON(runPath, WorkflowRunSchema);
        if (!run) {
          throw new WorkflowRunNotFoundError(id);
        }
        const now = /* @__PURE__ */ new Date();
        const updatedRun = {
          ...run,
          ...data,
          updatedAt: now
        };
        if (data.status === "running" && !updatedRun.startedAt) {
          updatedRun.startedAt = now;
        }
        if (data.status === "completed" || data.status === "failed" || data.status === "cancelled") {
          updatedRun.completedAt = now;
        }
        await writeJSON(runPath, updatedRun, {
          overwrite: true
        });
        return updatedRun;
      },
      async list(params) {
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        const result = await paginatedFileSystemQuery({
          directory: import_node_path2.default.join(basedir, "runs"),
          schema: WorkflowRunSchema,
          filter: /* @__PURE__ */ __name((run) => {
            if (params?.workflowName && run.workflowName !== params.workflowName) {
              return false;
            }
            if (params?.status && run.status !== params.status) {
              return false;
            }
            return true;
          }, "filter"),
          sortOrder: params?.pagination?.sortOrder ?? "desc",
          limit: params?.pagination?.limit,
          cursor: params?.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("wrun"),
          getId: /* @__PURE__ */ __name((run) => run.runId, "getId")
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((run) => ({
              ...run,
              input: [],
              output: void 0
            }))
          };
        }
        return result;
      },
      async cancel(id, params) {
        const run = await this.update(id, {
          status: "cancelled"
        });
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        return filterRunData(run, resolveData);
      },
      async pause(id, params) {
        const run = await this.update(id, {
          status: "paused"
        });
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        return filterRunData(run, resolveData);
      },
      async resume(id, params) {
        const run = await this.update(id, {
          status: "running"
        });
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        return filterRunData(run, resolveData);
      }
    },
    steps: {
      async create(runId, data) {
        const now = /* @__PURE__ */ new Date();
        const result = {
          runId,
          stepId: data.stepId,
          stepName: data.stepName,
          status: "pending",
          input: data.input,
          output: void 0,
          error: void 0,
          errorCode: void 0,
          attempt: 0,
          startedAt: void 0,
          completedAt: void 0,
          createdAt: now,
          updatedAt: now
        };
        const compositeKey = `${runId}-${data.stepId}`;
        const stepPath = import_node_path2.default.join(basedir, "steps", `${compositeKey}.json`);
        await writeJSON(stepPath, result);
        return result;
      },
      async get(runId, stepId, params) {
        if (!runId) {
          const fileIds = await listJSONFiles(import_node_path2.default.join(basedir, "steps"));
          const fileId = fileIds.find((fileId2) => fileId2.endsWith(`-${stepId}`));
          if (!fileId) {
            throw new Error(`Step ${stepId} not found`);
          }
          runId = fileId.split("-")[0];
        }
        const compositeKey = `${runId}-${stepId}`;
        const stepPath = import_node_path2.default.join(basedir, "steps", `${compositeKey}.json`);
        const step = await readJSON(stepPath, StepSchema);
        if (!step) {
          throw new Error(`Step ${stepId} in run ${runId} not found`);
        }
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        return filterStepData(step, resolveData);
      },
      async update(runId, stepId, data) {
        const compositeKey = `${runId}-${stepId}`;
        const stepPath = import_node_path2.default.join(basedir, "steps", `${compositeKey}.json`);
        const step = await readJSON(stepPath, StepSchema);
        if (!step) {
          throw new Error(`Step ${stepId} in run ${runId} not found`);
        }
        const now = /* @__PURE__ */ new Date();
        const updatedStep = {
          ...step,
          ...data,
          updatedAt: now
        };
        if (data.status === "running" && !updatedStep.startedAt) {
          updatedStep.startedAt = now;
        }
        if (data.status === "completed" || data.status === "failed") {
          updatedStep.completedAt = now;
        }
        await writeJSON(stepPath, updatedStep, {
          overwrite: true
        });
        return updatedStep;
      },
      async list(params) {
        const resolveData = params.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        const result = await paginatedFileSystemQuery({
          directory: import_node_path2.default.join(basedir, "steps"),
          schema: StepSchema,
          filePrefix: `${params.runId}-`,
          sortOrder: params.pagination?.sortOrder ?? "desc",
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("step"),
          getId: /* @__PURE__ */ __name((step) => step.stepId, "getId")
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((step) => ({
              ...step,
              input: [],
              output: void 0
            }))
          };
        }
        return result;
      }
    },
    // Events - filesystem-backed storage
    events: {
      async create(runId, data, params) {
        const eventId = `evnt_${monotonicUlid()}`;
        const now = /* @__PURE__ */ new Date();
        const result = {
          ...data,
          runId,
          eventId,
          createdAt: now
        };
        const compositeKey = `${runId}-${eventId}`;
        const eventPath = import_node_path2.default.join(basedir, "events", `${compositeKey}.json`);
        await writeJSON(eventPath, result);
        const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        return filterEventData(result, resolveData);
      },
      async list(params) {
        const { runId } = params;
        const resolveData = params.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        const result = await paginatedFileSystemQuery({
          directory: import_node_path2.default.join(basedir, "events"),
          schema: EventSchema,
          filePrefix: `${runId}-`,
          // Events in chronological order (oldest first) by default,
          // different from the default for other list calls.
          sortOrder: params.pagination?.sortOrder ?? "asc",
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("evnt"),
          getId: /* @__PURE__ */ __name((event) => event.eventId, "getId")
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((event) => {
              const { eventData: _eventData, ...rest } = event;
              return rest;
            })
          };
        }
        return result;
      },
      async listByCorrelationId(params) {
        const correlationId = params.correlationId;
        const resolveData = params.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION;
        const result = await paginatedFileSystemQuery({
          directory: import_node_path2.default.join(basedir, "events"),
          schema: EventSchema,
          // No filePrefix - search all events
          filter: /* @__PURE__ */ __name((event) => event.correlationId === correlationId, "filter"),
          // Events in chronological order (oldest first) by default,
          // different from the default for other list calls.
          sortOrder: params.pagination?.sortOrder ?? "asc",
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          getCreatedAt: getObjectCreatedAt("evnt"),
          getId: /* @__PURE__ */ __name((event) => event.eventId, "getId")
        });
        if (resolveData === "none") {
          return {
            ...result,
            data: result.data.map((event) => {
              const { eventData: _eventData, ...rest } = event;
              return rest;
            })
          };
        }
        return result;
      }
    },
    // Hooks
    hooks: {
      async create(runId, data) {
        const now = /* @__PURE__ */ new Date();
        const result = {
          runId,
          hookId: data.hookId,
          token: data.token,
          metadata: data.metadata,
          ownerId: "embedded-owner",
          projectId: "embedded-project",
          environment: "embedded",
          createdAt: now
        };
        const hookPath = import_node_path2.default.join(basedir, "hooks", `${data.hookId}.json`);
        await writeJSON(hookPath, result);
        return result;
      },
      async get(hookId, params) {
        const hookPath = import_node_path2.default.join(basedir, "hooks", `${hookId}.json`);
        const hook2 = await readJSON(hookPath, HookSchema);
        if (!hook2) {
          throw new Error(`Hook ${hookId} not found`);
        }
        const resolveData = params?.resolveData || DEFAULT_RESOLVE_DATA_OPTION;
        return filterHookData(hook2, resolveData);
      },
      async getByToken(token) {
        const hooksDir = import_node_path2.default.join(basedir, "hooks");
        const files = await listJSONFiles(hooksDir);
        for (const file2 of files) {
          const hookPath = import_node_path2.default.join(hooksDir, `${file2}.json`);
          const hook2 = await readJSON(hookPath, HookSchema);
          if (hook2 && hook2.token === token) {
            return hook2;
          }
        }
        throw new Error(`Hook with token ${token} not found`);
      },
      async list(params) {
        const hooksDir = import_node_path2.default.join(basedir, "hooks");
        const resolveData = params.resolveData || DEFAULT_RESOLVE_DATA_OPTION;
        const result = await paginatedFileSystemQuery({
          directory: hooksDir,
          schema: HookSchema,
          sortOrder: params.pagination?.sortOrder,
          limit: params.pagination?.limit,
          cursor: params.pagination?.cursor,
          filePrefix: void 0,
          filter: /* @__PURE__ */ __name((hook2) => {
            if (params.runId && hook2.runId !== params.runId) {
              return false;
            }
            return true;
          }, "filter"),
          getCreatedAt: /* @__PURE__ */ __name(() => {
            return /* @__PURE__ */ new Date(0);
          }, "getCreatedAt"),
          getId: /* @__PURE__ */ __name((hook2) => hook2.hookId, "getId")
        });
        return {
          ...result,
          data: result.data.map((hook2) => filterHookData(hook2, resolveData))
        };
      },
      async dispose(hookId) {
        const hookPath = import_node_path2.default.join(basedir, "hooks", `${hookId}.json`);
        const hook2 = await readJSON(hookPath, HookSchema);
        if (!hook2) {
          throw new Error(`Hook ${hookId} not found`);
        }
        await deleteJSON(hookPath);
        return hook2;
      }
    }
  };
}
__name(createStorage, "createStorage");

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/streamer.js
var import_node_events = require("node:events");
var import_node_path3 = __toESM(require("node:path"), 1);
var monotonicUlid2 = monotonicFactory(() => Math.random());
function serializeChunk(chunk) {
  const eofByte = Buffer.from([
    chunk.eof ? 1 : 0
  ]);
  return Buffer.concat([
    eofByte,
    chunk.chunk
  ]);
}
__name(serializeChunk, "serializeChunk");
function deserializeChunk(serialized) {
  const eof = serialized[0] === 1;
  const chunk = serialized.subarray(1);
  return {
    eof,
    chunk
  };
}
__name(deserializeChunk, "deserializeChunk");
function createStreamer(basedir) {
  const streamEmitter = new import_node_events.EventEmitter();
  return {
    async writeToStream(name, chunk) {
      const chunkId = `strm_${monotonicUlid2()}`;
      if (typeof chunk === "string") {
        chunk = new TextEncoder().encode(chunk);
      }
      const serialized = serializeChunk({
        chunk: Buffer.from(chunk),
        eof: false
      });
      const chunkPath = import_node_path3.default.join(basedir, "streams", "chunks", `${name}-${chunkId}.json`);
      await write(chunkPath, serialized);
      const chunkData = typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk instanceof Buffer ? new Uint8Array(chunk) : chunk;
      streamEmitter.emit(`chunk:${name}`, {
        streamName: name,
        chunkData,
        chunkId
      });
    },
    async closeStream(name) {
      const chunkId = `strm_${monotonicUlid2()}`;
      const chunkPath = import_node_path3.default.join(basedir, "streams", "chunks", `${name}-${chunkId}.json`);
      await write(chunkPath, serializeChunk({
        chunk: Buffer.from([]),
        eof: true
      }));
      streamEmitter.emit(`close:${name}`, {
        streamName: name
      });
    },
    async readFromStream(name, startIndex = 0) {
      const chunksDir = import_node_path3.default.join(basedir, "streams", "chunks");
      let removeListeners = /* @__PURE__ */ __name(() => {
      }, "removeListeners");
      return new ReadableStream({
        async start(controller) {
          const deliveredChunkIds = /* @__PURE__ */ new Set();
          const bufferedEventChunks = [];
          let isReadingFromDisk = true;
          const chunkListener = /* @__PURE__ */ __name((event) => {
            deliveredChunkIds.add(event.chunkId);
            if (isReadingFromDisk) {
              bufferedEventChunks.push({
                chunkId: event.chunkId,
                chunkData: event.chunkData
              });
            } else {
              controller.enqueue(event.chunkData);
            }
          }, "chunkListener");
          const closeListener = /* @__PURE__ */ __name(() => {
            streamEmitter.off(`chunk:${name}`, chunkListener);
            streamEmitter.off(`close:${name}`, closeListener);
            controller.close();
          }, "closeListener");
          removeListeners = closeListener;
          streamEmitter.on(`chunk:${name}`, chunkListener);
          streamEmitter.on(`close:${name}`, closeListener);
          const files = await listJSONFiles(chunksDir);
          const chunkFiles = files.filter((file2) => file2.startsWith(`${name}-`)).sort();
          let isComplete = false;
          for (let i2 = startIndex; i2 < chunkFiles.length; i2++) {
            const file2 = chunkFiles[i2];
            const chunkId = file2.substring(name.length + 1);
            if (deliveredChunkIds.has(chunkId)) {
              continue;
            }
            const chunk = deserializeChunk(await readBuffer(import_node_path3.default.join(chunksDir, `${file2}.json`)));
            if (chunk?.eof === true) {
              isComplete = true;
              break;
            }
            if (chunk.chunk.byteLength) {
              controller.enqueue(chunk.chunk);
            }
          }
          isReadingFromDisk = false;
          bufferedEventChunks.sort((a2, b2) => a2.chunkId.localeCompare(b2.chunkId));
          for (const buffered of bufferedEventChunks) {
            controller.enqueue(buffered.chunkData);
          }
          if (isComplete) {
            removeListeners();
            controller.close();
            return;
          }
        },
        cancel() {
          removeListeners();
        }
      });
    }
  };
}
__name(createStreamer, "createStreamer");

// node_modules/.pnpm/@workflow+world-local@4.0.1-beta.2/node_modules/@workflow/world-local/dist/index.js
function createEmbeddedWorld({ dataDir, port }) {
  const dir = dataDir ?? config.value.dataDir;
  const queuePort = port ?? config.value.port;
  return {
    ...createQueue(queuePort),
    ...createStorage(dir),
    ...createStreamer(dir)
  };
}
__name(createEmbeddedWorld, "createEmbeddedWorld");

// node_modules/.pnpm/@vercel+queue@0.0.0-alpha.24/node_modules/@vercel/queue/dist/index.mjs
var import_oidc = __toESM(require_dist(), 1);
async function streamToBuffer2(stream) {
  let totalLength = 0;
  const reader = stream.getReader();
  const chunks = [];
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      totalLength += value.length;
    }
  } finally {
    reader.releaseLock();
  }
  return Buffer.concat(chunks, totalLength);
}
__name(streamToBuffer2, "streamToBuffer");
var JsonTransport2 = class {
  static {
    __name(this, "JsonTransport");
  }
  contentType = "application/json";
  replacer;
  reviver;
  constructor(options = {}) {
    this.replacer = options.replacer;
    this.reviver = options.reviver;
  }
  serialize(value) {
    return Buffer.from(JSON.stringify(value, this.replacer), "utf8");
  }
  async deserialize(stream) {
    const buffer = await streamToBuffer2(stream);
    return JSON.parse(buffer.toString("utf8"), this.reviver);
  }
};
var MessageNotFoundError = class extends Error {
  static {
    __name(this, "MessageNotFoundError");
  }
  constructor(messageId) {
    super(`Message ${messageId} not found`);
    this.name = "MessageNotFoundError";
  }
};
var MessageNotAvailableError = class extends Error {
  static {
    __name(this, "MessageNotAvailableError");
  }
  constructor(messageId, reason) {
    super(`Message ${messageId} not available for processing${reason ? `: ${reason}` : ""}`);
    this.name = "MessageNotAvailableError";
  }
};
var MessageCorruptedError = class extends Error {
  static {
    __name(this, "MessageCorruptedError");
  }
  constructor(messageId, reason) {
    super(`Message ${messageId} is corrupted: ${reason}`);
    this.name = "MessageCorruptedError";
  }
};
var QueueEmptyError = class extends Error {
  static {
    __name(this, "QueueEmptyError");
  }
  constructor(queueName, consumerGroup) {
    super(`No messages available in queue "${queueName}" for consumer group "${consumerGroup}"`);
    this.name = "QueueEmptyError";
  }
};
var MessageLockedError = class extends Error {
  static {
    __name(this, "MessageLockedError");
  }
  retryAfter;
  constructor(messageId, retryAfter) {
    const retryMessage = retryAfter ? ` Retry after ${retryAfter} seconds.` : " Try again later.";
    super(`Message ${messageId} is temporarily locked.${retryMessage}`);
    this.name = "MessageLockedError";
    this.retryAfter = retryAfter;
  }
};
var UnauthorizedError = class extends Error {
  static {
    __name(this, "UnauthorizedError");
  }
  constructor(message = "Missing or invalid authentication token") {
    super(message);
    this.name = "UnauthorizedError";
  }
};
var ForbiddenError = class extends Error {
  static {
    __name(this, "ForbiddenError");
  }
  constructor(message = "Queue environment doesn't match token environment") {
    super(message);
    this.name = "ForbiddenError";
  }
};
var BadRequestError = class extends Error {
  static {
    __name(this, "BadRequestError");
  }
  constructor(message) {
    super(message);
    this.name = "BadRequestError";
  }
};
var InternalServerError = class extends Error {
  static {
    __name(this, "InternalServerError");
  }
  constructor(message = "Unexpected server error") {
    super(message);
    this.name = "InternalServerError";
  }
};
var InvalidLimitError = class extends Error {
  static {
    __name(this, "InvalidLimitError");
  }
  constructor(limit, min = 1, max = 10) {
    super(`Invalid limit: ${limit}. Limit must be between ${min} and ${max}.`);
    this.name = "InvalidLimitError";
  }
};
async function consumeStream(stream) {
  const reader = stream.getReader();
  try {
    while (true) {
      const { done } = await reader.read();
      if (done) break;
    }
  } finally {
    reader.releaseLock();
  }
}
__name(consumeStream, "consumeStream");
function parseQueueHeaders(headers) {
  const messageId = headers.get("Vqs-Message-Id");
  const deliveryCountStr = headers.get("Vqs-Delivery-Count") || "0";
  const timestamp = headers.get("Vqs-Timestamp");
  const contentType = headers.get("Content-Type") || "application/octet-stream";
  const ticket = headers.get("Vqs-Ticket");
  if (!messageId || !timestamp || !ticket) {
    return null;
  }
  const deliveryCount = parseInt(deliveryCountStr, 10);
  if (isNaN(deliveryCount)) {
    return null;
  }
  return {
    messageId,
    deliveryCount,
    createdAt: new Date(timestamp),
    contentType,
    ticket
  };
}
__name(parseQueueHeaders, "parseQueueHeaders");
var QueueClient = class {
  static {
    __name(this, "QueueClient");
  }
  baseUrl;
  basePath;
  token;
  /**
  * Create a new Vercel Queue Service client
  * @param options Client configuration options
  */
  constructor(options = {}) {
    this.baseUrl = options.baseUrl || "https://vercel-queue.com";
    this.basePath = options.basePath || "/api/v2/messages";
    this.token = options.token;
  }
  async getToken() {
    if (this.token) {
      return this.token;
    }
    const token = await (0, import_oidc.getVercelOidcToken)();
    if (!token) {
      throw new Error("Failed to get OIDC token from Vercel Functions. Make sure you are running in a Vercel Function environment, or provide a token explicitly.\n\nTo set up your environment:\n1. Link your project: 'vercel link'\n2. Pull environment variables: 'vercel env pull'\n3. Run with environment: 'dotenv -e .env.local -- your-command'");
    }
    return token;
  }
  /**
  * Send a message to a queue
  * @param options Send message options
  * @param transport Serializer/deserializer for the payload
  * @returns Promise with the message ID
  * @throws {BadRequestError} When request parameters are invalid
  * @throws {UnauthorizedError} When authentication fails
  * @throws {ForbiddenError} When access is denied (environment mismatch)
  * @throws {InternalServerError} When server encounters an error
  */
  async sendMessage(options, transport) {
    const { queueName, payload, idempotencyKey, retentionSeconds } = options;
    const headers = new Headers({
      Authorization: `Bearer ${await this.getToken()}`,
      "Vqs-Queue-Name": queueName,
      "Content-Type": transport.contentType
    });
    const deploymentId = options.deploymentId || process.env.VERCEL_DEPLOYMENT_ID;
    if (deploymentId) {
      headers.set("Vqs-Deployment-Id", deploymentId);
    }
    if (idempotencyKey) {
      headers.set("Vqs-Idempotency-Key", idempotencyKey);
    }
    if (retentionSeconds !== void 0) {
      headers.set("Vqs-Retention-Seconds", retentionSeconds.toString());
    }
    const body = transport.serialize(payload);
    const response = await fetch(`${this.baseUrl}${this.basePath}`, {
      method: "POST",
      headers,
      body
    });
    if (!response.ok) {
      if (response.status === 400) {
        const errorText = await response.text();
        throw new BadRequestError(errorText || "Invalid parameters");
      }
      if (response.status === 401) {
        throw new UnauthorizedError();
      }
      if (response.status === 403) {
        throw new ForbiddenError();
      }
      if (response.status === 409) {
        throw new Error("Duplicate idempotency key detected");
      }
      if (response.status >= 500) {
        throw new InternalServerError(`Server error: ${response.status} ${response.statusText}`);
      }
      throw new Error(`Failed to send message: ${response.status} ${response.statusText}`);
    }
    const responseData = await response.json();
    return responseData;
  }
  /**
  * Receive messages from a queue
  * @param options Receive messages options
  * @param transport Serializer/deserializer for the payload
  * @returns AsyncGenerator that yields messages as they arrive
  * @throws {InvalidLimitError} When limit parameter is not between 1 and 10
  * @throws {QueueEmptyError} When no messages are available (204)
  * @throws {MessageLockedError} When messages are temporarily locked (423)
  * @throws {BadRequestError} When request parameters are invalid
  * @throws {UnauthorizedError} When authentication fails
  * @throws {ForbiddenError} When access is denied (environment mismatch)
  * @throws {InternalServerError} When server encounters an error
  */
  async *receiveMessages(options, transport) {
    const { queueName, consumerGroup, visibilityTimeoutSeconds, limit } = options;
    if (limit !== void 0 && (limit < 1 || limit > 10)) {
      throw new InvalidLimitError(limit);
    }
    const headers = new Headers({
      Authorization: `Bearer ${await this.getToken()}`,
      "Vqs-Queue-Name": queueName,
      "Vqs-Consumer-Group": consumerGroup,
      Accept: "multipart/mixed"
    });
    if (visibilityTimeoutSeconds !== void 0) {
      headers.set("Vqs-Visibility-Timeout", visibilityTimeoutSeconds.toString());
    }
    if (limit !== void 0) {
      headers.set("Vqs-Limit", limit.toString());
    }
    const response = await fetch(`${this.baseUrl}${this.basePath}`, {
      method: "GET",
      headers
    });
    if (response.status === 204) {
      throw new QueueEmptyError(queueName, consumerGroup);
    }
    if (!response.ok) {
      if (response.status === 400) {
        const errorText = await response.text();
        throw new BadRequestError(errorText || "Invalid parameters");
      }
      if (response.status === 401) {
        throw new UnauthorizedError();
      }
      if (response.status === 403) {
        throw new ForbiddenError();
      }
      if (response.status === 423) {
        const retryAfterHeader = response.headers.get("Retry-After");
        let retryAfter;
        if (retryAfterHeader) {
          const parsed = parseInt(retryAfterHeader, 10);
          retryAfter = isNaN(parsed) ? void 0 : parsed;
        }
        throw new MessageLockedError("next message", retryAfter);
      }
      if (response.status >= 500) {
        throw new InternalServerError(`Server error: ${response.status} ${response.statusText}`);
      }
      throw new Error(`Failed to receive messages: ${response.status} ${response.statusText}`);
    }
    for await (const multipartMessage of parseMultipartStream(response)) {
      try {
        const parsedHeaders = parseQueueHeaders(multipartMessage.headers);
        if (!parsedHeaders) {
          console.warn("Missing required queue headers in multipart part");
          await consumeStream(multipartMessage.payload);
          continue;
        }
        const deserializedPayload = await transport.deserialize(multipartMessage.payload);
        const message = {
          ...parsedHeaders,
          payload: deserializedPayload
        };
        yield message;
      } catch (error45) {
        console.warn("Failed to process multipart message:", error45);
        await consumeStream(multipartMessage.payload);
      }
    }
  }
  async receiveMessageById(options, transport) {
    const { queueName, consumerGroup, messageId, visibilityTimeoutSeconds, skipPayload } = options;
    const headers = new Headers({
      Authorization: `Bearer ${await this.getToken()}`,
      "Vqs-Queue-Name": queueName,
      "Vqs-Consumer-Group": consumerGroup,
      Accept: "multipart/mixed"
    });
    if (visibilityTimeoutSeconds !== void 0) {
      headers.set("Vqs-Visibility-Timeout", visibilityTimeoutSeconds.toString());
    }
    if (skipPayload) {
      headers.set("Vqs-Skip-Payload", "1");
    }
    const response = await fetch(`${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`, {
      method: "GET",
      headers
    });
    if (!response.ok) {
      if (response.status === 400) {
        const errorText = await response.text();
        throw new BadRequestError(errorText || "Invalid parameters");
      }
      if (response.status === 401) {
        throw new UnauthorizedError();
      }
      if (response.status === 403) {
        throw new ForbiddenError();
      }
      if (response.status === 404) {
        throw new MessageNotFoundError(messageId);
      }
      if (response.status === 423) {
        const retryAfterHeader = response.headers.get("Retry-After");
        let retryAfter;
        if (retryAfterHeader) {
          const parsed = parseInt(retryAfterHeader, 10);
          retryAfter = isNaN(parsed) ? void 0 : parsed;
        }
        throw new MessageLockedError(messageId, retryAfter);
      }
      if (response.status === 409) {
        throw new MessageNotAvailableError(messageId);
      }
      if (response.status >= 500) {
        throw new InternalServerError(`Server error: ${response.status} ${response.statusText}`);
      }
      throw new Error(`Failed to receive message by ID: ${response.status} ${response.statusText}`);
    }
    if (skipPayload && response.status === 204) {
      const parsedHeaders = parseQueueHeaders(response.headers);
      if (!parsedHeaders) {
        throw new MessageCorruptedError(messageId, "Missing required queue headers in 204 response");
      }
      const message = {
        ...parsedHeaders,
        payload: void 0
      };
      return {
        message
      };
    }
    if (!transport) {
      throw new Error("Transport is required when skipPayload is not true");
    }
    try {
      for await (const multipartMessage of parseMultipartStream(response)) {
        try {
          const parsedHeaders = parseQueueHeaders(multipartMessage.headers);
          if (!parsedHeaders) {
            console.warn("Missing required queue headers in multipart part");
            await consumeStream(multipartMessage.payload);
            continue;
          }
          const deserializedPayload = await transport.deserialize(multipartMessage.payload);
          const message = {
            ...parsedHeaders,
            payload: deserializedPayload
          };
          return {
            message
          };
        } catch (error45) {
          console.warn("Failed to deserialize message by ID:", error45);
          await consumeStream(multipartMessage.payload);
          throw new MessageCorruptedError(messageId, `Failed to deserialize payload: ${error45}`);
        }
      }
    } catch (error45) {
      if (error45 instanceof MessageCorruptedError) {
        throw error45;
      }
      throw new MessageCorruptedError(messageId, `Failed to parse multipart response: ${error45}`);
    }
    throw new MessageNotFoundError(messageId);
  }
  /**
  * Delete a message (acknowledge processing)
  * @param options Delete message options
  * @returns Promise with delete status
  * @throws {MessageNotFoundError} When the message doesn't exist (404)
  * @throws {MessageNotAvailableError} When message can't be deleted (409)
  * @throws {BadRequestError} When ticket is missing or invalid (400)
  * @throws {UnauthorizedError} When authentication fails
  * @throws {ForbiddenError} When access is denied (environment mismatch)
  * @throws {InternalServerError} When server encounters an error
  */
  async deleteMessage(options) {
    const { queueName, consumerGroup, messageId, ticket } = options;
    const response = await fetch(`${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`, {
      method: "DELETE",
      headers: new Headers({
        Authorization: `Bearer ${await this.getToken()}`,
        "Vqs-Queue-Name": queueName,
        "Vqs-Consumer-Group": consumerGroup,
        "Vqs-Ticket": ticket
      })
    });
    if (!response.ok) {
      if (response.status === 400) {
        throw new BadRequestError("Missing or invalid ticket");
      }
      if (response.status === 401) {
        throw new UnauthorizedError();
      }
      if (response.status === 403) {
        throw new ForbiddenError();
      }
      if (response.status === 404) {
        throw new MessageNotFoundError(messageId);
      }
      if (response.status === 409) {
        throw new MessageNotAvailableError(messageId, "Invalid ticket, message not in correct state, or already processed");
      }
      if (response.status >= 500) {
        throw new InternalServerError(`Server error: ${response.status} ${response.statusText}`);
      }
      throw new Error(`Failed to delete message: ${response.status} ${response.statusText}`);
    }
    return {
      deleted: true
    };
  }
  /**
  * Change the visibility timeout of a message
  * @param options Change visibility options
  * @returns Promise with update status
  * @throws {MessageNotFoundError} When the message doesn't exist (404)
  * @throws {MessageNotAvailableError} When message can't be updated (409)
  * @throws {BadRequestError} When ticket is missing or visibility timeout invalid (400)
  * @throws {UnauthorizedError} When authentication fails
  * @throws {ForbiddenError} When access is denied (environment mismatch)
  * @throws {InternalServerError} When server encounters an error
  */
  async changeVisibility(options) {
    const { queueName, consumerGroup, messageId, ticket, visibilityTimeoutSeconds } = options;
    const response = await fetch(`${this.baseUrl}${this.basePath}/${encodeURIComponent(messageId)}`, {
      method: "PATCH",
      headers: new Headers({
        Authorization: `Bearer ${await this.getToken()}`,
        "Vqs-Queue-Name": queueName,
        "Vqs-Consumer-Group": consumerGroup,
        "Vqs-Ticket": ticket,
        "Vqs-Visibility-Timeout": visibilityTimeoutSeconds.toString()
      })
    });
    if (!response.ok) {
      if (response.status === 400) {
        throw new BadRequestError("Missing ticket or invalid visibility timeout");
      }
      if (response.status === 401) {
        throw new UnauthorizedError();
      }
      if (response.status === 403) {
        throw new ForbiddenError();
      }
      if (response.status === 404) {
        throw new MessageNotFoundError(messageId);
      }
      if (response.status === 409) {
        throw new MessageNotAvailableError(messageId, "Invalid ticket, message not in correct state, or already processed");
      }
      if (response.status >= 500) {
        throw new InternalServerError(`Server error: ${response.status} ${response.statusText}`);
      }
      throw new Error(`Failed to change visibility: ${response.status} ${response.statusText}`);
    }
    return {
      updated: true
    };
  }
};
function validateWildcardPattern(pattern) {
  const firstIndex = pattern.indexOf("*");
  const lastIndex = pattern.lastIndexOf("*");
  if (firstIndex !== lastIndex) {
    return false;
  }
  if (firstIndex === -1) {
    return false;
  }
  if (firstIndex !== pattern.length - 1) {
    return false;
  }
  return true;
}
__name(validateWildcardPattern, "validateWildcardPattern");
function matchesWildcardPattern(topicName, pattern) {
  const prefix = pattern.slice(0, -1);
  return topicName.startsWith(prefix);
}
__name(matchesWildcardPattern, "matchesWildcardPattern");
function findTopicHandler(queueName, handlers) {
  const exactHandler = handlers[queueName];
  if (exactHandler) {
    return exactHandler;
  }
  for (const pattern in handlers) {
    if (pattern.includes("*") && matchesWildcardPattern(queueName, pattern)) {
      return handlers[pattern];
    }
  }
  return null;
}
__name(findTopicHandler, "findTopicHandler");
async function parseCallback(request2) {
  const contentType = request2.headers.get("content-type");
  if (!contentType || !contentType.includes("application/cloudevents+json")) {
    throw new Error("Invalid content type: expected 'application/cloudevents+json'");
  }
  let cloudEvent;
  try {
    cloudEvent = await request2.json();
  } catch (error45) {
    throw new Error("Failed to parse CloudEvent from request body");
  }
  if (!cloudEvent.type || !cloudEvent.source || !cloudEvent.id || typeof cloudEvent.data !== "object" || cloudEvent.data == null) {
    throw new Error("Invalid CloudEvent: missing required fields");
  }
  if (cloudEvent.type !== "com.vercel.queue.v1beta") {
    throw new Error(`Invalid CloudEvent type: expected 'com.vercel.queue.v1beta', got '${cloudEvent.type}'`);
  }
  const missingFields = [];
  if (!("queueName" in cloudEvent.data)) missingFields.push("queueName");
  if (!("consumerGroup" in cloudEvent.data)) missingFields.push("consumerGroup");
  if (!("messageId" in cloudEvent.data)) missingFields.push("messageId");
  if (missingFields.length > 0) {
    throw new Error(`Missing required CloudEvent data fields: ${missingFields.join(", ")}`);
  }
  const { messageId, queueName, consumerGroup } = cloudEvent.data;
  return {
    queueName,
    consumerGroup,
    messageId
  };
}
__name(parseCallback, "parseCallback");
function handleCallback(handlers) {
  for (const topicPattern in handlers) {
    if (topicPattern.includes("*")) {
      if (!validateWildcardPattern(topicPattern)) {
        throw new Error(`Invalid wildcard pattern "${topicPattern}": * may only appear once and must be at the end of the topic name`);
      }
    }
  }
  const routeHandler = /* @__PURE__ */ __name(async (request2) => {
    try {
      const { queueName, consumerGroup, messageId } = await parseCallback(request2);
      const topicHandler = findTopicHandler(queueName, handlers);
      if (!topicHandler) {
        const availableTopics = Object.keys(handlers).join(", ");
        return Response.json({
          error: `No handler found for topic: ${queueName}`,
          availableTopics
        }, {
          status: 404
        });
      }
      const consumerGroupHandler = topicHandler[consumerGroup];
      if (!consumerGroupHandler) {
        const availableGroups = Object.keys(topicHandler).join(", ");
        return Response.json({
          error: `No handler found for consumer group "${consumerGroup}" in topic "${queueName}".`,
          availableGroups
        }, {
          status: 404
        });
      }
      const client = new QueueClient();
      const topic = new Topic(client, queueName);
      const cg = topic.consumerGroup(consumerGroup);
      await cg.consume(consumerGroupHandler, {
        messageId
      });
      return Response.json({
        status: "success"
      });
    } catch (error45) {
      console.error("Queue callback error:", error45);
      if (error45 instanceof Error && (error45.message.includes("Missing required CloudEvent data fields") || error45.message.includes("Invalid CloudEvent") || error45.message.includes("Invalid CloudEvent type") || error45.message.includes("Invalid content type") || error45.message.includes("Failed to parse CloudEvent"))) {
        return Response.json({
          error: error45.message
        }, {
          status: 400
        });
      }
      return Response.json({
        error: "Failed to process queue message"
      }, {
        status: 500
      });
    }
  }, "routeHandler");
  if (isDevMode()) {
    registerDevRouteHandler(routeHandler, handlers);
  }
  return routeHandler;
}
__name(handleCallback, "handleCallback");
var devRouteHandlers2 = /* @__PURE__ */ new Map();
var wildcardRouteHandlers2 = /* @__PURE__ */ new Map();
var routeHandlerKeys = /* @__PURE__ */ new WeakMap();
function cleanupDeadRefs(key, refs) {
  const aliveRefs = refs.filter((ref) => ref.deref() !== void 0);
  if (aliveRefs.length === 0) {
    wildcardRouteHandlers2.delete(key);
  } else if (aliveRefs.length < refs.length) {
    wildcardRouteHandlers2.set(key, aliveRefs);
  }
}
__name(cleanupDeadRefs, "cleanupDeadRefs");
function isDevMode() {
  return process.env.NODE_ENV === "development";
}
__name(isDevMode, "isDevMode");
function registerDevRouteHandler(routeHandler, handlers) {
  const existingKeys = routeHandlerKeys.get(routeHandler);
  if (existingKeys) {
    const newKeys = /* @__PURE__ */ new Set();
    for (const topicName in handlers) {
      for (const consumerGroup in handlers[topicName]) {
        newKeys.add(`${topicName}:${consumerGroup}`);
      }
    }
    for (const key of existingKeys) {
      if (!newKeys.has(key)) {
        const [topicPattern] = key.split(":");
        if (topicPattern.includes("*")) {
          const refs = wildcardRouteHandlers2.get(key);
          if (refs) {
            const filteredRefs = refs.filter((ref) => ref.deref() !== routeHandler);
            if (filteredRefs.length === 0) {
              wildcardRouteHandlers2.delete(key);
            } else {
              wildcardRouteHandlers2.set(key, filteredRefs);
            }
          }
        } else {
          devRouteHandlers2.delete(key);
        }
      }
    }
  }
  const keys = /* @__PURE__ */ new Set();
  for (const topicName in handlers) {
    for (const consumerGroup in handlers[topicName]) {
      const key = `${topicName}:${consumerGroup}`;
      keys.add(key);
      if (topicName.includes("*")) {
        const weakRef = new WeakRef(routeHandler);
        const existing = wildcardRouteHandlers2.get(key) || [];
        cleanupDeadRefs(key, existing);
        const cleanedRefs = wildcardRouteHandlers2.get(key) || [];
        cleanedRefs.push(weakRef);
        wildcardRouteHandlers2.set(key, cleanedRefs);
      } else {
        devRouteHandlers2.set(key, {
          routeHandler,
          topicPattern: topicName
        });
      }
    }
  }
  routeHandlerKeys.set(routeHandler, keys);
}
__name(registerDevRouteHandler, "registerDevRouteHandler");
function findRouteHandlersForTopic(topicName) {
  const handlersMap = /* @__PURE__ */ new Map();
  for (const [key, { routeHandler, topicPattern }] of devRouteHandlers2.entries()) {
    const [_2, consumerGroup] = key.split(":");
    if (topicPattern === topicName) {
      if (!handlersMap.has(routeHandler)) {
        handlersMap.set(routeHandler, /* @__PURE__ */ new Set());
      }
      handlersMap.get(routeHandler).add(consumerGroup);
    }
  }
  for (const [key, refs] of wildcardRouteHandlers2.entries()) {
    const [pattern, consumerGroup] = key.split(":");
    if (matchesWildcardPattern(topicName, pattern)) {
      cleanupDeadRefs(key, refs);
      const cleanedRefs = wildcardRouteHandlers2.get(key) || [];
      for (const ref of cleanedRefs) {
        const routeHandler = ref.deref();
        if (routeHandler) {
          if (!handlersMap.has(routeHandler)) {
            handlersMap.set(routeHandler, /* @__PURE__ */ new Set());
          }
          handlersMap.get(routeHandler).add(consumerGroup);
        }
      }
    }
  }
  return handlersMap;
}
__name(findRouteHandlersForTopic, "findRouteHandlersForTopic");
function createMockCloudEventRequest(topicName, consumerGroup, messageId) {
  const cloudEvent = {
    type: "com.vercel.queue.v1beta",
    source: `/topic/${topicName}/consumer/${consumerGroup}`,
    id: messageId,
    datacontenttype: "application/json",
    data: {
      messageId,
      queueName: topicName,
      consumerGroup
    },
    time: /* @__PURE__ */ (/* @__PURE__ */ new Date()).toISOString(),
    specversion: "1.0"
  };
  return new Request("https://localhost/api/queue/callback", {
    method: "POST",
    headers: {
      "Content-Type": "application/cloudevents+json"
    },
    body: JSON.stringify(cloudEvent)
  });
}
__name(createMockCloudEventRequest, "createMockCloudEventRequest");
var DEV_CALLBACK_DELAY = 1e3;
function scheduleDevTimeout(topicName, messageId, timeoutSeconds) {
  console.log(`[Dev Mode] Message ${messageId} timed out for ${timeoutSeconds}s, will re-trigger`);
  setTimeout(() => {
    console.log(`[Dev Mode] Re-triggering callback for timed-out message ${messageId}`);
    triggerDevCallbacks(topicName, messageId);
  }, timeoutSeconds * 1e3 + DEV_CALLBACK_DELAY);
}
__name(scheduleDevTimeout, "scheduleDevTimeout");
function triggerDevCallbacks(topicName, messageId) {
  const handlersMap = findRouteHandlersForTopic(topicName);
  if (handlersMap.size === 0) {
    return;
  }
  const consumerGroups = Array.from(new Set(Array.from(handlersMap.values()).flatMap((groups) => Array.from(groups))));
  console.log(`[Dev Mode] Triggering local callbacks for topic "${topicName}" \u2192 consumers: ${consumerGroups.join(", ")}`);
  setTimeout(async () => {
    for (const [routeHandler, consumerGroups2] of handlersMap.entries()) {
      for (const consumerGroup of consumerGroups2) {
        try {
          const request2 = createMockCloudEventRequest(topicName, consumerGroup, messageId);
          const response = await routeHandler(request2);
          if (response.ok) {
            try {
              const responseData = await response.json();
              if (responseData.status === "success") {
                console.log(`[Dev Mode] Message processed for ${topicName}/${consumerGroup}`);
              }
            } catch (jsonError) {
              console.error(`[Dev Mode] Failed to parse success response for ${topicName}/${consumerGroup}:`, jsonError);
            }
          } else {
            try {
              const errorData = await response.json();
              console.error(`[Dev Mode] Failed to process message for ${topicName}/${consumerGroup}:`, errorData.error || response.statusText);
            } catch (jsonError) {
              console.error(`[Dev Mode] Failed to process message for ${topicName}/${consumerGroup}:`, response.statusText);
            }
          }
        } catch (error45) {
          console.error(`[Dev Mode] Error triggering callback for ${topicName}/${consumerGroup}:`, error45);
        }
      }
    }
  }, DEV_CALLBACK_DELAY);
}
__name(triggerDevCallbacks, "triggerDevCallbacks");
function clearDevHandlers2() {
  devRouteHandlers2.clear();
  wildcardRouteHandlers2.clear();
}
__name(clearDevHandlers2, "clearDevHandlers");
if (process.env.NODE_ENV === "test" || process.env.VITEST) {
  globalThis.__clearDevHandlers = clearDevHandlers2;
}
var ConsumerGroup = class {
  static {
    __name(this, "ConsumerGroup");
  }
  client;
  topicName;
  consumerGroupName;
  visibilityTimeout;
  refreshInterval;
  transport;
  /**
  * Create a new ConsumerGroup instance
  * @param client QueueClient instance to use for API calls
  * @param topicName Name of the topic to consume from
  * @param consumerGroupName Name of the consumer group
  * @param options Optional configuration
  */
  constructor(client, topicName, consumerGroupName, options = {}) {
    this.client = client;
    this.topicName = topicName;
    this.consumerGroupName = consumerGroupName;
    this.visibilityTimeout = options.visibilityTimeoutSeconds || 30;
    this.refreshInterval = options.refreshInterval || 10;
    this.transport = options.transport || new JsonTransport2();
  }
  /**
  * Starts a background loop that periodically extends the visibility timeout for a message.
  * This prevents the message from becoming visible to other consumers while it's being processed.
  *
  * The extension loop runs every `refreshInterval` seconds and updates the message's
  * visibility timeout to `visibilityTimeout` seconds from the current time.
  *
  * @param messageId - The unique identifier of the message to extend visibility for
  * @param ticket - The receipt ticket that proves ownership of the message
  * @returns A function that when called will stop the extension loop
  *
  * @remarks
  * - The first extension attempt occurs after `refreshInterval` seconds, not immediately
  * - If an extension fails, the loop terminates with an error logged to console
  * - The returned stop function is idempotent - calling it multiple times is safe
  * - By default, the stop function returns immediately without waiting for in-flight
  * - Pass `true` to the stop function to wait for any in-flight extension to complete
  */
  startVisibilityExtension(messageId, ticket) {
    let isRunning = true;
    let resolveLifecycle;
    let timeoutId = null;
    const lifecyclePromise = new Promise((resolve) => {
      resolveLifecycle = resolve;
    });
    const extend2 = /* @__PURE__ */ __name(async () => {
      if (!isRunning) {
        resolveLifecycle();
        return;
      }
      try {
        await this.client.changeVisibility({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId,
          ticket,
          visibilityTimeoutSeconds: this.visibilityTimeout
        });
        if (isRunning) {
          timeoutId = setTimeout(() => extend2(), this.refreshInterval * 1e3);
        } else {
          resolveLifecycle();
        }
      } catch (error45) {
        console.error(`Failed to extend visibility for message ${messageId}:`, error45);
        resolveLifecycle();
      }
    }, "extend");
    timeoutId = setTimeout(() => extend2(), this.refreshInterval * 1e3);
    return async (waitForCompletion = false) => {
      isRunning = false;
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (waitForCompletion) {
        await lifecyclePromise;
      } else {
        resolveLifecycle();
      }
    };
  }
  /**
  * Process a single message with the given handler
  * @param message The message to process
  * @param handler Function to process the message
  */
  async processMessage(message, handler2) {
    const stopExtension = this.startVisibilityExtension(message.messageId, message.ticket);
    try {
      const result = await handler2(message.payload, {
        messageId: message.messageId,
        deliveryCount: message.deliveryCount,
        createdAt: message.createdAt,
        topicName: this.topicName,
        consumerGroup: this.consumerGroupName
      });
      await stopExtension();
      if (result && "timeoutSeconds" in result) {
        await this.client.changeVisibility({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId: message.messageId,
          ticket: message.ticket,
          visibilityTimeoutSeconds: result.timeoutSeconds
        });
        if (isDevMode()) {
          scheduleDevTimeout(this.topicName, message.messageId, result.timeoutSeconds);
        }
      } else {
        await this.client.deleteMessage({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId: message.messageId,
          ticket: message.ticket
        });
      }
    } catch (error45) {
      await stopExtension();
      if (this.transport.finalize && message.payload !== void 0 && message.payload !== null) {
        try {
          await this.transport.finalize(message.payload);
        } catch (finalizeError) {
          console.warn("Failed to finalize message payload:", finalizeError);
        }
      }
      throw error45;
    }
  }
  async consume(handler2, options) {
    if (options?.messageId) {
      if (options.skipPayload) {
        const response = await this.client.receiveMessageById({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId: options.messageId,
          visibilityTimeoutSeconds: this.visibilityTimeout,
          skipPayload: true
        }, this.transport);
        await this.processMessage(response.message, handler2);
      } else {
        const response = await this.client.receiveMessageById({
          queueName: this.topicName,
          consumerGroup: this.consumerGroupName,
          messageId: options.messageId,
          visibilityTimeoutSeconds: this.visibilityTimeout
        }, this.transport);
        await this.processMessage(response.message, handler2);
      }
    } else {
      let messageFound = false;
      for await (const message of this.client.receiveMessages({
        queueName: this.topicName,
        consumerGroup: this.consumerGroupName,
        visibilityTimeoutSeconds: this.visibilityTimeout,
        limit: 1
      }, this.transport)) {
        messageFound = true;
        await this.processMessage(message, handler2);
        break;
      }
      if (!messageFound) {
        throw new Error("No messages available");
      }
    }
  }
  /**
  * Get the consumer group name
  */
  get name() {
    return this.consumerGroupName;
  }
  /**
  * Get the topic name this consumer group is subscribed to
  */
  get topic() {
    return this.topicName;
  }
};
var Topic = class {
  static {
    __name(this, "Topic");
  }
  client;
  topicName;
  transport;
  /**
  * Create a new Topic instance
  * @param client QueueClient instance to use for API calls
  * @param topicName Name of the topic to work with
  * @param transport Optional serializer/deserializer for the payload (defaults to JSON)
  */
  constructor(client, topicName, transport) {
    this.client = client;
    this.topicName = topicName;
    this.transport = transport || new JsonTransport2();
  }
  /**
  * Publish a message to the topic
  * @param payload The data to publish
  * @param options Optional publish options
  * @returns An object containing the message ID
  * @throws {BadRequestError} When request parameters are invalid
  * @throws {UnauthorizedError} When authentication fails
  * @throws {ForbiddenError} When access is denied (environment mismatch)
  * @throws {InternalServerError} When server encounters an error
  */
  async publish(payload, options) {
    const result = await this.client.sendMessage({
      queueName: this.topicName,
      payload,
      idempotencyKey: options?.idempotencyKey,
      retentionSeconds: options?.retentionSeconds,
      deploymentId: options?.deploymentId
    }, this.transport);
    if (isDevMode()) {
      triggerDevCallbacks(this.topicName, result.messageId);
    }
    return {
      messageId: result.messageId
    };
  }
  /**
  * Create a consumer group for this topic
  * @param consumerGroupName Name of the consumer group
  * @param options Optional configuration for the consumer group
  * @returns A ConsumerGroup instance
  */
  consumerGroup(consumerGroupName, options) {
    const consumerOptions = {
      ...options,
      transport: options?.transport || this.transport
    };
    return new ConsumerGroup(this.client, this.topicName, consumerGroupName, consumerOptions);
  }
  /**
  * Get the topic name
  */
  get name() {
    return this.topicName;
  }
  /**
  * Get the transport used by this topic
  */
  get serializer() {
    return this.transport;
  }
};
async function send(topicName, payload, options) {
  const transport = options?.transport || new JsonTransport2();
  const client = new QueueClient();
  const result = await client.sendMessage({
    queueName: topicName,
    payload,
    idempotencyKey: options?.idempotencyKey,
    retentionSeconds: options?.retentionSeconds,
    deploymentId: options?.deploymentId
  }, transport);
  if (isDevMode()) {
    triggerDevCallbacks(topicName, result.messageId);
  }
  return {
    messageId: result.messageId
  };
}
__name(send, "send");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/queue.js
var MessageWrapper = object({
  payload: QueuePayloadSchema,
  queueName: ValidQueueName
});
function createQueue2() {
  const queue = /* @__PURE__ */ __name(async (queueName, x2, opts) => {
    const encoded = MessageWrapper.encode({
      payload: x2,
      queueName
    });
    const sanitizedQueueName = queueName.replace(/[^A-Za-z0-9-_]/g, "-");
    const { messageId } = await send(sanitizedQueueName, encoded, opts);
    return {
      messageId: MessageId.parse(messageId)
    };
  }, "queue");
  const createQueueHandler = /* @__PURE__ */ __name((prefix, handler2) => {
    return handleCallback({
      [`${prefix}*`]: {
        default: /* @__PURE__ */ __name((body, meta) => {
          const { payload, queueName } = MessageWrapper.parse(body);
          return handler2(payload, {
            queueName,
            messageId: MessageId.parse(meta.messageId),
            attempt: meta.deliveryCount
          });
        }, "default")
      }
    });
  }, "createQueueHandler");
  const getDeploymentId = /* @__PURE__ */ __name(async () => {
    const deploymentId = process.env.VERCEL_DEPLOYMENT_ID;
    if (!deploymentId) {
      throw new Error("VERCEL_DEPLOYMENT_ID environment variable is not set");
    }
    return deploymentId;
  }, "getDeploymentId");
  return {
    queue,
    createQueueHandler,
    getDeploymentId
  };
}
__name(createQueue2, "createQueue");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/utils.js
var import_oidc2 = __toESM(require_dist(), 1);
var DEFAULT_RESOLVE_DATA_OPTION2 = "all";
function dateToStringReplacer(_key, value) {
  if (value instanceof Date) {
    return value.toISOString();
  }
  return value;
}
__name(dateToStringReplacer, "dateToStringReplacer");
async function getHttpConfig(config3) {
  const projectConfig = config3?.projectConfig;
  const headers = new Headers(config3?.headers);
  if (projectConfig) {
    headers.set("x-vercel-environment", projectConfig.environment || "production");
    if (projectConfig.projectId) {
      headers.set("x-vercel-project-id", projectConfig.projectId);
    }
    if (projectConfig.teamId) {
      headers.set("x-vercel-team-id", projectConfig.teamId);
    }
  }
  const token = config3?.token ?? await (0, import_oidc2.getVercelOidcToken)();
  if (token) {
    headers.set("Authorization", `Bearer ${token}`);
  }
  let baseUrl = config3?.baseUrl;
  if (!baseUrl) {
    const shouldUseProxy = projectConfig?.projectId && projectConfig?.teamId;
    baseUrl = shouldUseProxy ? `https://api.vercel.com/v1/workflow` : "https://vercel-workflow.com/api";
  }
  return {
    baseUrl,
    headers
  };
}
__name(getHttpConfig, "getHttpConfig");
async function makeRequest({ endpoint: endpoint2, options = {}, config: config3 = {}, schema }) {
  const { baseUrl, headers } = await getHttpConfig(config3);
  headers.set("Content-Type", "application/json");
  const url2 = `${baseUrl}${endpoint2}`;
  const response = await fetch(url2, {
    ...options,
    headers
  });
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    if (process.env.DEBUG === "1") {
      const stringifiedHeaders = Array.from(headers.entries()).map(([key, value]) => `-H "${key}: ${value}"`).join(" ");
      console.error(`Failed to fetch, reproduce with:
curl -X ${options.method} ${stringifiedHeaders} "${url2}"`);
    }
    throw new WorkflowAPIError(errorData.message || `${options.method ?? "GET"} ${endpoint2} -> HTTP ${response.status}: ${response.statusText}`, {
      url: url2,
      status: response.status,
      code: errorData.code
    });
  }
  try {
    const text = await response.text();
    return schema.parse(JSON.parse(text));
  } catch (error45) {
    if (error45 instanceof ZodError) {
      throw new WorkflowAPIError(`Failed to parse server response for ${options.method ?? "GET"} ${endpoint2}: ${error45.message}`, {
        url: url2,
        cause: error45
      });
    }
    throw new WorkflowAPIError(`Failed to parse server response for ${options.method ?? "GET"} ${endpoint2}`, {
      url: url2,
      cause: error45
    });
  }
}
__name(makeRequest, "makeRequest");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/events.js
function filterEventData2(event, resolveData) {
  if (resolveData === "none") {
    const { eventData: _eventData, ...rest } = event;
    return rest;
  }
  return event;
}
__name(filterEventData2, "filterEventData");
var EventWithRefsSchema = zod_default.object({
  eventId: zod_default.string(),
  runId: zod_default.string(),
  eventType: EventTypeSchema,
  correlationId: zod_default.string().optional(),
  eventDataRef: zod_default.any().optional(),
  createdAt: zod_default.coerce.date()
});
async function getWorkflowRunEvents(params, config3) {
  const searchParams = new URLSearchParams();
  const { pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION2 } = params;
  let runId;
  let correlationId;
  if ("runId" in params) {
    runId = params.runId;
  } else {
    correlationId = params.correlationId;
  }
  if (!runId && !correlationId) {
    throw new Error("Either runId or correlationId must be provided");
  }
  if (pagination?.limit) searchParams.set("limit", pagination.limit.toString());
  if (pagination?.cursor) searchParams.set("cursor", pagination.cursor);
  if (pagination?.sortOrder) searchParams.set("sortOrder", pagination.sortOrder);
  if (correlationId) searchParams.set("correlationId", correlationId);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const query = queryString ? `?${queryString}` : "";
  const endpoint2 = correlationId ? `/v1/events${query}` : `/v1/runs/${runId}/events${query}`;
  const response = await makeRequest({
    endpoint: endpoint2,
    options: {
      method: "GET"
    },
    config: config3,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? EventWithRefsSchema : EventSchema)
  });
  return {
    ...response,
    data: response.data.map((event) => filterEventData2(event, resolveData))
  };
}
__name(getWorkflowRunEvents, "getWorkflowRunEvents");
async function createWorkflowRunEvent(id, data, params, config3) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION2;
  const event = await makeRequest({
    endpoint: `/v1/runs/${id}/events`,
    options: {
      method: "POST",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config3,
    schema: EventSchema
  });
  return filterEventData2(event, resolveData);
}
__name(createWorkflowRunEvent, "createWorkflowRunEvent");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/hooks.js
function filterHookData2(hook2, resolveData) {
  if (resolveData === "none") {
    const { metadataRef: _metadataRef, ...rest } = hook2;
    return rest;
  }
  return hook2;
}
__name(filterHookData2, "filterHookData");
var HookWithRefsSchema = HookSchema.omit({
  metadata: true
}).extend({
  metadataRef: zod_default.any().optional()
});
async function listHooks(params, config3) {
  const { runId, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION2 } = params;
  const searchParams = new URLSearchParams();
  if (pagination?.limit) searchParams.set("limit", pagination.limit.toString());
  if (pagination?.cursor) searchParams.set("cursor", pagination.cursor);
  if (pagination?.sortOrder) searchParams.set("sortOrder", pagination.sortOrder);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  if (runId) searchParams.set("runId", runId);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/hooks${queryString ? `?${queryString}` : ""}`;
  const response = await makeRequest({
    endpoint: endpoint2,
    options: {
      method: "GET"
    },
    config: config3,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? HookWithRefsSchema : HookSchema)
  });
  return {
    ...response,
    data: response.data.map((hook2) => filterHookData2(hook2, resolveData))
  };
}
__name(listHooks, "listHooks");
async function getHook(hookId, params, config3) {
  const resolveData = params?.resolveData || "all";
  const endpoint2 = `/v1/hooks/${hookId}`;
  const hook2 = await makeRequest({
    endpoint: endpoint2,
    options: {
      method: "GET"
    },
    config: config3,
    schema: HookSchema
  });
  return filterHookData2(hook2, resolveData);
}
__name(getHook, "getHook");
async function createHook(runId, data, config3) {
  return makeRequest({
    endpoint: `/v1/hooks/create`,
    options: {
      method: "POST",
      body: JSON.stringify({
        runId,
        ...data
      }, dateToStringReplacer)
    },
    config: config3,
    schema: HookSchema
  });
}
__name(createHook, "createHook");
async function getHookByToken(token, config3) {
  return makeRequest({
    endpoint: `/v1/hooks/by-token?token=${encodeURIComponent(token)}`,
    options: {
      method: "GET"
    },
    config: config3,
    schema: HookSchema
  });
}
__name(getHookByToken, "getHookByToken");
async function disposeHook(hookId, config3) {
  return makeRequest({
    endpoint: `/v1/hooks/${hookId}`,
    options: {
      method: "DELETE"
    },
    config: config3,
    schema: HookSchema
  });
}
__name(disposeHook, "disposeHook");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/runs.js
var WorkflowRunWithRefsSchema = WorkflowRunSchema.omit({
  input: true,
  output: true
}).extend({
  // We discard the results of the refs, so we don't care about the type here
  inputRef: external_exports.any().optional(),
  outputRef: external_exports.any().optional(),
  input: external_exports.array(external_exports.any()).optional(),
  output: external_exports.any().optional()
});
function filterRunData2(run, resolveData) {
  if (resolveData === "none") {
    const { inputRef: _inputRef, outputRef: _outputRef, ...rest } = run;
    return {
      ...rest,
      input: [],
      output: void 0
    };
  }
  return run;
}
__name(filterRunData2, "filterRunData");
async function listWorkflowRuns(params = {}, config3) {
  const { workflowName, status, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION2 } = params;
  const searchParams = new URLSearchParams();
  if (workflowName) searchParams.set("workflowName", workflowName);
  if (status) searchParams.set("status", status);
  if (pagination?.limit) searchParams.set("limit", pagination.limit.toString());
  if (pagination?.cursor) searchParams.set("cursor", pagination.cursor);
  if (pagination?.sortOrder) searchParams.set("sortOrder", pagination.sortOrder);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/runs${queryString ? `?${queryString}` : ""}`;
  const response = await makeRequest({
    endpoint: endpoint2,
    options: {
      method: "GET"
    },
    config: config3,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? WorkflowRunWithRefsSchema : WorkflowRunSchema)
  });
  return {
    ...response,
    data: response.data.map((run) => filterRunData2(run, resolveData))
  };
}
__name(listWorkflowRuns, "listWorkflowRuns");
async function createWorkflowRun(data, config3) {
  return makeRequest({
    endpoint: "/v1/runs/create",
    options: {
      method: "POST",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config3,
    schema: WorkflowRunSchema
  });
}
__name(createWorkflowRun, "createWorkflowRun");
async function getWorkflowRun(id, params, config3) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION2;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/runs/${id}${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint: endpoint2,
      options: {
        method: "GET"
      },
      config: config3,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWithRefsSchema : WorkflowRunSchema
    });
    return filterRunData2(run, resolveData);
  } catch (error45) {
    if (error45 instanceof WorkflowAPIError && error45.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error45;
  }
}
__name(getWorkflowRun, "getWorkflowRun");
async function updateWorkflowRun(id, data, config3) {
  try {
    return makeRequest({
      endpoint: `/v1/runs/${id}`,
      options: {
        method: "PUT",
        body: JSON.stringify(data, dateToStringReplacer)
      },
      config: config3,
      schema: WorkflowRunSchema
    });
  } catch (error45) {
    if (error45 instanceof WorkflowAPIError && error45.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error45;
  }
}
__name(updateWorkflowRun, "updateWorkflowRun");
async function cancelWorkflowRun(id, params, config3) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION2;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/runs/${id}/cancel${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint: endpoint2,
      options: {
        method: "PUT"
      },
      config: config3,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWithRefsSchema : WorkflowRunSchema
    });
    return filterRunData2(run, resolveData);
  } catch (error45) {
    if (error45 instanceof WorkflowAPIError && error45.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error45;
  }
}
__name(cancelWorkflowRun, "cancelWorkflowRun");
async function pauseWorkflowRun(id, params, config3) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION2;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/runs/${id}/pause${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint: endpoint2,
      options: {
        method: "PUT"
      },
      config: config3,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWithRefsSchema : WorkflowRunSchema
    });
    return filterRunData2(run, resolveData);
  } catch (error45) {
    if (error45 instanceof WorkflowAPIError && error45.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error45;
  }
}
__name(pauseWorkflowRun, "pauseWorkflowRun");
async function resumeWorkflowRun(id, params, config3) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION2;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/runs/${id}/resume${queryString ? `?${queryString}` : ""}`;
  try {
    const run = await makeRequest({
      endpoint: endpoint2,
      options: {
        method: "PUT"
      },
      config: config3,
      schema: remoteRefBehavior === "lazy" ? WorkflowRunWithRefsSchema : WorkflowRunSchema
    });
    return filterRunData2(run, resolveData);
  } catch (error45) {
    if (error45 instanceof WorkflowAPIError && error45.status === 404) {
      throw new WorkflowRunNotFoundError(id);
    }
    throw error45;
  }
}
__name(resumeWorkflowRun, "resumeWorkflowRun");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/steps.js
var StepWithRefsSchema = StepSchema.omit({
  input: true,
  output: true
}).extend({
  // We discard the results of the refs, so we don't care about the type here
  inputRef: external_exports.any().optional(),
  outputRef: external_exports.any().optional(),
  input: external_exports.array(external_exports.any()).optional(),
  output: external_exports.any().optional()
});
function filterStepData2(step, resolveData) {
  if (resolveData === "none") {
    const { inputRef: _inputRef, outputRef: _outputRef, ...rest } = step;
    return {
      ...rest,
      input: [],
      output: void 0
    };
  }
  return step;
}
__name(filterStepData2, "filterStepData");
async function listWorkflowRunSteps(params, config3) {
  const { runId, pagination, resolveData = DEFAULT_RESOLVE_DATA_OPTION2 } = params;
  const searchParams = new URLSearchParams();
  if (pagination?.cursor) searchParams.set("cursor", pagination.cursor);
  if (pagination?.limit) searchParams.set("limit", pagination.limit.toString());
  if (pagination?.sortOrder) searchParams.set("sortOrder", pagination.sortOrder);
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = `/v1/runs/${runId}/steps${queryString ? `?${queryString}` : ""}`;
  const response = await makeRequest({
    endpoint: endpoint2,
    options: {
      method: "GET"
    },
    config: config3,
    schema: PaginatedResponseSchema(remoteRefBehavior === "lazy" ? StepWithRefsSchema : StepSchema)
  });
  return {
    ...response,
    data: response.data.map((step) => filterStepData2(step, resolveData))
  };
}
__name(listWorkflowRunSteps, "listWorkflowRunSteps");
async function createStep(runId, data, config3) {
  return makeRequest({
    endpoint: `/v1/runs/${runId}/steps`,
    options: {
      method: "POST",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config3,
    schema: StepSchema
  });
}
__name(createStep, "createStep");
async function updateStep(runId, stepId, data, config3) {
  return makeRequest({
    endpoint: `/v1/runs/${runId}/steps/${stepId}`,
    options: {
      method: "PUT",
      body: JSON.stringify(data, dateToStringReplacer)
    },
    config: config3,
    schema: StepSchema
  });
}
__name(updateStep, "updateStep");
async function getStep(runId, stepId, params, config3) {
  const resolveData = params?.resolveData ?? DEFAULT_RESOLVE_DATA_OPTION2;
  const remoteRefBehavior = resolveData === "none" ? "lazy" : "resolve";
  const searchParams = new URLSearchParams();
  searchParams.set("remoteRefBehavior", remoteRefBehavior);
  const queryString = searchParams.toString();
  const endpoint2 = runId ? `/v1/runs/${runId}/steps/${stepId}${queryString ? `?${queryString}` : ""}` : `/v1/steps/${stepId}${queryString ? `?${queryString}` : ""}`;
  const step = await makeRequest({
    endpoint: endpoint2,
    options: {
      method: "GET"
    },
    config: config3,
    schema: remoteRefBehavior === "lazy" ? StepWithRefsSchema : StepSchema
  });
  return filterStepData2(step, resolveData);
}
__name(getStep, "getStep");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/storage.js
function createStorage2(config3) {
  return {
    // Storage interface with namespaced methods
    runs: {
      create: /* @__PURE__ */ __name((data) => createWorkflowRun(data, config3), "create"),
      get: /* @__PURE__ */ __name((id, params) => getWorkflowRun(id, params, config3), "get"),
      update: /* @__PURE__ */ __name((id, data) => updateWorkflowRun(id, data, config3), "update"),
      list: /* @__PURE__ */ __name((params) => listWorkflowRuns(params, config3), "list"),
      cancel: /* @__PURE__ */ __name((id, params) => cancelWorkflowRun(id, params, config3), "cancel"),
      pause: /* @__PURE__ */ __name((id, params) => pauseWorkflowRun(id, params, config3), "pause"),
      resume: /* @__PURE__ */ __name((id, params) => resumeWorkflowRun(id, params, config3), "resume")
    },
    steps: {
      create: /* @__PURE__ */ __name((runId, data) => createStep(runId, data, config3), "create"),
      get: /* @__PURE__ */ __name((runId, stepId, params) => getStep(runId, stepId, params, config3), "get"),
      update: /* @__PURE__ */ __name((runId, stepId, data) => updateStep(runId, stepId, data, config3), "update"),
      list: /* @__PURE__ */ __name((params) => listWorkflowRunSteps(params, config3), "list")
    },
    events: {
      create: /* @__PURE__ */ __name((runId, data, params) => createWorkflowRunEvent(runId, data, params, config3), "create"),
      list: /* @__PURE__ */ __name((params) => getWorkflowRunEvents(params, config3), "list"),
      listByCorrelationId: /* @__PURE__ */ __name((params) => getWorkflowRunEvents(params, config3), "listByCorrelationId")
    },
    hooks: {
      create: /* @__PURE__ */ __name((runId, data) => createHook(runId, data, config3), "create"),
      get: /* @__PURE__ */ __name((hookId, params) => getHook(hookId, params, config3), "get"),
      getByToken: /* @__PURE__ */ __name((token) => getHookByToken(token, config3), "getByToken"),
      list: /* @__PURE__ */ __name((params) => listHooks(params, config3), "list"),
      dispose: /* @__PURE__ */ __name((hookId) => disposeHook(hookId, config3), "dispose")
    }
  };
}
__name(createStorage2, "createStorage");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/streamer.js
function getStreamUrl(name, httpConfig) {
  return new URL(`${httpConfig.baseUrl}/v1/stream/${encodeURIComponent(name)}`);
}
__name(getStreamUrl, "getStreamUrl");
function createStreamer2(config3) {
  return {
    async writeToStream(name, chunk) {
      const httpConfig = await getHttpConfig(config3);
      await fetch(getStreamUrl(name, httpConfig), {
        method: "PUT",
        body: chunk,
        headers: httpConfig.headers,
        duplex: "half"
      });
    },
    async closeStream(name) {
      const httpConfig = await getHttpConfig(config3);
      httpConfig.headers.set("X-Stream-Done", "true");
      await fetch(getStreamUrl(name, httpConfig), {
        method: "PUT",
        headers: httpConfig.headers
      });
    },
    async readFromStream(name, startIndex) {
      const httpConfig = await getHttpConfig(config3);
      const url2 = getStreamUrl(name, httpConfig);
      if (typeof startIndex === "number") {
        url2.searchParams.set("startIndex", String(startIndex));
      }
      const res = await fetch(url2, {
        headers: httpConfig.headers
      });
      if (!res.ok) throw new Error(`Failed to fetch stream: ${res.status}`);
      return res.body;
    }
  };
}
__name(createStreamer2, "createStreamer");

// node_modules/.pnpm/@workflow+world-vercel@4.0.1-beta.2/node_modules/@workflow/world-vercel/dist/index.js
function createVercelWorld(config3) {
  return {
    ...createQueue2(),
    ...createStorage2(config3),
    ...createStreamer2(config3)
  };
}
__name(createVercelWorld, "createVercelWorld");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/runtime/world.js
var require2 = (0, import_node_module.createRequire)(import_node_path4.default.join(process.cwd(), "index.js"));
var worldCache;
var stubbedWorldCache;
function defaultWorld() {
  if (process.env.VERCEL_DEPLOYMENT_ID) {
    return "vercel";
  }
  return "embedded";
}
__name(defaultWorld, "defaultWorld");
var createWorld = /* @__PURE__ */ __name(() => {
  const targetWorld = process.env.WORKFLOW_TARGET_WORLD || defaultWorld();
  if (targetWorld === "vercel") {
    return createVercelWorld({
      baseUrl: process.env.WORKFLOW_VERCEL_PROXY_URL,
      token: process.env.WORKFLOW_VERCEL_AUTH_TOKEN,
      projectConfig: {
        environment: process.env.WORKFLOW_VERCEL_ENV,
        projectId: process.env.WORKFLOW_VERCEL_PROJECT,
        teamId: process.env.WORKFLOW_VERCEL_TEAM
      }
    });
  }
  if (targetWorld === "embedded") {
    return createEmbeddedWorld({
      dataDir: process.env.WORKFLOW_EMBEDDED_DATA_DIR,
      port: process.env.PORT ? Number(process.env.PORT) : void 0
    });
  }
  const mod = require2(targetWorld);
  if (typeof mod === "function") {
    return mod();
  } else if (typeof mod.default === "function") {
    return mod.default();
  } else if (typeof mod.createWorld === "function") {
    return mod.createWorld();
  }
  throw new Error(`Invalid target world module: ${targetWorld}, must export a default function or createWorld function that returns a World instance.`);
}, "createWorld");
var getWorldHandlers = /* @__PURE__ */ __name(() => {
  if (stubbedWorldCache) {
    return stubbedWorldCache;
  }
  const _world = createWorld();
  stubbedWorldCache = _world;
  return {
    createQueueHandler: _world.createQueueHandler
  };
}, "getWorldHandlers");
var getWorld = /* @__PURE__ */ __name(() => {
  if (worldCache) {
    return worldCache;
  }
  worldCache = createWorld();
  return worldCache;
}, "getWorld");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/symbols.js
var WORKFLOW_USE_STEP = Symbol.for("WORKFLOW_USE_STEP");
var WORKFLOW_CREATE_HOOK = Symbol.for("WORKFLOW_CREATE_HOOK");
var WORKFLOW_CONTEXT = Symbol.for("WORKFLOW_CONTEXT");
var WORKFLOW_GET_STREAM_ID = Symbol.for("WORKFLOW_GET_STREAM_ID");
var STREAM_NAME_SYMBOL = Symbol.for("WORKFLOW_STREAM_NAME");
var STREAM_TYPE_SYMBOL = Symbol.for("WORKFLOW_STREAM_TYPE");
var BODY_INIT_SYMBOL = Symbol.for("BODY_INIT");
var WEBHOOK_RESPONSE_WRITABLE = Symbol.for("WEBHOOK_RESPONSE_WRITABLE");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/serialization.js
function getStreamType(stream) {
  try {
    const reader = stream.getReader({
      mode: "byob"
    });
    reader.releaseLock();
    return "bytes";
  } catch {
  }
}
__name(getStreamType, "getStreamType");
function getSerializeStream(reducers) {
  const encoder = new TextEncoder();
  const stream = new TransformStream({
    transform(chunk, controller) {
      try {
        const serialized = stringify(chunk, reducers);
        controller.enqueue(encoder.encode(`${serialized}
`));
      } catch (error45) {
        controller.error(new WorkflowRuntimeError("Failed to serialize stream chunk. Ensure you're passing serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).", {
          slug: "serialization-failed",
          cause: error45
        }));
      }
    }
  });
  return stream;
}
__name(getSerializeStream, "getSerializeStream");
function getDeserializeStream(revivers) {
  const decoder = new TextDecoder();
  let buffer = "";
  const stream = new TransformStream({
    transform(chunk, controller) {
      buffer += decoder.decode(chunk, {
        stream: true
      });
      while (true) {
        const newlineIndex = buffer.indexOf("\n");
        if (newlineIndex === -1) break;
        const line = buffer.slice(0, newlineIndex);
        buffer = buffer.slice(newlineIndex + 1);
        if (line.length > 0) {
          const obj = parse(line, revivers);
          controller.enqueue(obj);
        }
      }
    },
    flush(controller) {
      if (buffer && buffer.length > 0) {
        const obj = parse(buffer, revivers);
        controller.enqueue(obj);
      }
    }
  });
  return stream;
}
__name(getDeserializeStream, "getDeserializeStream");
var WorkflowServerReadableStream = class extends ReadableStream {
  static {
    __name(this, "WorkflowServerReadableStream");
  }
  #reader;
  constructor(name, startIndex) {
    if (typeof name !== "string" || name.length === 0) {
      throw new Error(`"name" is required, got "${name}"`);
    }
    super({
      // @ts-expect-error Not sure why TypeScript is complaining about this
      type: "bytes",
      pull: /* @__PURE__ */ __name(async (controller) => {
        let reader = this.#reader;
        if (!reader) {
          const world = getWorld();
          const stream = await world.readFromStream(name, startIndex);
          reader = this.#reader = stream.getReader();
        }
        if (!reader) {
          controller.error(new Error("Failed to get reader"));
          return;
        }
        const result = await reader.read();
        if (result.done) {
          this.#reader = void 0;
          controller.close();
        } else {
          controller.enqueue(result.value);
        }
      }, "pull")
    });
  }
};
var WorkflowServerWritableStream = class extends WritableStream {
  static {
    __name(this, "WorkflowServerWritableStream");
  }
  constructor(name) {
    if (typeof name !== "string" || name.length === 0) {
      throw new Error(`"name" is required, got "${name}"`);
    }
    const world = getWorld();
    super({
      async write(chunk) {
        await world.writeToStream(name, chunk);
      },
      async close() {
        await world.closeStream(name);
      }
    });
  }
};
function revive(str) {
  return (0, eval)(`(${str})`);
}
__name(revive, "revive");
function getCommonReducers(global2 = globalThis) {
  const abToBase64 = /* @__PURE__ */ __name((value, offset, length) => {
    if (length === 0) return ".";
    return Buffer.from(value, offset, length).toString("base64");
  }, "abToBase64");
  const viewToBase64 = /* @__PURE__ */ __name((value) => abToBase64(value.buffer, value.byteOffset, value.byteLength), "viewToBase64");
  return {
    ArrayBuffer: /* @__PURE__ */ __name((value) => value instanceof global2.ArrayBuffer && abToBase64(value, 0, value.byteLength), "ArrayBuffer"),
    BigInt64Array: /* @__PURE__ */ __name((value) => value instanceof global2.BigInt64Array && viewToBase64(value), "BigInt64Array"),
    BigUint64Array: /* @__PURE__ */ __name((value) => value instanceof global2.BigUint64Array && viewToBase64(value), "BigUint64Array"),
    Date: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.Date)) return false;
      const valid = !Number.isNaN(value.getDate());
      return valid ? value.toISOString() : ".";
    }, "Date"),
    Error: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.Error)) return false;
      return {
        name: value.name,
        message: value.message,
        stack: value.stack
      };
    }, "Error"),
    Float32Array: /* @__PURE__ */ __name((value) => value instanceof global2.Float32Array && viewToBase64(value), "Float32Array"),
    Float64Array: /* @__PURE__ */ __name((value) => value instanceof global2.Float64Array && viewToBase64(value), "Float64Array"),
    Headers: /* @__PURE__ */ __name((value) => value instanceof global2.Headers && Array.from(value), "Headers"),
    Int8Array: /* @__PURE__ */ __name((value) => value instanceof global2.Int8Array && viewToBase64(value), "Int8Array"),
    Int16Array: /* @__PURE__ */ __name((value) => value instanceof global2.Int16Array && viewToBase64(value), "Int16Array"),
    Int32Array: /* @__PURE__ */ __name((value) => value instanceof global2.Int32Array && viewToBase64(value), "Int32Array"),
    Map: /* @__PURE__ */ __name((value) => value instanceof global2.Map && Array.from(value), "Map"),
    RegExp: /* @__PURE__ */ __name((value) => value instanceof global2.RegExp && {
      source: value.source,
      flags: value.flags
    }, "RegExp"),
    Request: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.Request)) return false;
      const data = {
        method: value.method,
        url: value.url,
        headers: value.headers,
        body: value.body,
        duplex: value.duplex
      };
      const responseWritable = value[WEBHOOK_RESPONSE_WRITABLE];
      if (responseWritable) {
        data.responseWritable = responseWritable;
      }
      return data;
    }, "Request"),
    Response: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.Response)) return false;
      return {
        type: value.type,
        url: value.url,
        status: value.status,
        statusText: value.statusText,
        headers: value.headers,
        body: value.body,
        redirected: value.redirected
      };
    }, "Response"),
    Set: /* @__PURE__ */ __name((value) => value instanceof global2.Set && Array.from(value), "Set"),
    URL: /* @__PURE__ */ __name((value) => value instanceof global2.URL && value.href, "URL"),
    URLSearchParams: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.URLSearchParams)) return false;
      if (value.size === 0) return ".";
      return String(value);
    }, "URLSearchParams"),
    Uint8Array: /* @__PURE__ */ __name((value) => value instanceof global2.Uint8Array && viewToBase64(value), "Uint8Array"),
    Uint8ClampedArray: /* @__PURE__ */ __name((value) => value instanceof global2.Uint8ClampedArray && viewToBase64(value), "Uint8ClampedArray"),
    Uint16Array: /* @__PURE__ */ __name((value) => value instanceof global2.Uint16Array && viewToBase64(value), "Uint16Array"),
    Uint32Array: /* @__PURE__ */ __name((value) => value instanceof global2.Uint32Array && viewToBase64(value), "Uint32Array")
  };
}
__name(getCommonReducers, "getCommonReducers");
function getStepReducers(global2 = globalThis, ops) {
  return {
    ...getCommonReducers(global2),
    ReadableStream: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.ReadableStream)) return false;
      if (value.locked) {
        throw new Error("ReadableStream is locked");
      }
      let name = value[STREAM_NAME_SYMBOL];
      let type = value[STREAM_TYPE_SYMBOL];
      if (!name) {
        name = global2.crypto.randomUUID();
        type = getStreamType(value);
        const writable = new WorkflowServerWritableStream(name);
        if (type === "bytes") {
          ops.push(value.pipeTo(writable));
        } else {
          ops.push(value.pipeThrough(getSerializeStream(getStepReducers(global2, ops))).pipeTo(writable));
        }
      }
      const s2 = {
        name
      };
      if (type) s2.type = type;
      return s2;
    }, "ReadableStream"),
    WritableStream: /* @__PURE__ */ __name((value) => {
      if (!(value instanceof global2.WritableStream)) return false;
      let name = value[STREAM_NAME_SYMBOL];
      if (!name) {
        name = global2.crypto.randomUUID();
        ops.push(new WorkflowServerReadableStream(name).pipeThrough(getDeserializeStream(getStepRevivers(global2, ops))).pipeTo(value));
      }
      return {
        name
      };
    }, "WritableStream")
  };
}
__name(getStepReducers, "getStepReducers");
function getCommonRevivers(global2 = globalThis) {
  function reviveArrayBuffer(value) {
    const base643 = value === "." ? "" : value;
    const buffer = Buffer.from(base643, "base64");
    const arrayBuffer = new global2.ArrayBuffer(buffer.length);
    const uint8Array = new global2.Uint8Array(arrayBuffer);
    uint8Array.set(buffer);
    return arrayBuffer;
  }
  __name(reviveArrayBuffer, "reviveArrayBuffer");
  return {
    ArrayBuffer: reviveArrayBuffer,
    BigInt64Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.BigInt64Array(ab);
    }, "BigInt64Array"),
    BigUint64Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.BigUint64Array(ab);
    }, "BigUint64Array"),
    Date: /* @__PURE__ */ __name((value) => new global2.Date(value), "Date"),
    Error: /* @__PURE__ */ __name((value) => {
      const error45 = new global2.Error(value.message);
      error45.name = value.name;
      error45.stack = value.stack;
      return error45;
    }, "Error"),
    Float32Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Float32Array(ab);
    }, "Float32Array"),
    Float64Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Float64Array(ab);
    }, "Float64Array"),
    Headers: /* @__PURE__ */ __name((value) => new global2.Headers(value), "Headers"),
    Int8Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Int8Array(ab);
    }, "Int8Array"),
    Int16Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Int16Array(ab);
    }, "Int16Array"),
    Int32Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Int32Array(ab);
    }, "Int32Array"),
    Map: /* @__PURE__ */ __name((value) => new global2.Map(value), "Map"),
    RegExp: /* @__PURE__ */ __name((value) => new global2.RegExp(value.source, value.flags), "RegExp"),
    Set: /* @__PURE__ */ __name((value) => new global2.Set(value), "Set"),
    URL: /* @__PURE__ */ __name((value) => new global2.URL(value), "URL"),
    URLSearchParams: /* @__PURE__ */ __name((value) => new global2.URLSearchParams(value === "." ? "" : value), "URLSearchParams"),
    Uint8Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint8Array(ab);
    }, "Uint8Array"),
    Uint8ClampedArray: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint8ClampedArray(ab);
    }, "Uint8ClampedArray"),
    Uint16Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint16Array(ab);
    }, "Uint16Array"),
    Uint32Array: /* @__PURE__ */ __name((value) => {
      const ab = reviveArrayBuffer(value);
      return new global2.Uint32Array(ab);
    }, "Uint32Array")
  };
}
__name(getCommonRevivers, "getCommonRevivers");
function getStepRevivers(global2 = globalThis, ops) {
  return {
    ...getCommonRevivers(global2),
    Request: /* @__PURE__ */ __name((value) => {
      const responseWritable = value.responseWritable;
      const request2 = new global2.Request(value.url, {
        method: value.method,
        headers: new global2.Headers(value.headers),
        body: value.body,
        duplex: value.duplex
      });
      if (responseWritable) {
        request2.respondWith = async (response) => {
          const writer = responseWritable.getWriter();
          await writer.write(response);
          await writer.close();
        };
      }
      return request2;
    }, "Request"),
    Response: /* @__PURE__ */ __name((value) => {
      return new global2.Response(value.body, {
        status: value.status,
        statusText: value.statusText,
        headers: new global2.Headers(value.headers)
      });
    }, "Response"),
    ReadableStream: /* @__PURE__ */ __name((value) => {
      if ("bodyInit" in value) {
        const bodyInit = value.bodyInit;
        const response = new global2.Response(bodyInit);
        return response.body;
      }
      const readable = new WorkflowServerReadableStream(value.name);
      if (value.type === "bytes") {
        return readable;
      } else {
        const transform2 = getDeserializeStream(getStepRevivers(global2, ops));
        ops.push(readable.pipeTo(transform2.writable));
        return transform2.readable;
      }
    }, "ReadableStream"),
    WritableStream: /* @__PURE__ */ __name((value) => {
      const serialize = getSerializeStream(getStepReducers(global2, ops));
      ops.push(serialize.readable.pipeTo(new WorkflowServerWritableStream(value.name)));
      return serialize.writable;
    }, "WritableStream")
  };
}
__name(getStepRevivers, "getStepRevivers");
function hydrateStepArguments(value, ops, global2 = globalThis, extraRevivers = {}) {
  const obj = unflatten(value, {
    ...getStepRevivers(global2, ops),
    ...extraRevivers
  });
  return obj;
}
__name(hydrateStepArguments, "hydrateStepArguments");
function dehydrateStepReturnValue(value, ops, global2 = globalThis) {
  try {
    const str = stringify(value, getStepReducers(global2, ops));
    return revive(str);
  } catch (error45) {
    throw new WorkflowRuntimeError(`Failed to serialize step return value. Ensure you're returning serializable types (plain objects, arrays, primitives, Date, RegExp, Map, Set).`, {
      slug: "serialization-failed",
      cause: error45
    });
  }
}
__name(dehydrateStepReturnValue, "dehydrateStepReturnValue");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/telemetry/semantic-conventions.js
function SemanticConvention(name) {
  return (value) => ({
    [name]: value
  });
}
__name(SemanticConvention, "SemanticConvention");
var WorkflowName = SemanticConvention("workflow.name");
var WorkflowOperation = SemanticConvention("workflow.operation");
var WorkflowRunId = SemanticConvention("workflow.run.id");
var WorkflowRunStatus = SemanticConvention("workflow.run.status");
var WorkflowStartedAt = SemanticConvention("workflow.started_at");
var WorkflowEventsCount = SemanticConvention("workflow.events.count");
var WorkflowArgumentsCount = SemanticConvention("workflow.arguments.count");
var WorkflowResultType = SemanticConvention("workflow.result.type");
var WorkflowTracePropagated = SemanticConvention("workflow.trace.propagated");
var WorkflowErrorName = SemanticConvention("workflow.error.name");
var WorkflowErrorMessage = SemanticConvention("workflow.error.message");
var WorkflowStepsCreated = SemanticConvention("workflow.steps.created");
var StepName = SemanticConvention("step.name");
var StepId = SemanticConvention("step.id");
var StepAttempt = SemanticConvention("step.attempt");
var StepStatus = SemanticConvention("step.status");
var StepMaxRetries = SemanticConvention("step.max_retries");
var StepTracePropagated = SemanticConvention("step.trace.propagated");
var StepSkipped = SemanticConvention("step.skipped");
var StepSkipReason = SemanticConvention("step.skip_reason");
var StepArgumentsCount = SemanticConvention("step.arguments.count");
var StepResultType = SemanticConvention("step.result.type");
var StepErrorName = SemanticConvention("step.error.name");
var StepErrorMessage = SemanticConvention("step.error.message");
var StepFatalError = SemanticConvention("step.fatal_error");
var StepRetryExhausted = SemanticConvention("step.retry.exhausted");
var StepRetryTimeoutSeconds = SemanticConvention("step.retry.timeout_seconds");
var StepRetryWillRetry = SemanticConvention("step.retry.will_retry");
var QueueName = SemanticConvention("queue.name");
var DeploymentId = SemanticConvention("deployment.id");
var HookToken = SemanticConvention("workflow.hook.token");
var HookId = SemanticConvention("workflow.hook.id");
var HookFound = SemanticConvention("workflow.hook.found");
var WebhookHandlersTriggered = SemanticConvention("webhook.handlers.triggered");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/util.js
function once2(fn) {
  const result = {
    get value() {
      const value = fn();
      Object.defineProperty(result, "value", {
        value
      });
      return value;
    }
  };
  return result;
}
__name(once2, "once");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/telemetry.js
async function serializeTraceCarrier() {
  const otel = await OtelApi.value;
  if (!otel) return {};
  const carrier = {};
  otel.propagation.inject(otel.context.active(), carrier);
  return carrier;
}
__name(serializeTraceCarrier, "serializeTraceCarrier");
async function deserializeTraceCarrier(traceCarrier) {
  const otel = await OtelApi.value;
  if (!otel) return;
  return otel.propagation.extract(otel.context.active(), traceCarrier);
}
__name(deserializeTraceCarrier, "deserializeTraceCarrier");
async function withTraceContext(traceCarrier, fn) {
  if (!traceCarrier) {
    return fn();
  }
  const otel = await OtelApi.value;
  if (!otel) return fn();
  const extractedContext = await deserializeTraceCarrier(traceCarrier);
  if (!extractedContext) {
    return fn();
  }
  return otel.context.with(extractedContext, async () => await fn());
}
__name(withTraceContext, "withTraceContext");
var OtelApi = once2(async () => {
  try {
    return await Promise.resolve().then(() => __toESM(require_src(), 1));
  } catch {
    console.warn("OpenTelemetry not available, tracing will be disabled");
    return null;
  }
});
var Tracer = once2(async () => {
  const api = await OtelApi.value;
  if (!api) return null;
  return api.trace.getTracer("workflow");
});
async function trace(spanName, ...args) {
  const [tracer, otel] = await Promise.all([
    Tracer.value,
    OtelApi.value
  ]);
  const { fn, opts } = typeof args[0] === "function" ? {
    fn: args[0],
    opts: {}
  } : {
    fn: args[1],
    opts: args[0]
  };
  if (!fn) throw new Error("Function to trace must be provided");
  if (!tracer || !otel) {
    return await fn();
  }
  return tracer.startActiveSpan(spanName, opts, async (span) => {
    try {
      const result = await fn(span);
      span.setStatus({
        code: otel.SpanStatusCode.OK
      });
      return result;
    } catch (e2) {
      span.setStatus({
        code: otel.SpanStatusCode.ERROR,
        message: e2.message
      });
      throw e2;
    } finally {
      span.end();
    }
  });
}
__name(trace, "trace");
async function getActiveSpan() {
  const otel = await OtelApi.value;
  if (!otel) return null;
  return otel.trace.getActiveSpan();
}
__name(getActiveSpan, "getActiveSpan");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/step/context-storage.js
var import_node_async_hooks = require("node:async_hooks");
var contextStorage = /* @__PURE__ */ new import_node_async_hooks.AsyncLocalStorage();

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/step/get-step-metadata.js
function getStepMetadata() {
  const ctx = contextStorage.getStore();
  if (!ctx) {
    throw new Error("`getStepMetadata()` can only be called inside a step function");
  }
  return ctx.stepMetadata;
}
__name(getStepMetadata, "getStepMetadata");

// node_modules/.pnpm/workflow@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0_next@15.0.3_react-dom@19.0.0_react@19_953f1560e5b5900bbc2c66daccad0466/node_modules/workflow/dist/stdlib.js
var import_ms3 = __toESM(require_ms(), 1);
var MAX_SLEEP_DURATION_SECONDS = (0, import_ms3.default)("23h") / 1e3;
async function sleep(param) {
  const { stepStartedAt } = getStepMetadata();
  const durationMs = typeof param === "string" ? (0, import_ms3.default)(param) : param.getTime() - Number(stepStartedAt);
  if (typeof durationMs !== "number" || durationMs < 0) {
    const message = param instanceof Date ? `Invalid sleep date: "${param}". Expected a future date.` : `Invalid sleep duration: "${param}". Expected a valid duration string like "1s", "1m", "1h", etc.`;
    throw new Error(message);
  }
  const endAt = +stepStartedAt + durationMs;
  const now = Date.now();
  if (now < endAt) {
    const remainingSeconds = (endAt - now) / 1e3;
    const retryAfter = Math.min(remainingSeconds, MAX_SLEEP_DURATION_SECONDS);
    throw new RetryableError(`Sleeping for ${(0, import_ms3.default)(retryAfter * 1e3, {
      long: true
    })}`, {
      retryAfter
    });
  }
}
__name(sleep, "sleep");
sleep.maxRetries = Infinity;
async function fetch2(...args) {
  return globalThis.fetch(...args);
}
__name(fetch2, "fetch");
registerStepFunction("step//node_modules/.pnpm/workflow@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0_next@15.0.3_react-dom@19.0.0_react@19_953f1560e5b5900bbc2c66daccad0466/node_modules/workflow/dist/stdlib.js//sleep", sleep);
registerStepFunction("step//node_modules/.pnpm/workflow@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0_next@15.0.3_react-dom@19.0.0_react@19_953f1560e5b5900bbc2c66daccad0466/node_modules/workflow/dist/stdlib.js//fetch", fetch2);

// node_modules/.pnpm/@js-temporal+polyfill@0.4.4/node_modules/@js-temporal/polyfill/dist/index.esm.js
var import_jsbi = __toESM(require_jsbi_cjs(), 1);
var t = {};
function MakeIntrinsicClass(e2, t2) {
  Object.defineProperty(e2.prototype, Symbol.toStringTag, {
    value: t2,
    writable: false,
    enumerable: false,
    configurable: true
  });
  for (const t3 of Object.getOwnPropertyNames(e2)) {
    const r2 = Object.getOwnPropertyDescriptor(e2, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2, t3, r2));
  }
  for (const t3 of Object.getOwnPropertyNames(e2.prototype)) {
    const r2 = Object.getOwnPropertyDescriptor(e2.prototype, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2.prototype, t3, r2));
  }
  DefineIntrinsic(t2, e2), DefineIntrinsic(`${t2}.prototype`, e2.prototype);
}
__name(MakeIntrinsicClass, "MakeIntrinsicClass");
function DefineIntrinsic(e2, r2) {
  const o2 = `%${e2}%`;
  if (void 0 !== t[o2]) throw new Error(`intrinsic ${e2} already exists`);
  t[o2] = r2;
}
__name(DefineIntrinsic, "DefineIntrinsic");
function GetIntrinsic(e2) {
  return t[e2];
}
__name(GetIntrinsic, "GetIntrinsic");
var r;
var o;
var n = "slot-epochNanoSeconds";
var a = "slot-timezone-identifier";
var i = "slot-year";
var s = "slot-month";
var l = "slot-day";
var d = "slot-hour";
var m = "slot-minute";
var c = "slot-second";
var h = "slot-millisecond";
var u = "slot-microsecond";
var T = "slot-nanosecond";
var p = "slot-calendar";
var f = "slot-date-brand";
var y = "slot-year-month-brand";
var I = "slot-month-day-brand";
var S = "slot-cached-instant";
var g = "slot-time-zone";
var w = "slot-years";
var D = "slot-months";
var G = "slot-weeks";
var v = "slot-days";
var C = "slot-hours";
var O = "slot-minutes";
var b = "slot-seconds";
var E = "slot-milliseconds";
var M = "slot-microseconds";
var R = "slot-nanoseconds";
var F = "slot-calendar-identifier";
var Y = /* @__PURE__ */ new WeakMap();
var P = Symbol.for("@@Temporal__GetSlots");
(r = globalThis)[P] || (r[P] = /* @__PURE__ */ __name(function _GetSlots(e2) {
  return Y.get(e2);
}, "_GetSlots"));
var Z = globalThis[P];
var B = Symbol.for("@@Temporal__CreateSlots");
(o = globalThis)[B] || (o[B] = /* @__PURE__ */ __name(function _CreateSlots(e2) {
  Y.set(e2, /* @__PURE__ */ Object.create(null));
}, "_CreateSlots"));
var N = globalThis[B];
function HasSlot(e2, ...t2) {
  if (!e2 || "object" != typeof e2) return false;
  const r2 = Z(e2);
  return !!r2 && t2.every((e3) => e3 in r2);
}
__name(HasSlot, "HasSlot");
function GetSlot(e2, t2) {
  const r2 = Z(e2)?.[t2];
  if (void 0 === r2) throw new TypeError(`Missing internal slot ${t2}`);
  return r2;
}
__name(GetSlot, "GetSlot");
function SetSlot(e2, t2, r2) {
  const o2 = Z(e2);
  if (void 0 === o2) throw new TypeError("Missing slots for the given container");
  if (o2[t2]) throw new TypeError(`${t2} already has set`);
  o2[t2] = r2;
}
__name(SetSlot, "SetSlot");
var j = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
var $ = new RegExp("(?:" + [
  `(?:${j.source})(?:\\/(?:${j.source}))*`,
  "Etc/GMT(?:0|[-+]\\d{1,2})",
  "GMT[-+]?0",
  "EST5EDT",
  "CST6CDT",
  "MST7MDT",
  "PST8PDT",
  /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source
].join("|") + ")");
var k = /(?:[+\u2212-]\d{6}|\d{4})/;
var U = /(?:0[1-9]|1[0-2])/;
var A = /(?:0[1-9]|[12]\d|3[01])/;
var L = new RegExp(`(${k.source})(?:-(${U.source})-(${A.source})|(${U.source})(${A.source}))`);
var x = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
var W = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
var q = new RegExp(`([zZ])|${W.source}?`);
var H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g;
var V = new RegExp([
  `^${L.source}`,
  `(?:(?:T|\\s+)${x.source}(?:${q.source})?)?`,
  `(?:\\[!?(${$.source})\\])?`,
  `((?:${H.source})*)$`
].join(""), "i");
var z = new RegExp([
  `^T?${x.source}`,
  `(?:${q.source})?`,
  `(?:\\[!?${$.source}\\])?`,
  `((?:${H.source})*)$`
].join(""), "i");
var _ = new RegExp(`^(${k.source})-?(${U.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var J = new RegExp(`^(?:--)?(${U.source})-?(${A.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var K = /(\d+)(?:[.,](\d{1,9}))?/;
var X = new RegExp(`(?:${K.source}H)?(?:${K.source}M)?(?:${K.source}S)?`);
var Q = new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${X.source})?$`, "i");
var ee = Array.prototype.includes;
var te = Array.prototype.push;
var re = globalThis.Intl.DateTimeFormat;
var oe = Math.min;
var ne = Math.max;
var ae = Math.abs;
var ie = Math.floor;
var se = Math.sign;
var le = Math.trunc;
var de = Number.isNaN;
var me = Number.isFinite;
var ce = Number;
var he = String;
var ue = Number.MAX_SAFE_INTEGER;
var Te = Object.create;
var pe = Object.getOwnPropertyDescriptor;
var fe = Reflect.apply;
var ye = Reflect.ownKeys;
var Ie = import_jsbi.default.BigInt(0);
var Se = import_jsbi.default.BigInt(1);
var ge = import_jsbi.default.BigInt(60);
var we = import_jsbi.default.BigInt(24);
var De = import_jsbi.default.BigInt(1e3);
var Ge = import_jsbi.default.BigInt(1e6);
var ve = import_jsbi.default.BigInt(1e9);
var Ce = import_jsbi.default.BigInt(-1);
var Oe = import_jsbi.default.multiply(import_jsbi.default.BigInt(3600), ve);
var be = import_jsbi.default.multiply(ge, ve);
var Ee = import_jsbi.default.multiply(Oe, we);
var Me = import_jsbi.default.multiply(import_jsbi.default.BigInt(-86400), import_jsbi.default.BigInt(1e17));
var Re = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), import_jsbi.default.BigInt(1e17));
var Fe = -271821;
var Ye = 275760;
var Pe = import_jsbi.default.multiply(import_jsbi.default.BigInt(-388152), import_jsbi.default.BigInt(1e13));
var Ze = import_jsbi.default.multiply(Ee, import_jsbi.default.BigInt(3660));
var Be = import_jsbi.default.multiply(Ee, import_jsbi.default.BigInt(366));
var Ne = import_jsbi.default.multiply(Ee, import_jsbi.default.BigInt(14));
var je = [
  "iso8601",
  "hebrew",
  "islamic",
  "islamic-umalqura",
  "islamic-tbla",
  "islamic-civil",
  "islamic-rgsa",
  "islamicc",
  "persian",
  "ethiopic",
  "ethioaa",
  "coptic",
  "chinese",
  "dangi",
  "roc",
  "indian",
  "buddhist",
  "japanese",
  "gregory"
];
function isZero(t2) {
  return import_jsbi.default.equal(t2, Ie);
}
__name(isZero, "isZero");
function GetMethod(e2, t2) {
  const r2 = e2[t2];
  if (void 0 !== r2) return r2;
}
__name(GetMethod, "GetMethod");
function Call(e2, t2, r2) {
  const o2 = arguments.length > 2 ? r2 : [];
  return fe(e2, t2, o2);
}
__name(Call, "Call");
function IsObject(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
__name(IsObject, "IsObject");
function ToNumber(e2) {
  if ("bigint" == typeof e2) throw new TypeError("Cannot convert BigInt to number");
  return ce(e2);
}
__name(ToNumber, "ToNumber");
function ToIntegerOrInfinity(e2) {
  const t2 = ToNumber(e2);
  if (de(t2) || 0 === t2) return 0;
  if (!me(t2)) return t2;
  const r2 = ie(ae(t2));
  return 0 === r2 ? 0 : se(t2) * r2;
}
__name(ToIntegerOrInfinity, "ToIntegerOrInfinity");
function IsIntegralNumber(e2) {
  if ("number" != typeof e2 || de(e2) || !me(e2)) return false;
  const t2 = ae(e2);
  return ie(t2) === t2;
}
__name(IsIntegralNumber, "IsIntegralNumber");
function ToString(e2) {
  if ("symbol" == typeof e2) throw new TypeError("Cannot convert a Symbol value to a String");
  return he(e2);
}
__name(ToString, "ToString");
function ToIntegerWithTruncation(e2) {
  const t2 = ToNumber(e2);
  if (0 === t2) return 0;
  if (de(t2) || !me(t2)) throw new RangeError("invalid number value");
  const r2 = le(t2);
  return 0 === r2 ? 0 : r2;
}
__name(ToIntegerWithTruncation, "ToIntegerWithTruncation");
function ToPositiveIntegerWithTruncation(e2, t2) {
  const r2 = ToIntegerWithTruncation(e2);
  if (r2 <= 0) {
    if (void 0 !== t2) throw new RangeError(`property '${t2}' cannot be a a number less than one`);
    throw new RangeError("Cannot convert a number less than one to a positive integer");
  }
  return r2;
}
__name(ToPositiveIntegerWithTruncation, "ToPositiveIntegerWithTruncation");
function ToIntegerIfIntegral(e2) {
  const t2 = ToNumber(e2);
  if (!me(t2)) throw new RangeError("infinity is out of range");
  if (!IsIntegralNumber(t2)) throw new RangeError(`unsupported fractional value ${e2}`);
  return 0 === t2 ? 0 : t2;
}
__name(ToIntegerIfIntegral, "ToIntegerIfIntegral");
function divmod(t2, r2) {
  return {
    quotient: import_jsbi.default.divide(t2, r2),
    remainder: import_jsbi.default.remainder(t2, r2)
  };
}
__name(divmod, "divmod");
function isNegativeJSBI(t2) {
  return import_jsbi.default.lessThan(t2, Ie);
}
__name(isNegativeJSBI, "isNegativeJSBI");
function signJSBI(e2) {
  return isZero(e2) ? 0 : isNegativeJSBI(e2) ? -1 : 1;
}
__name(signJSBI, "signJSBI");
function abs(t2) {
  return import_jsbi.default.lessThan(t2, Ie) ? import_jsbi.default.multiply(t2, Ce) : t2;
}
__name(abs, "abs");
var $e = /* @__PURE__ */ new Map([
  [
    "year",
    ToIntegerWithTruncation
  ],
  [
    "month",
    ToPositiveIntegerWithTruncation
  ],
  [
    "monthCode",
    ToString
  ],
  [
    "day",
    ToPositiveIntegerWithTruncation
  ],
  [
    "hour",
    ToIntegerWithTruncation
  ],
  [
    "minute",
    ToIntegerWithTruncation
  ],
  [
    "second",
    ToIntegerWithTruncation
  ],
  [
    "millisecond",
    ToIntegerWithTruncation
  ],
  [
    "microsecond",
    ToIntegerWithTruncation
  ],
  [
    "nanosecond",
    ToIntegerWithTruncation
  ],
  [
    "years",
    ToIntegerIfIntegral
  ],
  [
    "months",
    ToIntegerIfIntegral
  ],
  [
    "weeks",
    ToIntegerIfIntegral
  ],
  [
    "days",
    ToIntegerIfIntegral
  ],
  [
    "hours",
    ToIntegerIfIntegral
  ],
  [
    "minutes",
    ToIntegerIfIntegral
  ],
  [
    "seconds",
    ToIntegerIfIntegral
  ],
  [
    "milliseconds",
    ToIntegerIfIntegral
  ],
  [
    "microseconds",
    ToIntegerIfIntegral
  ],
  [
    "nanoseconds",
    ToIntegerIfIntegral
  ],
  [
    "era",
    ToString
  ],
  [
    "eraYear",
    ToIntegerOrInfinity
  ],
  [
    "offset",
    ToString
  ]
]);
var ke = /* @__PURE__ */ new Map([
  [
    "hour",
    0
  ],
  [
    "minute",
    0
  ],
  [
    "second",
    0
  ],
  [
    "millisecond",
    0
  ],
  [
    "microsecond",
    0
  ],
  [
    "nanosecond",
    0
  ]
]);
var Ue = [
  [
    "years",
    "year",
    "date"
  ],
  [
    "months",
    "month",
    "date"
  ],
  [
    "weeks",
    "week",
    "date"
  ],
  [
    "days",
    "day",
    "date"
  ],
  [
    "hours",
    "hour",
    "time"
  ],
  [
    "minutes",
    "minute",
    "time"
  ],
  [
    "seconds",
    "second",
    "time"
  ],
  [
    "milliseconds",
    "millisecond",
    "time"
  ],
  [
    "microseconds",
    "microsecond",
    "time"
  ],
  [
    "nanoseconds",
    "nanosecond",
    "time"
  ]
];
var Ae = new Map(Ue.map((e2) => [
  e2[0],
  e2[1]
]));
var Le = new Map(Ue.map(([e2, t2]) => [
  t2,
  e2
]));
var xe = Ue.map(([, e2]) => e2);
var We = Array.from(Ae.keys()).sort();
var qe = /* @__PURE__ */ new Map();
function getIntlDateTimeFormatEnUsForTimeZone(e2) {
  let t2 = qe.get(e2);
  return void 0 === t2 && (t2 = new re("en-us", {
    timeZone: he(e2),
    hour12: false,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), qe.set(e2, t2)), t2;
}
__name(getIntlDateTimeFormatEnUsForTimeZone, "getIntlDateTimeFormatEnUsForTimeZone");
function ToObject(e2) {
  if (null == e2) throw new TypeError(`Expected object not ${e2}`);
  return Object(e2);
}
__name(ToObject, "ToObject");
function CopyDataProperties(e2, t2, r2, o2) {
  if (null == t2) return;
  const n2 = ye(t2);
  for (const a2 of n2) if (!r2.some((e3) => Object.is(e3, a2)) && Object.prototype.propertyIsEnumerable.call(t2, a2)) {
    const r3 = t2[a2];
    if (o2 && o2.some((e3) => Object.is(e3, r3))) continue;
    e2[a2] = r3;
  }
}
__name(CopyDataProperties, "CopyDataProperties");
function IsTemporalInstant(e2) {
  return HasSlot(e2, n) && !HasSlot(e2, g, p);
}
__name(IsTemporalInstant, "IsTemporalInstant");
function IsTemporalTimeZone(e2) {
  return HasSlot(e2, a);
}
__name(IsTemporalTimeZone, "IsTemporalTimeZone");
function IsTemporalCalendar(e2) {
  return HasSlot(e2, F);
}
__name(IsTemporalCalendar, "IsTemporalCalendar");
function IsTemporalDuration(e2) {
  return HasSlot(e2, w, D, v, C, O, b, E, M, R);
}
__name(IsTemporalDuration, "IsTemporalDuration");
function IsTemporalDate(e2) {
  return HasSlot(e2, f);
}
__name(IsTemporalDate, "IsTemporalDate");
function IsTemporalTime(e2) {
  return HasSlot(e2, d, m, c, h, u, T) && !HasSlot(e2, i, s, l);
}
__name(IsTemporalTime, "IsTemporalTime");
function IsTemporalDateTime(e2) {
  return HasSlot(e2, i, s, l, d, m, c, h, u, T);
}
__name(IsTemporalDateTime, "IsTemporalDateTime");
function IsTemporalYearMonth(e2) {
  return HasSlot(e2, y);
}
__name(IsTemporalYearMonth, "IsTemporalYearMonth");
function IsTemporalMonthDay(e2) {
  return HasSlot(e2, I);
}
__name(IsTemporalMonthDay, "IsTemporalMonthDay");
function IsTemporalZonedDateTime(e2) {
  return HasSlot(e2, n, g, p);
}
__name(IsTemporalZonedDateTime, "IsTemporalZonedDateTime");
function RejectTemporalLikeObject(e2) {
  if (HasSlot(e2, p) || HasSlot(e2, g)) throw new TypeError("with() does not support a calendar or timeZone property");
  if (IsTemporalTime(e2)) throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
  if (void 0 !== e2.calendar) throw new TypeError("with() does not support a calendar property");
  if (void 0 !== e2.timeZone) throw new TypeError("with() does not support a timeZone property");
}
__name(RejectTemporalLikeObject, "RejectTemporalLikeObject");
function ParseTemporalTimeZone(e2) {
  const { ianaName: t2, offset: r2, z: o2 } = (/* @__PURE__ */ __name(function ParseTemporalTimeZoneString(e3) {
    if (new RegExp(`^${$.source}$`, "i").test(e3)) return {
      ianaName: e3
    };
    try {
      const t3 = ParseISODateTime(e3);
      if (t3.z || t3.offset || t3.ianaName) return t3;
    } catch {
    }
    throw new RangeError(`Invalid time zone: ${e3}`);
  }, "ParseTemporalTimeZoneString"))(e2);
  if (t2) return GetCanonicalTimeZoneIdentifier(t2);
  if (o2) return "UTC";
  return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r2));
}
__name(ParseTemporalTimeZone, "ParseTemporalTimeZone");
function MaybeFormatCalendarAnnotation(e2, t2) {
  return "never" === t2 ? "" : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e2), t2);
}
__name(MaybeFormatCalendarAnnotation, "MaybeFormatCalendarAnnotation");
function FormatCalendarAnnotation(e2, t2) {
  if ("never" === t2) return "";
  if ("auto" === t2 && "iso8601" === e2) return "";
  return `[${"critical" === t2 ? "!" : ""}u-ca=${e2}]`;
}
__name(FormatCalendarAnnotation, "FormatCalendarAnnotation");
function ParseISODateTime(e2) {
  const t2 = V.exec(e2);
  if (!t2) throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  let r2 = t2[1];
  if ("\u2212" === r2[0] && (r2 = `-${r2.slice(1)}`), "-000000" === r2) throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  const o2 = ToIntegerOrInfinity(r2), n2 = ToIntegerOrInfinity(t2[2] || t2[4]), a2 = ToIntegerOrInfinity(t2[3] || t2[5]), i2 = ToIntegerOrInfinity(t2[6]), s2 = void 0 !== t2[6], l2 = ToIntegerOrInfinity(t2[7] || t2[10]);
  let d2 = ToIntegerOrInfinity(t2[8] || t2[11]);
  60 === d2 && (d2 = 59);
  const m2 = (t2[9] || t2[12]) + "000000000", c2 = ToIntegerOrInfinity(m2.slice(0, 3)), h2 = ToIntegerOrInfinity(m2.slice(3, 6)), u2 = ToIntegerOrInfinity(m2.slice(6, 9));
  let T2, p2 = false;
  if (t2[13]) T2 = void 0, p2 = true;
  else if (t2[14] && t2[15]) {
    const e3 = "-" === t2[14] || "\u2212" === t2[14] ? "-" : "+", r3 = t2[15] || "00", o3 = t2[16] || "00", n3 = t2[17] || "00";
    let a3 = t2[18] || "0";
    if (T2 = `${e3}${r3}:${o3}`, +a3) {
      for (; a3.endsWith("0"); ) a3 = a3.slice(0, -1);
      T2 += `:${n3}.${a3}`;
    } else +n3 && (T2 += `:${n3}`);
    "-00:00" === T2 && (T2 = "+00:00");
  }
  const f2 = t2[19], y2 = t2[20];
  let I2;
  for (const [, e3, t3, r3] of y2.matchAll(H)) if ("u-ca" === t3) void 0 === I2 && (I2 = r3);
  else if ("!" === e3) throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
  return RejectDateTime(o2, n2, a2, i2, l2, d2, c2, h2, u2), {
    year: o2,
    month: n2,
    day: a2,
    hasTime: s2,
    hour: i2,
    minute: l2,
    second: d2,
    millisecond: c2,
    microsecond: h2,
    nanosecond: u2,
    ianaName: f2,
    offset: T2,
    z: p2,
    calendar: I2
  };
}
__name(ParseISODateTime, "ParseISODateTime");
function ParseTemporalYearMonthString(e2) {
  const t2 = _.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    let a3 = t2[1];
    if ("\u2212" === a3[0] && (a3 = `-${a3.slice(1)}`), "-000000" === a3) throw new RangeError(`invalid ISO 8601 string: ${e2}`);
    r2 = ToIntegerOrInfinity(a3), o2 = ToIntegerOrInfinity(t2[2]);
    const i2 = t2[3];
    for (const [, e3, t3, r3] of i2.matchAll(H)) if ("u-ca" === t3) void 0 === n2 && (n2 = r3);
    else if ("!" === e3) throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
    if (void 0 !== n2 && "iso8601" !== n2) throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ year: r2, month: o2, calendar: n2, day: a2, z: t3 } = ParseISODateTime(e2), t3) throw new RangeError("Z designator not supported for PlainYearMonth");
  }
  return {
    year: r2,
    month: o2,
    calendar: n2,
    referenceISODay: a2
  };
}
__name(ParseTemporalYearMonthString, "ParseTemporalYearMonthString");
function ParseTemporalMonthDayString(e2) {
  const t2 = J.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    r2 = ToIntegerOrInfinity(t2[1]), o2 = ToIntegerOrInfinity(t2[2]);
    const e3 = t2[3];
    for (const [, t3, r3, o3] of e3.matchAll(H)) if ("u-ca" === r3) void 0 === n2 && (n2 = o3);
    else if ("!" === t3) throw new RangeError(`Unrecognized annotation: !${r3}=${o3}`);
    if (void 0 !== n2 && "iso8601" !== n2) throw new RangeError("MM-DD format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ month: r2, day: o2, calendar: n2, year: a2, z: t3 } = ParseISODateTime(e2), t3) throw new RangeError("Z designator not supported for PlainMonthDay");
  }
  return {
    month: r2,
    day: o2,
    calendar: n2,
    referenceISOYear: a2
  };
}
__name(ParseTemporalMonthDayString, "ParseTemporalMonthDayString");
function ParseTemporalInstant(e2) {
  let { year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2, offset: m2, z: c2 } = (/* @__PURE__ */ __name(function ParseTemporalInstantString(e3) {
    const t3 = ParseISODateTime(e3);
    if (!t3.z && !t3.offset) throw new RangeError("Temporal.Instant requires a time zone offset");
    return t3;
  }, "ParseTemporalInstantString"))(e2);
  if (!c2 && !m2) throw new RangeError("Temporal.Instant requires a time zone offset");
  const h2 = c2 ? 0 : ParseTimeZoneOffsetString(m2);
  ({ year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2 } = BalanceISODateTime(t2, r2, o2, n2, a2, i2, s2, l2, d2 - h2));
  const u2 = GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2);
  if (null === u2) throw new RangeError("DateTime outside of supported range");
  return u2;
}
__name(ParseTemporalInstant, "ParseTemporalInstant");
function RegulateISODate(e2, t2, r2, o2) {
  let n2 = e2, a2 = t2, i2 = r2;
  switch (o2) {
    case "reject":
      RejectISODate(n2, a2, i2);
      break;
    case "constrain":
      ({ year: n2, month: a2, day: i2 } = ConstrainISODate(n2, a2, i2));
  }
  return {
    year: n2,
    month: a2,
    day: i2
  };
}
__name(RegulateISODate, "RegulateISODate");
function RegulateTime(e2, t2, r2, o2, n2, a2, i2) {
  let s2 = e2, l2 = t2, d2 = r2, m2 = o2, c2 = n2, h2 = a2;
  switch (i2) {
    case "reject":
      RejectTime(s2, l2, d2, m2, c2, h2);
      break;
    case "constrain":
      ({ hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 } = (/* @__PURE__ */ __name(function ConstrainTime(e3, t3, r3, o3, n3, a3) {
        const i3 = ConstrainToRange(e3, 0, 23), s3 = ConstrainToRange(t3, 0, 59), l3 = ConstrainToRange(r3, 0, 59), d3 = ConstrainToRange(o3, 0, 999), m3 = ConstrainToRange(n3, 0, 999), c3 = ConstrainToRange(a3, 0, 999);
        return {
          hour: i3,
          minute: s3,
          second: l3,
          millisecond: d3,
          microsecond: m3,
          nanosecond: c3
        };
      }, "ConstrainTime"))(s2, l2, d2, m2, c2, h2));
  }
  return {
    hour: s2,
    minute: l2,
    second: d2,
    millisecond: m2,
    microsecond: c2,
    nanosecond: h2
  };
}
__name(RegulateTime, "RegulateTime");
function ToTemporalDurationRecord(e2) {
  if (!IsObject(e2)) return (/* @__PURE__ */ __name(function ParseTemporalDurationString(e3) {
    const t3 = Q.exec(e3);
    if (!t3) throw new RangeError(`invalid duration: ${e3}`);
    if (t3.slice(2).every((e4) => void 0 === e4)) throw new RangeError(`invalid duration: ${e3}`);
    const r3 = "-" === t3[1] || "\u2212" === t3[1] ? -1 : 1, o3 = void 0 === t3[2] ? 0 : ToIntegerWithTruncation(t3[2]) * r3, n3 = void 0 === t3[3] ? 0 : ToIntegerWithTruncation(t3[3]) * r3, a3 = void 0 === t3[4] ? 0 : ToIntegerWithTruncation(t3[4]) * r3, i3 = void 0 === t3[5] ? 0 : ToIntegerWithTruncation(t3[5]) * r3, s3 = void 0 === t3[6] ? 0 : ToIntegerWithTruncation(t3[6]) * r3, l3 = t3[7], d3 = t3[8], m3 = t3[9], c3 = t3[10], h3 = t3[11];
    let u2 = 0, T2 = 0, p2 = 0;
    if (void 0 !== l3) {
      if (d3 ?? m3 ?? c3 ?? h3) throw new RangeError("only the smallest unit can be fractional");
      p2 = 3600 * ToIntegerOrInfinity((l3 + "000000000").slice(0, 9)) * r3;
    } else if (u2 = void 0 === d3 ? 0 : ToIntegerWithTruncation(d3) * r3, void 0 !== m3) {
      if (c3 ?? h3) throw new RangeError("only the smallest unit can be fractional");
      p2 = 60 * ToIntegerOrInfinity((m3 + "000000000").slice(0, 9)) * r3;
    } else T2 = void 0 === c3 ? 0 : ToIntegerWithTruncation(c3) * r3, void 0 !== h3 && (p2 = ToIntegerOrInfinity((h3 + "000000000").slice(0, 9)) * r3);
    const f2 = p2 % 1e3, y2 = le(p2 / 1e3) % 1e3, I2 = le(p2 / 1e6) % 1e3;
    return T2 += le(p2 / 1e9) % 60, u2 += le(p2 / 6e10), RejectDuration(o3, n3, a3, i3, s3, u2, T2, I2, y2, f2), {
      years: o3,
      months: n3,
      weeks: a3,
      days: i3,
      hours: s3,
      minutes: u2,
      seconds: T2,
      milliseconds: I2,
      microseconds: y2,
      nanoseconds: f2
    };
  }, "ParseTemporalDurationString"))(ToString(e2));
  if (IsTemporalDuration(e2)) return {
    years: GetSlot(e2, w),
    months: GetSlot(e2, D),
    weeks: GetSlot(e2, G),
    days: GetSlot(e2, v),
    hours: GetSlot(e2, C),
    minutes: GetSlot(e2, O),
    seconds: GetSlot(e2, b),
    milliseconds: GetSlot(e2, E),
    microseconds: GetSlot(e2, M),
    nanoseconds: GetSlot(e2, R)
  };
  const t2 = {
    years: 0,
    months: 0,
    weeks: 0,
    days: 0,
    hours: 0,
    minutes: 0,
    seconds: 0,
    milliseconds: 0,
    microseconds: 0,
    nanoseconds: 0
  };
  let r2 = (/* @__PURE__ */ __name(function ToTemporalPartialDurationRecord(e3) {
    if (!IsObject(e3)) throw new TypeError("invalid duration-like");
    const t3 = {
      years: void 0,
      months: void 0,
      weeks: void 0,
      days: void 0,
      hours: void 0,
      minutes: void 0,
      seconds: void 0,
      milliseconds: void 0,
      microseconds: void 0,
      nanoseconds: void 0
    };
    let r3 = false;
    for (const o3 of We) {
      const n3 = e3[o3];
      void 0 !== n3 && (r3 = true, t3[o3] = ToIntegerIfIntegral(n3));
    }
    if (!r3) throw new TypeError("invalid duration-like");
    return t3;
  }, "ToTemporalPartialDurationRecord"))(e2);
  for (const e3 of We) {
    const o3 = r2[e3];
    void 0 !== o3 && (t2[e3] = o3);
  }
  let { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 } = t2;
  return RejectDuration(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), {
    years: o2,
    months: n2,
    weeks: a2,
    days: i2,
    hours: s2,
    minutes: l2,
    seconds: d2,
    milliseconds: m2,
    microseconds: c2,
    nanoseconds: h2
  };
}
__name(ToTemporalDurationRecord, "ToTemporalDurationRecord");
function ToTemporalOverflow(e2) {
  return void 0 === e2 ? "constrain" : GetOption(e2, "overflow", [
    "constrain",
    "reject"
  ], "constrain");
}
__name(ToTemporalOverflow, "ToTemporalOverflow");
function ToTemporalDisambiguation(e2) {
  return void 0 === e2 ? "compatible" : GetOption(e2, "disambiguation", [
    "compatible",
    "earlier",
    "later",
    "reject"
  ], "compatible");
}
__name(ToTemporalDisambiguation, "ToTemporalDisambiguation");
function ToTemporalRoundingMode(e2, t2) {
  return GetOption(e2, "roundingMode", [
    "ceil",
    "floor",
    "expand",
    "trunc",
    "halfCeil",
    "halfFloor",
    "halfExpand",
    "halfTrunc",
    "halfEven"
  ], t2);
}
__name(ToTemporalRoundingMode, "ToTemporalRoundingMode");
function ToTemporalOffset(e2, t2) {
  return void 0 === e2 ? t2 : GetOption(e2, "offset", [
    "prefer",
    "use",
    "ignore",
    "reject"
  ], t2);
}
__name(ToTemporalOffset, "ToTemporalOffset");
function ToCalendarNameOption(e2) {
  return GetOption(e2, "calendarName", [
    "auto",
    "always",
    "never",
    "critical"
  ], "auto");
}
__name(ToCalendarNameOption, "ToCalendarNameOption");
function ToTemporalRoundingIncrement(e2) {
  let t2 = e2.roundingIncrement;
  if (void 0 === t2) return 1;
  if (t2 = ToNumber(t2), !me(t2)) throw new RangeError("roundingIncrement must be finite");
  const r2 = le(t2);
  if (r2 < 1 || r2 > 1e9) throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${t2}`);
  return r2;
}
__name(ToTemporalRoundingIncrement, "ToTemporalRoundingIncrement");
function ValidateTemporalRoundingIncrement(e2, t2, r2) {
  const o2 = r2 ? t2 : t2 - 1;
  if (e2 > o2) throw new RangeError(`roundingIncrement must be at least 1 and less than ${o2}, not ${e2}`);
  if (t2 % e2 != 0) throw new RangeError(`Rounding increment must divide evenly into ${t2}`);
}
__name(ValidateTemporalRoundingIncrement, "ValidateTemporalRoundingIncrement");
function ToFractionalSecondDigits(e2) {
  const t2 = e2.fractionalSecondDigits;
  if (void 0 === t2) return "auto";
  if ("number" != typeof t2) {
    if ("auto" !== ToString(t2)) throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
    return "auto";
  }
  const r2 = ie(t2);
  if (!me(r2) || r2 < 0 || r2 > 9) throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  return r2;
}
__name(ToFractionalSecondDigits, "ToFractionalSecondDigits");
function ToSecondsStringPrecisionRecord(e2, t2) {
  switch (e2) {
    case "minute":
      return {
        precision: "minute",
        unit: "minute",
        increment: 1
      };
    case "second":
      return {
        precision: 0,
        unit: "second",
        increment: 1
      };
    case "millisecond":
      return {
        precision: 3,
        unit: "millisecond",
        increment: 1
      };
    case "microsecond":
      return {
        precision: 6,
        unit: "microsecond",
        increment: 1
      };
    case "nanosecond":
      return {
        precision: 9,
        unit: "nanosecond",
        increment: 1
      };
  }
  switch (t2) {
    case "auto":
      return {
        precision: t2,
        unit: "nanosecond",
        increment: 1
      };
    case 0:
      return {
        precision: t2,
        unit: "second",
        increment: 1
      };
    case 1:
    case 2:
    case 3:
      return {
        precision: t2,
        unit: "millisecond",
        increment: 10 ** (3 - t2)
      };
    case 4:
    case 5:
    case 6:
      return {
        precision: t2,
        unit: "microsecond",
        increment: 10 ** (6 - t2)
      };
    case 7:
    case 8:
    case 9:
      return {
        precision: t2,
        unit: "nanosecond",
        increment: 10 ** (9 - t2)
      };
    default:
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  }
}
__name(ToSecondsStringPrecisionRecord, "ToSecondsStringPrecisionRecord");
var He = Symbol("~required~");
function GetTemporalUnit(e2, t2, r2, o2, n2 = []) {
  const a2 = [];
  for (const [, e3, t3] of Ue) "datetime" !== r2 && r2 !== t3 || a2.push(e3);
  a2.push(...n2);
  let i2 = o2;
  i2 === He ? i2 = void 0 : void 0 !== i2 && a2.push(i2);
  const s2 = [
    ...a2
  ];
  for (const e3 of a2) {
    const t3 = Le.get(e3);
    void 0 !== t3 && s2.push(t3);
  }
  let l2 = GetOption(e2, t2, s2, i2);
  if (void 0 === l2 && o2 === He) throw new RangeError(`${t2} is required`);
  return Ae.has(l2) ? Ae.get(l2) : l2;
}
__name(GetTemporalUnit, "GetTemporalUnit");
function ToRelativeTemporalObject(e2) {
  const t2 = e2.relativeTo;
  if (void 0 === t2) return t2;
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = "option", p2 = false;
  if (IsObject(t2)) {
    if (IsTemporalZonedDateTime(t2) || IsTemporalDate(t2)) return t2;
    if (IsTemporalDateTime(t2)) return TemporalDateTimeToDate(t2);
    c2 = GetTemporalCalendarSlotValueWithISODefault(t2);
    const e3 = CalendarFields(c2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    e3.push("timeZone", "offset");
    const p3 = PrepareTemporalFields(t2, e3, []), f2 = Te(null);
    f2.overflow = "constrain", { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(c2, p3, f2), u2 = p3.offset, void 0 === u2 && (T2 = "wall"), h2 = p3.timeZone, void 0 !== h2 && (h2 = ToTemporalTimeZoneSlotValue(h2));
  } else {
    let e3, f2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, calendar: c2, ianaName: e3, offset: u2, z: f2 } = ParseISODateTime(ToString(t2)), e3) h2 = ToTemporalTimeZoneSlotValue(e3), f2 ? T2 = "exact" : u2 || (T2 = "wall"), p2 = true;
    else if (f2) throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
    if (c2 || (c2 = "iso8601"), !IsBuiltinCalendar(c2)) throw new RangeError(`invalid calendar identifier ${c2}`);
    c2 = ASCIILowercase(c2);
  }
  if (void 0 === h2) return CreateTemporalDate(r2, o2, n2, c2);
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, T2, "option" === T2 ? ParseTimeZoneOffsetString(u2) : 0, h2, "compatible", "reject", p2), h2, c2);
}
__name(ToRelativeTemporalObject, "ToRelativeTemporalObject");
function DefaultTemporalLargestUnit(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const [m2, c2] of [
    [
      "years",
      e2
    ],
    [
      "months",
      t2
    ],
    [
      "weeks",
      r2
    ],
    [
      "days",
      o2
    ],
    [
      "hours",
      n2
    ],
    [
      "minutes",
      a2
    ],
    [
      "seconds",
      i2
    ],
    [
      "milliseconds",
      s2
    ],
    [
      "microseconds",
      l2
    ],
    [
      "nanoseconds",
      d2
    ]
  ]) if (0 !== c2) return Ae.get(m2);
  return "nanosecond";
}
__name(DefaultTemporalLargestUnit, "DefaultTemporalLargestUnit");
function LargerOfTwoTemporalUnits(e2, t2) {
  return xe.indexOf(e2) > xe.indexOf(t2) ? t2 : e2;
}
__name(LargerOfTwoTemporalUnits, "LargerOfTwoTemporalUnits");
function PrepareTemporalFields(e2, t2, r2, { emptySourceErrorMessage: o2 } = {
  emptySourceErrorMessage: "no supported properties found"
}) {
  const n2 = Te(null);
  let a2 = false;
  t2.sort();
  for (const o3 of t2) {
    let t3 = e2[o3];
    if (void 0 !== t3) a2 = true, $e.has(o3) && (t3 = $e.get(o3)(t3)), n2[o3] = t3;
    else if ("partial" !== r2) {
      if (ee.call(r2, o3)) throw new TypeError(`required property '${o3}' missing or undefined`);
      t3 = ke.get(o3), n2[o3] = t3;
    }
  }
  if ("partial" === r2 && !a2) throw new TypeError(o2);
  return n2;
}
__name(PrepareTemporalFields, "PrepareTemporalFields");
function ToTemporalTimeRecord(e2, t2 = "complete") {
  const r2 = [
    "hour",
    "microsecond",
    "millisecond",
    "minute",
    "nanosecond",
    "second"
  ], o2 = PrepareTemporalFields(e2, r2, "partial", {
    emptySourceErrorMessage: "invalid time-like"
  }), n2 = {};
  for (const e3 of r2) {
    const r3 = pe(o2, e3);
    void 0 !== r3 ? n2[e3] = r3.value : "complete" === t2 && (n2[e3] = 0);
  }
  return n2;
}
__name(ToTemporalTimeRecord, "ToTemporalTimeRecord");
function ToTemporalDate(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalDate(r2)) return r2;
    if (IsTemporalZonedDateTime(r2) && (ToTemporalOverflow(t2), r2 = GetPlainDateTimeFor(GetSlot(r2, g), GetSlot(r2, S), GetSlot(r2, p))), IsTemporalDateTime(r2)) return ToTemporalOverflow(t2), CreateTemporalDate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, p));
    const e3 = GetTemporalCalendarSlotValueWithISODefault(r2);
    return CalendarDateFromFields(e3, PrepareTemporalFields(r2, CalendarFields(e3, [
      "day",
      "month",
      "monthCode",
      "year"
    ]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: o2, month: n2, day: a2, calendar: d2, z: m2 } = (/* @__PURE__ */ __name(function ParseTemporalDateString(e3) {
    return ParseISODateTime(e3);
  }, "ParseTemporalDateString"))(ToString(r2));
  if (m2) throw new RangeError("Z designator not supported for PlainDate");
  if (d2 || (d2 = "iso8601"), !IsBuiltinCalendar(d2)) throw new RangeError(`invalid calendar identifier ${d2}`);
  return d2 = ASCIILowercase(d2), CreateTemporalDate(o2, n2, a2, d2);
}
__name(ToTemporalDate, "ToTemporalDate");
function InterpretTemporalDateTimeFields(e2, t2, r2) {
  let { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = ToTemporalTimeRecord(t2);
  const h2 = ToTemporalOverflow(r2), u2 = CalendarDateFromFields(e2, t2, r2), T2 = GetSlot(u2, i), p2 = GetSlot(u2, s), f2 = GetSlot(u2, l);
  return { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = RegulateTime(o2, n2, a2, d2, m2, c2, h2), {
    year: T2,
    month: p2,
    day: f2,
    hour: o2,
    minute: n2,
    second: a2,
    millisecond: d2,
    microsecond: m2,
    nanosecond: c2
  };
}
__name(InterpretTemporalDateTimeFields, "InterpretTemporalDateTimeFields");
function ToTemporalDateTime(e2, t2) {
  let r2, o2, n2, a2, d2, m2, c2, h2, u2, T2;
  if (IsObject(e2)) {
    if (IsTemporalDateTime(e2)) return e2;
    if (IsTemporalZonedDateTime(e2)) return ToTemporalOverflow(t2), GetPlainDateTimeFor(GetSlot(e2, g), GetSlot(e2, S), GetSlot(e2, p));
    if (IsTemporalDate(e2)) return ToTemporalOverflow(t2), CreateTemporalDateTime(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), 0, 0, 0, 0, 0, 0, GetSlot(e2, p));
    T2 = GetTemporalCalendarSlotValueWithISODefault(e2);
    const f2 = PrepareTemporalFields(e2, CalendarFields(T2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]), []);
    ({ year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2 } = InterpretTemporalDateTimeFields(T2, f2, t2));
  } else {
    let i2;
    if (ToTemporalOverflow(t2), { year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2, calendar: T2, z: i2 } = (/* @__PURE__ */ __name(function ParseTemporalDateTimeString(e3) {
      return ParseISODateTime(e3);
    }, "ParseTemporalDateTimeString"))(ToString(e2)), i2) throw new RangeError("Z designator not supported for PlainDateTime");
    if (RejectDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2), T2 || (T2 = "iso8601"), !IsBuiltinCalendar(T2)) throw new RangeError(`invalid calendar identifier ${T2}`);
    T2 = ASCIILowercase(T2);
  }
  return CreateTemporalDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2, T2);
}
__name(ToTemporalDateTime, "ToTemporalDateTime");
function ToTemporalDuration(e2) {
  if (IsTemporalDuration(e2)) return e2;
  let { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = ToTemporalDurationRecord(e2);
  return new (GetIntrinsic("%Temporal.Duration%"))(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
}
__name(ToTemporalDuration, "ToTemporalDuration");
function ToTemporalInstant(e2) {
  if (IsTemporalInstant(e2)) return e2;
  if (IsTemporalZonedDateTime(e2)) {
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, n));
  }
  const t2 = ParseTemporalInstant(ToString(e2));
  return new (GetIntrinsic("%Temporal.Instant%"))(t2);
}
__name(ToTemporalInstant, "ToTemporalInstant");
function ToTemporalMonthDay(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalMonthDay(r2)) return r2;
    let e3, o3;
    if (HasSlot(r2, p)) e3 = GetSlot(r2, p), o3 = false;
    else {
      let t3 = r2.calendar;
      o3 = void 0 === t3, void 0 === t3 && (t3 = "iso8601"), e3 = ToTemporalCalendarSlotValue(t3);
    }
    const n3 = PrepareTemporalFields(r2, CalendarFields(e3, [
      "day",
      "month",
      "monthCode",
      "year"
    ]), []);
    return o3 && void 0 !== n3.month && void 0 === n3.monthCode && void 0 === n3.year && (n3.year = 1972), CalendarMonthDayFromFields(e3, n3, t2);
  }
  ToTemporalOverflow(t2);
  let { month: o2, day: n2, referenceISOYear: a2, calendar: i2 } = ParseTemporalMonthDayString(ToString(r2));
  if (void 0 === i2 && (i2 = "iso8601"), !IsBuiltinCalendar(i2)) throw new RangeError(`invalid calendar identifier ${i2}`);
  if (i2 = ASCIILowercase(i2), void 0 === a2) return RejectISODate(1972, o2, n2), CreateTemporalMonthDay(o2, n2, i2);
  return CalendarMonthDayFromFields(i2, CreateTemporalMonthDay(o2, n2, i2, a2));
}
__name(ToTemporalMonthDay, "ToTemporalMonthDay");
function ToTemporalTime(e2, t2 = "constrain") {
  let r2, o2, n2, a2, i2, s2, l2 = e2;
  if (IsObject(l2)) {
    if (IsTemporalTime(l2)) return l2;
    if (IsTemporalZonedDateTime(l2) && (l2 = GetPlainDateTimeFor(GetSlot(l2, g), GetSlot(l2, S), GetSlot(l2, p))), IsTemporalDateTime(l2)) {
      return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(l2, d), GetSlot(l2, m), GetSlot(l2, c), GetSlot(l2, h), GetSlot(l2, u), GetSlot(l2, T));
    }
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = ToTemporalTimeRecord(l2)), { hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = RegulateTime(r2, o2, n2, a2, i2, s2, t2);
  } else ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = (/* @__PURE__ */ __name(function ParseTemporalTimeString(e3) {
    const t3 = z.exec(e3);
    let r3, o3, n3, a3, i3, s3, l3;
    if (t3) {
      r3 = ToIntegerOrInfinity(t3[1]), o3 = ToIntegerOrInfinity(t3[2] || t3[5]), n3 = ToIntegerOrInfinity(t3[3] || t3[6]), 60 === n3 && (n3 = 59);
      const e4 = (t3[4] || t3[7]) + "000000000";
      a3 = ToIntegerOrInfinity(e4.slice(0, 3)), i3 = ToIntegerOrInfinity(e4.slice(3, 6)), s3 = ToIntegerOrInfinity(e4.slice(6, 9)), l3 = t3[14];
      for (const [, e5, t4, r4] of l3.matchAll(H)) if ("u-ca" !== t4 && "!" === e5) throw new RangeError(`Unrecognized annotation: !${t4}=${r4}`);
      if (t3[8]) throw new RangeError("Z designator not supported for PlainTime");
    } else {
      let t4, l4;
      if ({ hasTime: l4, hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3, z: t4 } = ParseISODateTime(e3), !l4) throw new RangeError(`time is missing in string: ${e3}`);
      if (t4) throw new RangeError("Z designator not supported for PlainTime");
    }
    if (/[tT ][0-9][0-9]/.test(e3)) return {
      hour: r3,
      minute: o3,
      second: n3,
      millisecond: a3,
      microsecond: i3,
      nanosecond: s3
    };
    try {
      const { month: t4, day: r4 } = ParseTemporalMonthDayString(e3);
      RejectISODate(1972, t4, r4);
    } catch {
      try {
        const { year: t4, month: r4 } = ParseTemporalYearMonthString(e3);
        RejectISODate(t4, r4, 1);
      } catch {
        return {
          hour: r3,
          minute: o3,
          second: n3,
          millisecond: a3,
          microsecond: i3,
          nanosecond: s3
        };
      }
    }
    throw new RangeError(`invalid ISO 8601 time-only string ${e3}; may need a T prefix`);
  }, "ParseTemporalTimeString"))(ToString(l2))), RejectTime(r2, o2, n2, a2, i2, s2);
  return new (GetIntrinsic("%Temporal.PlainTime%"))(r2, o2, n2, a2, i2, s2);
}
__name(ToTemporalTime, "ToTemporalTime");
function ToTemporalYearMonth(e2, t2) {
  if (IsObject(e2)) {
    if (IsTemporalYearMonth(e2)) return e2;
    const r3 = GetTemporalCalendarSlotValueWithISODefault(e2);
    return CalendarYearMonthFromFields(r3, PrepareTemporalFields(e2, CalendarFields(r3, [
      "month",
      "monthCode",
      "year"
    ]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: r2, month: o2, referenceISODay: n2, calendar: a2 } = ParseTemporalYearMonthString(ToString(e2));
  if (void 0 === a2 && (a2 = "iso8601"), !IsBuiltinCalendar(a2)) throw new RangeError(`invalid calendar identifier ${a2}`);
  if (a2 = ASCIILowercase(a2), void 0 === n2) return RejectISODate(r2, o2, 1), CreateTemporalYearMonth(r2, o2, a2);
  return CalendarYearMonthFromFields(a2, CreateTemporalYearMonth(r2, o2, a2, n2));
}
__name(ToTemporalYearMonth, "ToTemporalYearMonth");
function InterpretISODateTimeOffset(t2, r2, o2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2) {
  const I2 = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t2, r2, o2, i2, s2, l2, d2, m2, c2);
  if ("wall" === h2 || "ignore" === f2) {
    return GetSlot(GetInstantFor(T2, I2, p2), n);
  }
  if ("exact" === h2 || "use" === f2) {
    const n2 = GetUTCEpochNanoseconds(t2, r2, o2, i2, s2, l2, d2, m2, c2);
    if (null === n2) throw new RangeError("ZonedDateTime outside of supported range");
    return import_jsbi.default.subtract(n2, import_jsbi.default.BigInt(u2));
  }
  const S2 = GetPossibleInstantsFor(T2, I2);
  for (const t3 of S2) {
    const r3 = GetOffsetNanosecondsFor(T2, t3), o3 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(r3), be, "halfExpand"));
    if (r3 === u2 || y2 && o3 === u2) return GetSlot(t3, n);
  }
  if ("reject" === f2) {
    const e2 = FormatTimeZoneOffsetString(u2), t3 = IsTemporalTimeZone(T2) ? GetSlot(T2, a) : "time zone";
    throw new RangeError(`Offset ${e2} is invalid for ${I2.toString()} in ${t3}`);
  }
  return GetSlot(DisambiguatePossibleInstants(S2, T2, I2, p2), n);
}
__name(InterpretISODateTimeOffset, "InterpretISODateTimeOffset");
function ToTemporalZonedDateTime(e2, t2) {
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2 = false, y2 = "option";
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2)) return e2;
    u2 = GetTemporalCalendarSlotValueWithISODefault(e2);
    const f3 = CalendarFields(u2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    f3.push("timeZone", "offset");
    const I3 = PrepareTemporalFields(e2, f3, [
      "timeZone"
    ]);
    c2 = ToTemporalTimeZoneSlotValue(I3.timeZone), h2 = I3.offset, void 0 === h2 && (y2 = "wall"), T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(u2, I3, t2);
  } else {
    let I3, S2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, ianaName: I3, offset: h2, z: S2, calendar: u2 } = (/* @__PURE__ */ __name(function ParseTemporalZonedDateTimeString(e3) {
      const t3 = ParseISODateTime(e3);
      if (!t3.ianaName) throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
      return t3;
    }, "ParseTemporalZonedDateTimeString"))(ToString(e2)), c2 = ToTemporalTimeZoneSlotValue(I3), S2 ? y2 = "exact" : h2 || (y2 = "wall"), u2 || (u2 = "iso8601"), !IsBuiltinCalendar(u2)) throw new RangeError(`invalid calendar identifier ${u2}`);
    u2 = ASCIILowercase(u2), f2 = true, T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), ToTemporalOverflow(t2);
  }
  let I2 = 0;
  "option" === y2 && (I2 = ParseTimeZoneOffsetString(h2));
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, y2, I2, c2, T2, p2, f2), c2, u2);
}
__name(ToTemporalZonedDateTime, "ToTemporalZonedDateTime");
function CreateTemporalDateSlots(e2, t2, r2, o2, n2) {
  RejectISODate(t2, r2, o2), RejectDateRange(t2, r2, o2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, o2), SetSlot(e2, p, n2), SetSlot(e2, f, true);
}
__name(CreateTemporalDateSlots, "CreateTemporalDateSlots");
function CreateTemporalDate(e2, t2, r2, o2 = "iso8601") {
  const n2 = GetIntrinsic("%Temporal.PlainDate%"), a2 = Te(n2.prototype);
  return CreateTemporalDateSlots(a2, e2, t2, r2, o2), a2;
}
__name(CreateTemporalDate, "CreateTemporalDate");
function CreateTemporalDateTimeSlots(e2, t2, r2, o2, n2, a2, f2, y2, I2, S2, g2) {
  RejectDateTime(t2, r2, o2, n2, a2, f2, y2, I2, S2), RejectDateTimeRange(t2, r2, o2, n2, a2, f2, y2, I2, S2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, o2), SetSlot(e2, d, n2), SetSlot(e2, m, a2), SetSlot(e2, c, f2), SetSlot(e2, h, y2), SetSlot(e2, u, I2), SetSlot(e2, T, S2), SetSlot(e2, p, g2);
}
__name(CreateTemporalDateTimeSlots, "CreateTemporalDateTimeSlots");
function CreateTemporalDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2 = "iso8601") {
  const m2 = GetIntrinsic("%Temporal.PlainDateTime%"), c2 = Te(m2.prototype);
  return CreateTemporalDateTimeSlots(c2, e2, t2, r2, o2, n2, a2, i2, s2, l2, d2), c2;
}
__name(CreateTemporalDateTime, "CreateTemporalDateTime");
function CreateTemporalMonthDaySlots(e2, t2, r2, o2, n2) {
  RejectISODate(n2, t2, r2), RejectDateRange(n2, t2, r2), N(e2), SetSlot(e2, s, t2), SetSlot(e2, l, r2), SetSlot(e2, i, n2), SetSlot(e2, p, o2), SetSlot(e2, I, true);
}
__name(CreateTemporalMonthDaySlots, "CreateTemporalMonthDaySlots");
function CreateTemporalMonthDay(e2, t2, r2 = "iso8601", o2 = 1972) {
  const n2 = GetIntrinsic("%Temporal.PlainMonthDay%"), a2 = Te(n2.prototype);
  return CreateTemporalMonthDaySlots(a2, e2, t2, r2, o2), a2;
}
__name(CreateTemporalMonthDay, "CreateTemporalMonthDay");
function CreateTemporalYearMonthSlots(e2, t2, r2, o2, n2) {
  RejectISODate(t2, r2, n2), (/* @__PURE__ */ __name(function RejectYearMonthRange(e3, t3) {
    RejectToRange(e3, Fe, Ye), e3 === Fe ? RejectToRange(t3, 4, 12) : e3 === Ye && RejectToRange(t3, 1, 9);
  }, "RejectYearMonthRange"))(t2, r2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, n2), SetSlot(e2, p, o2), SetSlot(e2, y, true);
}
__name(CreateTemporalYearMonthSlots, "CreateTemporalYearMonthSlots");
function CreateTemporalYearMonth(e2, t2, r2 = "iso8601", o2 = 1) {
  const n2 = GetIntrinsic("%Temporal.PlainYearMonth%"), a2 = Te(n2.prototype);
  return CreateTemporalYearMonthSlots(a2, e2, t2, r2, o2), a2;
}
__name(CreateTemporalYearMonth, "CreateTemporalYearMonth");
function CreateTemporalZonedDateTimeSlots(e2, t2, r2, o2) {
  ValidateEpochNanoseconds(t2), N(e2), SetSlot(e2, n, t2), SetSlot(e2, g, r2), SetSlot(e2, p, o2);
  const a2 = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, n));
  SetSlot(e2, S, a2);
}
__name(CreateTemporalZonedDateTimeSlots, "CreateTemporalZonedDateTimeSlots");
function CreateTemporalZonedDateTime(e2, t2, r2 = "iso8601") {
  const o2 = GetIntrinsic("%Temporal.ZonedDateTime%"), n2 = Te(o2.prototype);
  return CreateTemporalZonedDateTimeSlots(n2, e2, t2, r2), n2;
}
__name(CreateTemporalZonedDateTime, "CreateTemporalZonedDateTime");
function CalendarFields(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "fields"), e2, [
    t2
  ]), o2 = [];
  for (const e3 of r2) {
    if ("string" != typeof e3) throw new TypeError("bad return from calendar.fields()");
    te.call(o2, e3);
  }
  return o2;
}
__name(CalendarFields, "CalendarFields");
function CalendarMergeFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"), o3, [
      t2,
      r2
    ]);
  }
  const o2 = Call(GetMethod(e2, "mergeFields"), e2, [
    t2,
    r2
  ]);
  if (!IsObject(o2)) throw new TypeError("bad return from calendar.mergeFields()");
  return o2;
}
__name(CalendarMergeFields, "CalendarMergeFields");
function CalendarDateAdd(e2, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e2) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"), n3, [
      t2,
      r2,
      o2
    ]);
  }
  void 0 === a2 && (a2 = GetMethod(e2, "dateAdd"));
  const i2 = fe(a2, e2, [
    t2,
    r2,
    o2
  ]);
  if (!IsTemporalDate(i2)) throw new TypeError("invalid result");
  return i2;
}
__name(CalendarDateAdd, "CalendarDateAdd");
function CalendarDateUntil(e2, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e2) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"), n3, [
      t2,
      r2,
      o2
    ]);
  }
  void 0 === a2 && (a2 = GetMethod(e2, "dateUntil"));
  const i2 = fe(a2, e2, [
    t2,
    r2,
    o2
  ]);
  if (!IsTemporalDuration(i2)) throw new TypeError("invalid result");
  return i2;
}
__name(CalendarDateUntil, "CalendarDateUntil");
function CalendarYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"), r3, [
      t2
    ]);
  }
  let r2 = Call(GetMethod(e2, "year"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar year result must be an integer");
  if (!IsIntegralNumber(r2)) throw new RangeError("calendar year result must be an integer");
  return r2;
}
__name(CalendarYear, "CalendarYear");
function CalendarMonth(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"), r3, [
      t2
    ]);
  }
  let r2 = Call(GetMethod(e2, "month"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar month result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar month result must be a positive integer");
  return r2;
}
__name(CalendarMonth, "CalendarMonth");
function CalendarMonthCode(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"), r3, [
      t2
    ]);
  }
  let r2 = Call(GetMethod(e2, "monthCode"), e2, [
    t2
  ]);
  if ("string" != typeof r2) throw new TypeError("calendar monthCode result must be a string");
  return r2;
}
__name(CalendarMonthCode, "CalendarMonthCode");
function CalendarDay(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "day"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar day result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar day result must be a positive integer");
  return r2;
}
__name(CalendarDay, "CalendarDay");
function CalendarEra(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), r3, [
      t2
    ]);
  }
  let r2 = Call(GetMethod(e2, "era"), e2, [
    t2
  ]);
  if (void 0 === r2) return r2;
  if ("string" != typeof r2) throw new TypeError("calendar era result must be a string or undefined");
  return r2;
}
__name(CalendarEra, "CalendarEra");
function CalendarEraYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"), r3, [
      t2
    ]);
  }
  let r2 = Call(GetMethod(e2, "eraYear"), e2, [
    t2
  ]);
  if (void 0 === r2) return r2;
  if ("number" != typeof r2) throw new TypeError("calendar eraYear result must be an integer or undefined");
  if (!IsIntegralNumber(r2)) throw new RangeError("calendar eraYear result must be an integer or undefined");
  return r2;
}
__name(CalendarEraYear, "CalendarEraYear");
function CalendarDayOfWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "dayOfWeek"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar dayOfWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar dayOfWeek result must be a positive integer");
  return r2;
}
__name(CalendarDayOfWeek, "CalendarDayOfWeek");
function CalendarDayOfYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "dayOfYear"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar dayOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar dayOfYear result must be a positive integer");
  return r2;
}
__name(CalendarDayOfYear, "CalendarDayOfYear");
function CalendarWeekOfYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "weekOfYear"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar weekOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar weekOfYear result must be a positive integer");
  return r2;
}
__name(CalendarWeekOfYear, "CalendarWeekOfYear");
function CalendarYearOfWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "yearOfWeek"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar yearOfWeek result must be an integer");
  if (!IsIntegralNumber(r2)) throw new RangeError("calendar yearOfWeek result must be an integer");
  return r2;
}
__name(CalendarYearOfWeek, "CalendarYearOfWeek");
function CalendarDaysInWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "daysInWeek"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar daysInWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar daysInWeek result must be a positive integer");
  return r2;
}
__name(CalendarDaysInWeek, "CalendarDaysInWeek");
function CalendarDaysInMonth(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "daysInMonth"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar daysInMonth result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar daysInMonth result must be a positive integer");
  return r2;
}
__name(CalendarDaysInMonth, "CalendarDaysInMonth");
function CalendarDaysInYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "daysInYear"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar daysInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar daysInYear result must be a positive integer");
  return r2;
}
__name(CalendarDaysInYear, "CalendarDaysInYear");
function CalendarMonthsInYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "monthsInYear"), e2, [
    t2
  ]);
  if ("number" != typeof r2) throw new TypeError("calendar monthsInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1) throw new RangeError("calendar monthsInYear result must be a positive integer");
  return r2;
}
__name(CalendarMonthsInYear, "CalendarMonthsInYear");
function CalendarInLeapYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"), r3, [
      t2
    ]);
  }
  const r2 = Call(GetMethod(e2, "inLeapYear"), e2, [
    t2
  ]);
  if ("boolean" != typeof r2) throw new TypeError("calendar inLeapYear result must be a boolean");
  return r2;
}
__name(CalendarInLeapYear, "CalendarInLeapYear");
function ToTemporalCalendarSlotValue(e2) {
  if (IsObject(e2)) {
    if (HasSlot(e2, p)) return GetSlot(e2, p);
    if (!(/* @__PURE__ */ __name(function ObjectImplementsTemporalCalendarProtocol(e3) {
      return !!IsTemporalCalendar(e3) || "dateAdd" in e3 && "dateFromFields" in e3 && "dateUntil" in e3 && "day" in e3 && "dayOfWeek" in e3 && "dayOfYear" in e3 && "daysInMonth" in e3 && "daysInWeek" in e3 && "daysInYear" in e3 && "fields" in e3 && "id" in e3 && "inLeapYear" in e3 && "mergeFields" in e3 && "month" in e3 && "monthCode" in e3 && "monthDayFromFields" in e3 && "monthsInYear" in e3 && "weekOfYear" in e3 && "year" in e3 && "yearMonthFromFields" in e3 && "yearOfWeek" in e3;
    }, "ObjectImplementsTemporalCalendarProtocol"))(e2)) throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
    return e2;
  }
  const t2 = ToString(e2);
  if (IsBuiltinCalendar(t2)) return ASCIILowercase(t2);
  let r2;
  try {
    ({ calendar: r2 } = ParseISODateTime(t2));
  } catch {
    try {
      ({ calendar: r2 } = ParseTemporalYearMonthString(t2));
    } catch {
      ({ calendar: r2 } = ParseTemporalMonthDayString(t2));
    }
  }
  if (r2 || (r2 = "iso8601"), !IsBuiltinCalendar(r2)) throw new RangeError(`invalid calendar identifier ${r2}`);
  return ASCIILowercase(r2);
}
__name(ToTemporalCalendarSlotValue, "ToTemporalCalendarSlotValue");
function GetTemporalCalendarSlotValueWithISODefault(e2) {
  if (HasSlot(e2, p)) return GetSlot(e2, p);
  const { calendar: t2 } = e2;
  return void 0 === t2 ? "iso8601" : ToTemporalCalendarSlotValue(t2);
}
__name(GetTemporalCalendarSlotValueWithISODefault, "GetTemporalCalendarSlotValueWithISODefault");
function ToTemporalCalendarIdentifier(e2) {
  if ("string" == typeof e2) return e2;
  const t2 = e2.id;
  if ("string" != typeof t2) throw new TypeError("calendar.id should be a string");
  return t2;
}
__name(ToTemporalCalendarIdentifier, "ToTemporalCalendarIdentifier");
function ToTemporalCalendarObject(e2) {
  if (IsObject(e2)) return e2;
  return new (GetIntrinsic("%Temporal.Calendar%"))(e2);
}
__name(ToTemporalCalendarObject, "ToTemporalCalendarObject");
function CalendarEquals(e2, t2) {
  if (e2 === t2) return true;
  return ToTemporalCalendarIdentifier(e2) === ToTemporalCalendarIdentifier(t2);
}
__name(CalendarEquals, "CalendarEquals");
function ThrowIfCalendarsNotEqual(e2, t2, r2) {
  if (e2 === t2) return;
  const o2 = ToTemporalCalendarIdentifier(e2), n2 = ToTemporalCalendarIdentifier(t2);
  if (o2 !== n2) throw new RangeError(`cannot ${r2} of ${o2} and ${n2} calendars`);
}
__name(ThrowIfCalendarsNotEqual, "ThrowIfCalendarsNotEqual");
function ConsolidateCalendars(e2, t2) {
  if (e2 === t2) return t2;
  const r2 = ToTemporalCalendarIdentifier(e2), o2 = ToTemporalCalendarIdentifier(t2);
  if (r2 === o2 || "iso8601" === r2) return t2;
  if ("iso8601" === o2) return e2;
  throw new RangeError("irreconcilable calendars");
}
__name(ConsolidateCalendars, "ConsolidateCalendars");
function CalendarDateFromFields(e2, t2, r2, o2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"), o3, [
      t2,
      r2
    ]);
  }
  const n2 = Call(o2 ?? GetMethod(e2, "dateFromFields"), e2, [
    t2,
    r2
  ]);
  if (!IsTemporalDate(n2)) throw new TypeError("invalid result");
  return n2;
}
__name(CalendarDateFromFields, "CalendarDateFromFields");
function CalendarYearMonthFromFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"), o3, [
      t2,
      r2
    ]);
  }
  let o2 = Call(GetMethod(e2, "yearMonthFromFields"), e2, [
    t2,
    r2
  ]);
  if (!IsTemporalYearMonth(o2)) throw new TypeError("invalid result");
  return o2;
}
__name(CalendarYearMonthFromFields, "CalendarYearMonthFromFields");
function CalendarMonthDayFromFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"), o3, [
      t2,
      r2
    ]);
  }
  let o2 = Call(GetMethod(e2, "monthDayFromFields"), e2, [
    t2,
    r2
  ]);
  if (!IsTemporalMonthDay(o2)) throw new TypeError("invalid result");
  return o2;
}
__name(CalendarMonthDayFromFields, "CalendarMonthDayFromFields");
function ToTemporalTimeZoneSlotValue(e2) {
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2)) return GetSlot(e2, g);
    if (!(/* @__PURE__ */ __name(function ObjectImplementsTemporalTimeZoneProtocol(e3) {
      return !!IsTemporalTimeZone(e3) || "getOffsetNanosecondsFor" in e3 && "getPossibleInstantsFor" in e3 && "id" in e3;
    }, "ObjectImplementsTemporalTimeZoneProtocol"))(e2)) throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
    return e2;
  }
  return ParseTemporalTimeZone(ToString(e2));
}
__name(ToTemporalTimeZoneSlotValue, "ToTemporalTimeZoneSlotValue");
function ToTemporalTimeZoneIdentifier(e2) {
  if ("string" == typeof e2) return e2;
  const t2 = e2.id;
  if ("string" != typeof t2) throw new TypeError("timeZone.id should be a string");
  return t2;
}
__name(ToTemporalTimeZoneIdentifier, "ToTemporalTimeZoneIdentifier");
function ToTemporalTimeZoneObject(e2) {
  if (IsObject(e2)) return e2;
  return new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
}
__name(ToTemporalTimeZoneObject, "ToTemporalTimeZoneObject");
function TimeZoneEquals(e2, t2) {
  if (e2 === t2) return true;
  return ToTemporalTimeZoneIdentifier(e2) === ToTemporalTimeZoneIdentifier(t2);
}
__name(TimeZoneEquals, "TimeZoneEquals");
function TemporalDateTimeToDate(e2) {
  return CreateTemporalDate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p));
}
__name(TemporalDateTimeToDate, "TemporalDateTimeToDate");
function TemporalDateTimeToTime(e2) {
  return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T));
}
__name(TemporalDateTimeToTime, "TemporalDateTimeToTime");
function GetOffsetNanosecondsFor(e2, t2, r2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"), r3, [
      t2
    ]);
  }
  const o2 = Call(r2 ?? GetMethod(e2, "getOffsetNanosecondsFor"), e2, [
    t2
  ]);
  if ("number" != typeof o2) throw new TypeError("bad return from getOffsetNanosecondsFor");
  if (!IsIntegralNumber(o2) || ae(o2) >= 864e11) throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
  return o2;
}
__name(GetOffsetNanosecondsFor, "GetOffsetNanosecondsFor");
function GetOffsetStringFor(e2, t2) {
  return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e2, t2));
}
__name(GetOffsetStringFor, "GetOffsetStringFor");
function GetPlainDateTimeFor(e2, t2, r2) {
  const o2 = GetSlot(t2, n), a2 = GetOffsetNanosecondsFor(e2, t2);
  let { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = GetISOPartsFromEpoch(o2);
  return { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = BalanceISODateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2 + a2), CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, r2);
}
__name(GetPlainDateTimeFor, "GetPlainDateTimeFor");
function GetInstantFor(e2, t2, r2) {
  return DisambiguatePossibleInstants(GetPossibleInstantsFor(e2, t2), e2, t2, r2);
}
__name(GetInstantFor, "GetInstantFor");
function DisambiguatePossibleInstants(t2, r2, o2, n2) {
  const a2 = GetIntrinsic("%Temporal.Instant%"), f2 = t2.length;
  if (1 === f2) return t2[0];
  if (f2) switch (n2) {
    case "compatible":
    case "earlier":
      return t2[0];
    case "later":
      return t2[f2 - 1];
    case "reject":
      throw new RangeError("multiple instants found");
  }
  const y2 = GetSlot(o2, i), I2 = GetSlot(o2, s), S2 = GetSlot(o2, l), g2 = GetSlot(o2, d), w2 = GetSlot(o2, m), D2 = GetSlot(o2, c), G2 = GetSlot(o2, h), v2 = GetSlot(o2, u), C2 = GetSlot(o2, T), O2 = GetUTCEpochNanoseconds(y2, I2, S2, g2, w2, D2, G2, v2, C2);
  if (null === O2) throw new RangeError("DateTime outside of supported range");
  const b2 = new a2(import_jsbi.default.subtract(O2, Ee)), E2 = new a2(import_jsbi.default.add(O2, Ee)), M2 = GetOffsetNanosecondsFor(r2, b2), R2 = GetOffsetNanosecondsFor(r2, E2) - M2;
  switch (n2) {
    case "earlier": {
      const e2 = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R2, void 0);
      return GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e2))[0];
    }
    case "compatible":
    case "later": {
      const e2 = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, R2, void 0), a3 = GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e2));
      return a3[a3.length - 1];
    }
    case "reject":
      throw new RangeError("no such instant found");
  }
}
__name(DisambiguatePossibleInstants, "DisambiguatePossibleInstants");
function GetPossibleInstantsFor(e2, t2, r2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"), r3, [
      t2
    ]);
  }
  const o2 = Call(r2 ?? GetMethod(e2, "getPossibleInstantsFor"), e2, [
    t2
  ]), n2 = [];
  for (const e3 of o2) {
    if (!IsTemporalInstant(e3)) throw new TypeError("bad return from getPossibleInstantsFor");
    te.call(n2, e3);
  }
  return n2;
}
__name(GetPossibleInstantsFor, "GetPossibleInstantsFor");
function ISOYearString(e2) {
  let t2;
  if (e2 < 0 || e2 > 9999) {
    t2 = (e2 < 0 ? "-" : "+") + `000000${ae(e2)}`.slice(-6);
  } else t2 = `0000${e2}`.slice(-4);
  return t2;
}
__name(ISOYearString, "ISOYearString");
function ISODateTimePartString(e2) {
  return `00${e2}`.slice(-2);
}
__name(ISODateTimePartString, "ISODateTimePartString");
function FormatSecondsStringPart(e2, t2, r2, o2, n2) {
  if ("minute" === n2) return "";
  const a2 = `:${ISODateTimePartString(e2)}`;
  let i2, s2 = 1e6 * t2 + 1e3 * r2 + o2;
  if ("auto" === n2) {
    if (0 === s2) return a2;
    for (i2 = `${s2}`.padStart(9, "0"); "0" === i2[i2.length - 1]; ) i2 = i2.slice(0, -1);
  } else {
    if (0 === n2) return a2;
    i2 = `${s2}`.padStart(9, "0").slice(0, n2);
  }
  return `${a2}.${i2}`;
}
__name(FormatSecondsStringPart, "FormatSecondsStringPart");
function TemporalInstantToString(e2, t2, r2) {
  let o2 = t2;
  void 0 === o2 && (o2 = "UTC");
  const n2 = GetPlainDateTimeFor(o2, e2, "iso8601"), a2 = ISOYearString(GetSlot(n2, i)), p2 = ISODateTimePartString(GetSlot(n2, s)), f2 = ISODateTimePartString(GetSlot(n2, l)), y2 = ISODateTimePartString(GetSlot(n2, d)), I2 = ISODateTimePartString(GetSlot(n2, m)), S2 = FormatSecondsStringPart(GetSlot(n2, c), GetSlot(n2, h), GetSlot(n2, u), GetSlot(n2, T), r2);
  let g2 = "Z";
  if (void 0 !== t2) {
    g2 = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o2, e2));
  }
  return `${a2}-${p2}-${f2}T${y2}:${I2}${S2}${g2}`;
}
__name(TemporalInstantToString, "TemporalInstantToString");
function TemporalDurationToString(t2, r2 = "auto", o2) {
  function formatNumber(t3) {
    return t3 <= ue ? t3.toString(10) : import_jsbi.default.BigInt(t3).toString(10);
  }
  __name(formatNumber, "formatNumber");
  const n2 = GetSlot(t2, w), a2 = GetSlot(t2, D), i2 = GetSlot(t2, G), s2 = GetSlot(t2, v), l2 = GetSlot(t2, C), d2 = GetSlot(t2, O);
  let m2 = GetSlot(t2, b), c2 = GetSlot(t2, E), h2 = GetSlot(t2, M), u2 = GetSlot(t2, R);
  const T2 = DurationSign(n2, a2, i2, s2, l2, d2, m2, c2, h2, u2);
  if (o2) {
    const { unit: e2, increment: t3, roundingMode: r3 } = o2;
    ({ seconds: m2, milliseconds: c2, microseconds: h2, nanoseconds: u2 } = RoundDuration(0, 0, 0, 0, 0, 0, m2, c2, h2, u2, t3, e2, r3));
  }
  const p2 = [];
  n2 && p2.push(`${formatNumber(ae(n2))}Y`), a2 && p2.push(`${formatNumber(ae(a2))}M`), i2 && p2.push(`${formatNumber(ae(i2))}W`), s2 && p2.push(`${formatNumber(ae(s2))}D`);
  const f2 = [];
  l2 && f2.push(`${formatNumber(ae(l2))}H`), d2 && f2.push(`${formatNumber(ae(d2))}M`);
  const y2 = [];
  let I2, S2, g2, F2, Y2 = TotalDurationNanoseconds(0, 0, 0, m2, c2, h2, u2, 0);
  ({ quotient: Y2, remainder: I2 } = divmod(Y2, De)), { quotient: Y2, remainder: S2 } = divmod(Y2, De), { quotient: F2, remainder: g2 } = divmod(Y2, De);
  const P2 = 1e6 * ae(import_jsbi.default.toNumber(g2)) + 1e3 * ae(import_jsbi.default.toNumber(S2)) + ae(import_jsbi.default.toNumber(I2));
  let Z2;
  if ("auto" === r2) {
    if (0 !== P2) for (Z2 = `${P2}`.padStart(9, "0"); "0" === Z2[Z2.length - 1]; ) Z2 = Z2.slice(0, -1);
  } else 0 !== r2 && (Z2 = `${P2}`.padStart(9, "0").slice(0, r2));
  return Z2 && y2.unshift(".", Z2), import_jsbi.default.equal(F2, Ie) && !y2.length && "auto" === r2 || y2.unshift(abs(F2).toString()), y2.length && f2.push(`${y2.join("")}S`), f2.length && f2.unshift("T"), p2.length || f2.length ? `${T2 < 0 ? "-" : ""}P${p2.join("")}${f2.join("")}` : "PT0S";
}
__name(TemporalDurationToString, "TemporalDurationToString");
function TemporalDateToString(e2, t2 = "auto") {
  return `${ISOYearString(GetSlot(e2, i))}-${ISODateTimePartString(GetSlot(e2, s))}-${ISODateTimePartString(GetSlot(e2, l))}${MaybeFormatCalendarAnnotation(GetSlot(e2, p), t2)}`;
}
__name(TemporalDateToString, "TemporalDateToString");
function TemporalDateTimeToString(e2, t2, r2 = "auto", o2) {
  let n2 = GetSlot(e2, i), a2 = GetSlot(e2, s), f2 = GetSlot(e2, l), y2 = GetSlot(e2, d), I2 = GetSlot(e2, m), S2 = GetSlot(e2, c), g2 = GetSlot(e2, h), w2 = GetSlot(e2, u), D2 = GetSlot(e2, T);
  if (o2) {
    const { unit: e3, increment: t3, roundingMode: r3 } = o2;
    ({ year: n2, month: a2, day: f2, hour: y2, minute: I2, second: S2, millisecond: g2, microsecond: w2, nanosecond: D2 } = RoundISODateTime(n2, a2, f2, y2, I2, S2, g2, w2, D2, t3, e3, r3));
  }
  return `${ISOYearString(n2)}-${ISODateTimePartString(a2)}-${ISODateTimePartString(f2)}T${ISODateTimePartString(y2)}:${ISODateTimePartString(I2)}${FormatSecondsStringPart(S2, g2, w2, D2, t2)}${MaybeFormatCalendarAnnotation(GetSlot(e2, p), r2)}`;
}
__name(TemporalDateTimeToString, "TemporalDateTimeToString");
function TemporalMonthDayToString(e2, t2 = "auto") {
  let r2 = `${ISODateTimePartString(GetSlot(e2, s))}-${ISODateTimePartString(GetSlot(e2, l))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 = `${ISOYearString(GetSlot(e2, i))}-${r2}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
__name(TemporalMonthDayToString, "TemporalMonthDayToString");
function TemporalYearMonthToString(e2, t2 = "auto") {
  let r2 = `${ISOYearString(GetSlot(e2, i))}-${ISODateTimePartString(GetSlot(e2, s))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 += `-${ISODateTimePartString(GetSlot(e2, l))}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
__name(TemporalYearMonthToString, "TemporalYearMonthToString");
function TemporalZonedDateTimeToString(e2, t2, r2 = "auto", o2 = "auto", a2 = "auto", f2) {
  let y2 = GetSlot(e2, S);
  if (f2) {
    const { unit: t3, increment: r3, roundingMode: o3 } = f2, a3 = RoundInstant(GetSlot(e2, n), r3, t3, o3);
    y2 = new (GetIntrinsic("%Temporal.Instant%"))(a3);
  }
  const I2 = GetSlot(e2, g), w2 = GetPlainDateTimeFor(I2, y2, "iso8601");
  let D2 = `${ISOYearString(GetSlot(w2, i))}-${ISODateTimePartString(GetSlot(w2, s))}-${ISODateTimePartString(GetSlot(w2, l))}T${ISODateTimePartString(GetSlot(w2, d))}:${ISODateTimePartString(GetSlot(w2, m))}${FormatSecondsStringPart(GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), t2)}`;
  if ("never" !== a2) {
    D2 += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I2, y2));
  }
  if ("never" !== o2) {
    D2 += `[${"critical" === o2 ? "!" : ""}${ToTemporalTimeZoneIdentifier(I2)}]`;
  }
  return D2 += MaybeFormatCalendarAnnotation(GetSlot(e2, p), r2), D2;
}
__name(TemporalZonedDateTimeToString, "TemporalZonedDateTimeToString");
function IsTimeZoneOffsetString(e2) {
  return ze.test(he(e2));
}
__name(IsTimeZoneOffsetString, "IsTimeZoneOffsetString");
function ParseTimeZoneOffsetString(e2) {
  const t2 = ze.exec(he(e2));
  if (!t2) throw new RangeError(`invalid time zone offset: ${e2}`);
  return ("-" === t2[1] || "\u2212" === t2[1] ? -1 : 1) * (1e9 * (60 * (60 * +t2[2] + +(t2[3] || 0)) + +(t2[4] || 0)) + +((t2[5] || 0) + "000000000").slice(0, 9));
}
__name(ParseTimeZoneOffsetString, "ParseTimeZoneOffsetString");
function GetCanonicalTimeZoneIdentifier(e2) {
  if (IsTimeZoneOffsetString(e2)) {
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e2));
  }
  return getIntlDateTimeFormatEnUsForTimeZone(he(e2)).resolvedOptions().timeZone;
}
__name(GetCanonicalTimeZoneIdentifier, "GetCanonicalTimeZoneIdentifier");
function GetNamedTimeZoneOffsetNanoseconds(t2, r2) {
  const { year: o2, month: n2, day: a2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = GetNamedTimeZoneDateTimeParts(t2, r2), h2 = o2 % 400, u2 = (o2 - h2) / 400, T2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(146097), Ee), p2 = GetUTCEpochNanoseconds(h2, n2, a2, i2, s2, l2, d2, m2, c2), f2 = import_jsbi.default.add(p2, import_jsbi.default.multiply(T2, import_jsbi.default.BigInt(u2)));
  return import_jsbi.default.toNumber(import_jsbi.default.subtract(f2, r2));
}
__name(GetNamedTimeZoneOffsetNanoseconds, "GetNamedTimeZoneOffsetNanoseconds");
function FormatTimeZoneOffsetString(e2) {
  const t2 = e2 < 0 ? "-" : "+", r2 = ae(e2), o2 = r2 % 1e9, n2 = ie(r2 / 1e9) % 60, a2 = ie(r2 / 6e10) % 60, i2 = ISODateTimePartString(ie(r2 / 36e11)), s2 = ISODateTimePartString(a2), l2 = ISODateTimePartString(n2);
  let d2 = "";
  if (o2) {
    let e3 = `${o2}`.padStart(9, "0");
    for (; "0" === e3[e3.length - 1]; ) e3 = e3.slice(0, -1);
    d2 = `:${l2}.${e3}`;
  } else n2 && (d2 = `:${l2}`);
  return `${t2}${i2}:${s2}${d2}`;
}
__name(FormatTimeZoneOffsetString, "FormatTimeZoneOffsetString");
function FormatISOTimeZoneOffsetString(t2) {
  let r2 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(t2), be, "halfExpand"));
  const o2 = r2 < 0 ? "-" : "+";
  r2 = ae(r2);
  const n2 = r2 / 6e10 % 60;
  return `${o2}${ISODateTimePartString(ie(r2 / 36e11))}:${ISODateTimePartString(n2)}`;
}
__name(FormatISOTimeZoneOffsetString, "FormatISOTimeZoneOffsetString");
function GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = /* @__PURE__ */ new Date();
  m2.setUTCHours(n2, a2, i2, s2), m2.setUTCFullYear(t2, r2 - 1, o2);
  const c2 = m2.getTime();
  if (de(c2)) return null;
  let h2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(c2), Ge);
  return h2 = import_jsbi.default.add(h2, import_jsbi.default.multiply(import_jsbi.default.BigInt(l2), De)), h2 = import_jsbi.default.add(h2, import_jsbi.default.BigInt(d2)), import_jsbi.default.lessThan(h2, Me) || import_jsbi.default.greaterThan(h2, Re) ? null : h2;
}
__name(GetUTCEpochNanoseconds, "GetUTCEpochNanoseconds");
function GetISOPartsFromEpoch(t2) {
  const { quotient: r2, remainder: o2 } = divmod(t2, Ge);
  let n2 = import_jsbi.default.toNumber(r2), a2 = import_jsbi.default.toNumber(o2);
  a2 < 0 && (a2 += 1e6, n2 -= 1);
  const i2 = ie(a2 / 1e3) % 1e3, s2 = a2 % 1e3, l2 = new Date(n2);
  return {
    epochMilliseconds: n2,
    year: l2.getUTCFullYear(),
    month: l2.getUTCMonth() + 1,
    day: l2.getUTCDate(),
    hour: l2.getUTCHours(),
    minute: l2.getUTCMinutes(),
    second: l2.getUTCSeconds(),
    millisecond: l2.getUTCMilliseconds(),
    microsecond: i2,
    nanosecond: s2
  };
}
__name(GetISOPartsFromEpoch, "GetISOPartsFromEpoch");
function GetNamedTimeZoneDateTimeParts(e2, t2) {
  const { epochMilliseconds: r2, millisecond: o2, microsecond: n2, nanosecond: a2 } = GetISOPartsFromEpoch(t2), { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2 } = (/* @__PURE__ */ __name(function GetFormatterParts(e3, t3) {
    const r3 = getIntlDateTimeFormatEnUsForTimeZone(e3).format(new Date(t3));
    return (/* @__PURE__ */ __name(function parseFromEnUsFormat(e4) {
      const t4 = e4.split(/[^\w]+/);
      if (7 !== t4.length) throw new RangeError(`expected 7 parts in "${e4}`);
      const r4 = +t4[0], o3 = +t4[1];
      let n3 = +t4[2];
      const a3 = t4[3].toUpperCase();
      if ("B" === a3 || "BC" === a3) n3 = 1 - n3;
      else if ("A" !== a3 && "AD" !== a3) throw new RangeError(`Unknown era ${a3} in "${e4}`);
      let i3 = +t4[4];
      24 === i3 && (i3 = 0);
      const s3 = +t4[5], l3 = +t4[6];
      if (!(me(n3) && me(r4) && me(o3) && me(i3) && me(s3) && me(l3))) throw new RangeError(`Invalid number in "${e4}`);
      return {
        year: n3,
        month: r4,
        day: o3,
        hour: i3,
        minute: s3,
        second: l3
      };
    }, "parseFromEnUsFormat"))(r3);
  }, "GetFormatterParts"))(e2, r2);
  return BalanceISODateTime(i2, s2, l2, d2, m2, c2, o2, n2, a2);
}
__name(GetNamedTimeZoneDateTimeParts, "GetNamedTimeZoneDateTimeParts");
function maxJSBI(t2, r2) {
  return import_jsbi.default.lessThan(t2, r2) ? r2 : t2;
}
__name(maxJSBI, "maxJSBI");
function afterLatestPossibleTzdbRuleChange() {
  return import_jsbi.default.add(Ve(), Ze);
}
__name(afterLatestPossibleTzdbRuleChange, "afterLatestPossibleTzdbRuleChange");
function GetNamedTimeZoneNextTransition(t2, r2) {
  if (import_jsbi.default.lessThan(r2, Pe)) return GetNamedTimeZoneNextTransition(t2, Pe);
  const o2 = import_jsbi.default.add(r2, Be), n2 = maxJSBI(afterLatestPossibleTzdbRuleChange(), o2);
  let a2 = maxJSBI(Pe, r2);
  const i2 = GetNamedTimeZoneOffsetNanoseconds(t2, a2);
  let s2 = a2, l2 = i2;
  for (; i2 === l2 && import_jsbi.default.lessThan(import_jsbi.default.BigInt(a2), n2); ) {
    if (s2 = import_jsbi.default.add(a2, Ne), import_jsbi.default.greaterThan(s2, Re)) return null;
    l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2), i2 === l2 && (a2 = s2);
  }
  if (i2 === l2) return null;
  return bisect((e2) => GetNamedTimeZoneOffsetNanoseconds(t2, e2), a2, s2, i2, l2);
}
__name(GetNamedTimeZoneNextTransition, "GetNamedTimeZoneNextTransition");
function GetNamedTimeZonePreviousTransition(t2, r2) {
  const o2 = afterLatestPossibleTzdbRuleChange(), a2 = import_jsbi.default.greaterThan(r2, o2), i2 = a2 ? import_jsbi.default.subtract(r2, Be) : Pe;
  if ("Africa/Casablanca" === t2 || "Africa/El_Aaiun" === t2) {
    const o3 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
    if (import_jsbi.default.lessThan(o3, r2)) return GetNamedTimeZonePreviousTransition(t2, o3);
  }
  let s2 = import_jsbi.default.subtract(r2, Se);
  if (import_jsbi.default.lessThan(s2, Pe)) return null;
  const l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2);
  let d2 = s2, m2 = l2;
  for (; l2 === m2 && import_jsbi.default.greaterThan(s2, i2); ) {
    if (d2 = import_jsbi.default.subtract(s2, Ne), import_jsbi.default.lessThan(d2, Pe)) return null;
    m2 = GetNamedTimeZoneOffsetNanoseconds(t2, d2), l2 === m2 && (s2 = d2);
  }
  if (l2 === m2) {
    if (a2) {
      const r3 = import_jsbi.default.subtract(o2, Ee);
      return GetNamedTimeZonePreviousTransition(t2, r3);
    }
    return null;
  }
  return bisect((e2) => GetNamedTimeZoneOffsetNanoseconds(t2, e2), d2, s2, m2, l2);
}
__name(GetNamedTimeZonePreviousTransition, "GetNamedTimeZonePreviousTransition");
function LeapYear(e2) {
  if (void 0 === e2) return false;
  return e2 % 4 == 0 && (!(e2 % 100 == 0) || e2 % 400 == 0);
}
__name(LeapYear, "LeapYear");
function ISODaysInMonth(e2, t2) {
  return {
    standard: [
      31,
      28,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ],
    leapyear: [
      31,
      29,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ]
  }[LeapYear(e2) ? "leapyear" : "standard"][t2 - 1];
}
__name(ISODaysInMonth, "ISODaysInMonth");
function DayOfWeek(e2, t2, r2) {
  const o2 = t2 + (t2 < 3 ? 10 : -2), n2 = e2 - (t2 < 3 ? 1 : 0), a2 = ie(n2 / 100), i2 = n2 - 100 * a2, s2 = (r2 + ie(2.6 * o2 - 0.2) + (i2 + ie(i2 / 4)) + (ie(a2 / 4) - 2 * a2)) % 7;
  return s2 + (s2 <= 0 ? 7 : 0);
}
__name(DayOfWeek, "DayOfWeek");
function DayOfYear(e2, t2, r2) {
  let o2 = r2;
  for (let r3 = t2 - 1; r3 > 0; r3--) o2 += ISODaysInMonth(e2, r3);
  return o2;
}
__name(DayOfYear, "DayOfYear");
function WeekOfYear(e2, t2, r2) {
  const o2 = DayOfYear(e2, t2, r2), n2 = DayOfWeek(e2, t2, r2) || 7, a2 = DayOfWeek(e2, 1, 1), i2 = ie((o2 - n2 + 10) / 7);
  return i2 < 1 ? 5 === a2 || 6 === a2 && LeapYear(e2 - 1) ? {
    week: 53,
    year: e2 - 1
  } : {
    week: 52,
    year: e2 - 1
  } : 53 === i2 && (LeapYear(e2) ? 366 : 365) - o2 < 4 - n2 ? {
    week: 1,
    year: e2 + 1
  } : {
    week: i2,
    year: e2
  };
}
__name(WeekOfYear, "WeekOfYear");
function DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const m2 of [
    e2,
    t2,
    r2,
    o2,
    n2,
    a2,
    i2,
    s2,
    l2,
    d2
  ]) if (0 !== m2) return m2 < 0 ? -1 : 1;
  return 0;
}
__name(DurationSign, "DurationSign");
function BalanceISOYearMonth(e2, t2) {
  let r2 = e2, o2 = t2;
  if (!me(r2) || !me(o2)) throw new RangeError("infinity is out of range");
  return o2 -= 1, r2 += ie(o2 / 12), o2 %= 12, o2 < 0 && (o2 += 12), o2 += 1, {
    year: r2,
    month: o2
  };
}
__name(BalanceISOYearMonth, "BalanceISOYearMonth");
function BalanceISODate(e2, t2, r2) {
  let o2 = e2, n2 = t2, a2 = r2;
  if (!me(a2)) throw new RangeError("infinity is out of range");
  ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2));
  const i2 = 146097;
  if (ae(a2) > i2) {
    const e3 = le(a2 / i2);
    o2 += 400 * e3, a2 -= e3 * i2;
  }
  let s2 = 0, l2 = n2 > 2 ? o2 : o2 - 1;
  for (; s2 = LeapYear(l2) ? 366 : 365, a2 < -s2; ) o2 -= 1, l2 -= 1, a2 += s2;
  for (l2 += 1; s2 = LeapYear(l2) ? 366 : 365, a2 > s2; ) o2 += 1, l2 += 1, a2 -= s2;
  for (; a2 < 1; ) ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 - 1)), a2 += ISODaysInMonth(o2, n2);
  for (; a2 > ISODaysInMonth(o2, n2); ) a2 -= ISODaysInMonth(o2, n2), { year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 + 1);
  return {
    year: o2,
    month: n2,
    day: a2
  };
}
__name(BalanceISODate, "BalanceISODate");
function BalanceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  const { deltaDays: d2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 } = BalanceTime(o2, n2, a2, i2, s2, l2), { year: f2, month: y2, day: I2 } = BalanceISODate(e2, t2, r2 + d2);
  return {
    year: f2,
    month: y2,
    day: I2,
    hour: m2,
    minute: c2,
    second: h2,
    millisecond: u2,
    microsecond: T2,
    nanosecond: p2
  };
}
__name(BalanceISODateTime, "BalanceISODateTime");
function BalanceTime(t2, r2, o2, n2, a2, i2) {
  let s2, l2 = import_jsbi.default.BigInt(t2), d2 = import_jsbi.default.BigInt(r2), m2 = import_jsbi.default.BigInt(o2), c2 = import_jsbi.default.BigInt(n2), h2 = import_jsbi.default.BigInt(a2), u2 = import_jsbi.default.BigInt(i2);
  return { quotient: s2, remainder: u2 } = NonNegativeBigIntDivmod(u2, De), h2 = import_jsbi.default.add(h2, s2), { quotient: s2, remainder: h2 } = NonNegativeBigIntDivmod(h2, De), c2 = import_jsbi.default.add(c2, s2), { quotient: s2, remainder: c2 } = NonNegativeBigIntDivmod(c2, De), m2 = import_jsbi.default.add(m2, s2), { quotient: s2, remainder: m2 } = NonNegativeBigIntDivmod(m2, ge), d2 = import_jsbi.default.add(d2, s2), { quotient: s2, remainder: d2 } = NonNegativeBigIntDivmod(d2, ge), l2 = import_jsbi.default.add(l2, s2), { quotient: s2, remainder: l2 } = NonNegativeBigIntDivmod(l2, we), {
    deltaDays: import_jsbi.default.toNumber(s2),
    hour: import_jsbi.default.toNumber(l2),
    minute: import_jsbi.default.toNumber(d2),
    second: import_jsbi.default.toNumber(m2),
    millisecond: import_jsbi.default.toNumber(c2),
    microsecond: import_jsbi.default.toNumber(h2),
    nanosecond: import_jsbi.default.toNumber(u2)
  };
}
__name(BalanceTime, "BalanceTime");
function TotalDurationNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2) {
  const d2 = import_jsbi.default.BigInt(t2);
  let m2 = import_jsbi.default.BigInt(s2);
  0 !== t2 && (m2 = import_jsbi.default.subtract(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(l2)));
  const c2 = import_jsbi.default.add(import_jsbi.default.BigInt(r2), import_jsbi.default.multiply(d2, import_jsbi.default.BigInt(24))), h2 = import_jsbi.default.add(import_jsbi.default.BigInt(o2), import_jsbi.default.multiply(c2, ge)), u2 = import_jsbi.default.add(import_jsbi.default.BigInt(n2), import_jsbi.default.multiply(h2, ge)), T2 = import_jsbi.default.add(import_jsbi.default.BigInt(a2), import_jsbi.default.multiply(u2, De)), p2 = import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.multiply(T2, De));
  return import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.multiply(p2, De));
}
__name(TotalDurationNanoseconds, "TotalDurationNanoseconds");
function NanosecondsToDays(t2, r2) {
  const o2 = GetIntrinsic("%Temporal.Instant%"), a2 = se(import_jsbi.default.toNumber(t2));
  let f2 = import_jsbi.default.BigInt(t2), y2 = 864e11;
  if (0 === a2) return {
    days: 0,
    nanoseconds: Ie,
    dayLengthNs: y2
  };
  if (!IsTemporalZonedDateTime(r2)) {
    let t3;
    return { quotient: t3, remainder: f2 } = divmod(f2, import_jsbi.default.BigInt(y2)), {
      days: import_jsbi.default.toNumber(t3),
      nanoseconds: f2,
      dayLengthNs: y2
    };
  }
  const I2 = GetSlot(r2, n), w2 = GetSlot(r2, S), D2 = import_jsbi.default.add(I2, f2), G2 = new o2(D2), v2 = GetSlot(r2, g), C2 = GetSlot(r2, p), O2 = GetPlainDateTimeFor(v2, w2, C2), b2 = GetPlainDateTimeFor(v2, G2, C2);
  let { days: E2 } = DifferenceISODateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(O2, d), GetSlot(O2, m), GetSlot(O2, c), GetSlot(O2, h), GetSlot(O2, u), GetSlot(O2, T), GetSlot(b2, i), GetSlot(b2, s), GetSlot(b2, l), GetSlot(b2, d), GetSlot(b2, m), GetSlot(b2, c), GetSlot(b2, h), GetSlot(b2, u), GetSlot(b2, T), C2, "day", Te(null)), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, E2, 0, 0, 0, 0, 0, 0), R2 = import_jsbi.default.BigInt(E2);
  if (1 === a2) for (; import_jsbi.default.greaterThan(R2, Ie) && import_jsbi.default.greaterThan(M2, D2); ) R2 = import_jsbi.default.subtract(R2, Se), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, import_jsbi.default.toNumber(R2), 0, 0, 0, 0, 0, 0);
  f2 = import_jsbi.default.subtract(D2, M2);
  let F2 = false, Y2 = new o2(M2);
  do {
    const t3 = AddZonedDateTime(Y2, v2, C2, 0, 0, 0, a2, 0, 0, 0, 0, 0, 0), r3 = GetSlot(Y2, n);
    y2 = import_jsbi.default.toNumber(import_jsbi.default.subtract(t3, r3)), F2 = import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(f2, import_jsbi.default.BigInt(y2)), import_jsbi.default.BigInt(a2)), Ie), F2 && (f2 = import_jsbi.default.subtract(f2, import_jsbi.default.BigInt(y2)), Y2 = new o2(t3), R2 = import_jsbi.default.add(R2, import_jsbi.default.BigInt(a2)));
  } while (F2);
  if (!isZero(R2) && signJSBI(R2) !== a2) throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
  if (!isZero(f2) && signJSBI(f2) !== a2) {
    if (isNegativeJSBI(f2) && 1 === a2) throw new Error("assert not reached");
    throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
  }
  if (import_jsbi.default.greaterThanOrEqual(abs(f2), abs(import_jsbi.default.BigInt(y2)))) throw new Error("assert not reached");
  return {
    days: import_jsbi.default.toNumber(R2),
    nanoseconds: f2,
    dayLengthNs: ae(y2)
  };
}
__name(NanosecondsToDays, "NanosecondsToDays");
function BalanceDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  let d2 = BalancePossiblyInfiniteDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2);
  if ("positive overflow" === d2 || "negative overflow" === d2) throw new RangeError("Duration out of range");
  return d2;
}
__name(BalanceDuration, "BalanceDuration");
function BalancePossiblyInfiniteDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2) {
  let c2, h2, u2, T2, f2, y2, I2 = t2;
  if (IsTemporalZonedDateTime(m2)) {
    const t3 = AddZonedDateTime(GetSlot(m2, S), GetSlot(m2, g), GetSlot(m2, p), 0, 0, 0, I2, r2, o2, a2, i2, s2, l2), d3 = GetSlot(m2, n);
    c2 = import_jsbi.default.subtract(t3, d3);
  } else c2 = TotalDurationNanoseconds(I2, r2, o2, a2, i2, s2, l2, 0);
  "year" === d2 || "month" === d2 || "week" === d2 || "day" === d2 ? { days: I2, nanoseconds: c2 } = NanosecondsToDays(c2, m2) : I2 = 0;
  const w2 = import_jsbi.default.lessThan(c2, Ie) ? -1 : 1;
  switch (c2 = abs(c2), h2 = u2 = T2 = f2 = y2 = Ie, d2) {
    case "year":
    case "month":
    case "week":
    case "day":
    case "hour":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge), { quotient: y2, remainder: f2 } = divmod(f2, ge);
      break;
    case "minute":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge);
      break;
    case "second":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De);
      break;
    case "millisecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De);
      break;
    case "microsecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De));
      break;
    case "nanosecond":
      break;
    default:
      throw new Error("assert not reached");
  }
  const D2 = import_jsbi.default.toNumber(y2) * w2, G2 = import_jsbi.default.toNumber(f2) * w2, v2 = import_jsbi.default.toNumber(T2) * w2, C2 = import_jsbi.default.toNumber(u2) * w2, O2 = import_jsbi.default.toNumber(h2) * w2, b2 = import_jsbi.default.toNumber(c2) * w2;
  for (const e2 of [
    I2,
    D2,
    G2,
    v2,
    C2,
    O2,
    b2
  ]) if (!me(e2)) return 1 === w2 ? "positive overflow" : "negative overflow";
  return {
    days: I2,
    hours: D2,
    minutes: G2,
    seconds: v2,
    milliseconds: C2,
    microseconds: O2,
    nanoseconds: b2
  };
}
__name(BalancePossiblyInfiniteDuration, "BalancePossiblyInfiniteDuration");
function UnbalanceDurationRelative(t2, r2, o2, n2, a2, i2) {
  const s2 = GetIntrinsic("%Temporal.Duration%"), l2 = DurationSign(t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
  if (0 === l2) return {
    years: t2,
    months: r2,
    weeks: o2,
    days: n2
  };
  const d2 = import_jsbi.default.BigInt(l2);
  let m2, c2, h2 = import_jsbi.default.BigInt(t2), u2 = import_jsbi.default.BigInt(r2), T2 = import_jsbi.default.BigInt(o2), f2 = import_jsbi.default.BigInt(n2);
  i2 && (c2 = ToTemporalDate(i2), m2 = GetSlot(c2, p));
  const y2 = new s2(l2), I2 = new s2(0, l2), S2 = new s2(0, 0, l2);
  switch (a2) {
    case "year":
      break;
    case "month":
      {
        if (!m2) throw new RangeError("a starting point is required for months balancing");
        let t3, r3;
        for ("string" != typeof m2 && (t3 = GetMethod(m2, "dateAdd"), r3 = GetMethod(m2, "dateUntil")); !isZero(h2); ) {
          const o3 = CalendarDateAdd(m2, c2, y2, void 0, t3), n3 = Te(null);
          n3.largestUnit = "month";
          const a3 = CalendarDateUntil(m2, c2, o3, n3, r3), i3 = import_jsbi.default.BigInt(GetSlot(a3, D));
          c2 = o3, u2 = import_jsbi.default.add(u2, i3), h2 = import_jsbi.default.subtract(h2, d2);
        }
      }
      break;
    case "week": {
      if (!m2) throw new RangeError("a starting point is required for weeks balancing");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), h2 = import_jsbi.default.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), u2 = import_jsbi.default.subtract(u2, d2);
      }
      break;
    }
    default: {
      if (isZero(h2) && isZero(u2) && isZero(T2)) break;
      if (!m2) throw new RangeError("a starting point is required for balancing calendar units");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), h2 = import_jsbi.default.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), u2 = import_jsbi.default.subtract(u2, d2);
      }
      for (; !isZero(T2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, S2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), T2 = import_jsbi.default.subtract(T2, d2);
      }
      break;
    }
  }
  return {
    years: import_jsbi.default.toNumber(h2),
    months: import_jsbi.default.toNumber(u2),
    weeks: import_jsbi.default.toNumber(T2),
    days: import_jsbi.default.toNumber(f2)
  };
}
__name(UnbalanceDurationRelative, "UnbalanceDurationRelative");
function CalculateOffsetShift(e2, t2, r2, o2, n2) {
  if (IsTemporalZonedDateTime(e2)) {
    const a2 = GetSlot(e2, S), i2 = GetSlot(e2, g), s2 = GetSlot(e2, p), l2 = GetOffsetNanosecondsFor(i2, a2), d2 = AddZonedDateTime(a2, i2, s2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
    return GetOffsetNanosecondsFor(i2, new (GetIntrinsic("%Temporal.Instant%"))(d2)) - l2;
  }
  return 0;
}
__name(CalculateOffsetShift, "CalculateOffsetShift");
function CreateNegatedTemporalDuration(e2) {
  return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e2, w), -GetSlot(e2, D), -GetSlot(e2, G), -GetSlot(e2, v), -GetSlot(e2, C), -GetSlot(e2, O), -GetSlot(e2, b), -GetSlot(e2, E), -GetSlot(e2, M), -GetSlot(e2, R));
}
__name(CreateNegatedTemporalDuration, "CreateNegatedTemporalDuration");
function ConstrainToRange(e2, t2, r2) {
  return oe(r2, ne(t2, e2));
}
__name(ConstrainToRange, "ConstrainToRange");
function ConstrainISODate(e2, t2, r2) {
  const o2 = ConstrainToRange(t2, 1, 12);
  return {
    year: e2,
    month: o2,
    day: ConstrainToRange(r2, 1, ISODaysInMonth(e2, o2))
  };
}
__name(ConstrainISODate, "ConstrainISODate");
function RejectToRange(e2, t2, r2) {
  if (e2 < t2 || e2 > r2) throw new RangeError(`value out of range: ${t2} <= ${e2} <= ${r2}`);
}
__name(RejectToRange, "RejectToRange");
function RejectISODate(e2, t2, r2) {
  RejectToRange(t2, 1, 12), RejectToRange(r2, 1, ISODaysInMonth(e2, t2));
}
__name(RejectISODate, "RejectISODate");
function RejectDateRange(e2, t2, r2) {
  RejectDateTimeRange(e2, t2, r2, 12, 0, 0, 0, 0, 0);
}
__name(RejectDateRange, "RejectDateRange");
function RejectTime(e2, t2, r2, o2, n2, a2) {
  RejectToRange(e2, 0, 23), RejectToRange(t2, 0, 59), RejectToRange(r2, 0, 59), RejectToRange(o2, 0, 999), RejectToRange(n2, 0, 999), RejectToRange(a2, 0, 999);
}
__name(RejectTime, "RejectTime");
function RejectDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  RejectISODate(e2, t2, r2), RejectTime(o2, n2, a2, i2, s2, l2);
}
__name(RejectDateTime, "RejectDateTime");
function RejectDateTimeRange(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  if (RejectToRange(e2, Fe, Ye), e2 === Fe && null == GetUTCEpochNanoseconds(e2, t2, r2 + 1, o2, n2, a2, i2, s2, l2 - 1) || e2 === Ye && null == GetUTCEpochNanoseconds(e2, t2, r2 - 1, o2, n2, a2, i2, s2, l2 + 1)) throw new RangeError("DateTime outside of supported range");
}
__name(RejectDateTimeRange, "RejectDateTimeRange");
function ValidateEpochNanoseconds(t2) {
  if (import_jsbi.default.lessThan(t2, Me) || import_jsbi.default.greaterThan(t2, Re)) throw new RangeError("Instant outside of supported range");
}
__name(ValidateEpochNanoseconds, "ValidateEpochNanoseconds");
function RejectDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2);
  for (const c2 of [
    e2,
    t2,
    r2,
    o2,
    n2,
    a2,
    i2,
    s2,
    l2,
    d2
  ]) {
    if (!me(c2)) throw new RangeError("infinite values not allowed as duration fields");
    const e3 = se(c2);
    if (0 !== e3 && e3 !== m2) throw new RangeError("mixed-sign values not allowed as duration fields");
  }
}
__name(RejectDuration, "RejectDuration");
function DifferenceISODate(e2, t2, r2, o2, n2, a2, i2) {
  switch (i2) {
    case "year":
    case "month": {
      const s2 = -CompareISODate(e2, t2, r2, o2, n2, a2);
      if (0 === s2) return {
        years: 0,
        months: 0,
        weeks: 0,
        days: 0
      };
      const l2 = {
        year: e2,
        month: t2,
        day: r2
      }, d2 = {
        year: o2,
        month: n2,
        day: a2
      };
      let m2 = d2.year - l2.year, c2 = AddISODate(e2, t2, r2, m2, 0, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2);
      if (0 === h2) return "year" === i2 ? {
        years: m2,
        months: 0,
        weeks: 0,
        days: 0
      } : {
        years: 0,
        months: 12 * m2,
        weeks: 0,
        days: 0
      };
      let u2 = d2.month - l2.month;
      if (h2 !== s2 && (m2 -= s2, u2 += 12 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2), 0 === h2) return "year" === i2 ? {
        years: m2,
        months: u2,
        weeks: 0,
        days: 0
      } : {
        years: 0,
        months: u2 + 12 * m2,
        weeks: 0,
        days: 0
      };
      h2 !== s2 && (u2 -= s2, u2 === -s2 && (m2 -= s2, u2 = 11 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"));
      let T2 = 0;
      return T2 = c2.month === d2.month ? d2.day - c2.day : s2 < 0 ? -c2.day - (ISODaysInMonth(d2.year, d2.month) - d2.day) : d2.day + (ISODaysInMonth(c2.year, c2.month) - c2.day), "month" === i2 && (u2 += 12 * m2, m2 = 0), {
        years: m2,
        months: u2,
        weeks: 0,
        days: T2
      };
    }
    case "week":
    case "day": {
      let s2, l2, d2;
      CompareISODate(e2, t2, r2, o2, n2, a2) < 0 ? (l2 = {
        year: e2,
        month: t2,
        day: r2
      }, s2 = {
        year: o2,
        month: n2,
        day: a2
      }, d2 = 1) : (l2 = {
        year: o2,
        month: n2,
        day: a2
      }, s2 = {
        year: e2,
        month: t2,
        day: r2
      }, d2 = -1);
      let m2 = DayOfYear(s2.year, s2.month, s2.day) - DayOfYear(l2.year, l2.month, l2.day);
      for (let e3 = l2.year; e3 < s2.year; ++e3) m2 += LeapYear(e3) ? 366 : 365;
      let c2 = 0;
      return "week" === i2 && (c2 = ie(m2 / 7), m2 %= 7), c2 *= d2, m2 *= d2, {
        years: 0,
        months: 0,
        weeks: c2,
        days: m2
      };
    }
    default:
      throw new Error("assert not reached");
  }
}
__name(DifferenceISODate, "DifferenceISODate");
function DifferenceTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = i2 - e2, u2 = s2 - t2, T2 = l2 - r2, p2 = d2 - o2, f2 = m2 - n2, y2 = c2 - a2;
  const I2 = DurationSign(0, 0, 0, 0, h2, u2, T2, p2, f2, y2);
  h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2;
  let S2 = 0;
  if ({ deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), 0 != S2) throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
  return h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2, {
    hours: h2,
    minutes: u2,
    seconds: T2,
    milliseconds: p2,
    microseconds: f2,
    nanoseconds: y2
  };
}
__name(DifferenceTime, "DifferenceTime");
function DifferenceInstant(t2, r2, o2, n2, a2, i2) {
  const s2 = import_jsbi.default.subtract(r2, t2);
  let l2 = 0, d2 = 0, m2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(s2, De)), c2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(s2, De), De)), h2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(s2, Ge), De)), u2 = import_jsbi.default.toNumber(import_jsbi.default.divide(s2, ve));
  return { hours: l2, minutes: d2, seconds: u2, milliseconds: h2, microseconds: c2, nanoseconds: m2 } = RoundDuration(0, 0, 0, 0, 0, 0, u2, h2, c2, m2, o2, n2, i2), BalanceDuration(0, l2, d2, u2, h2, c2, m2, a2);
}
__name(DifferenceInstant, "DifferenceInstant");
function DifferenceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2) {
  let w2 = e2, D2 = t2, G2 = r2, { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = DifferenceTime(o2, n2, a2, i2, s2, l2, h2, u2, T2, p2, f2, y2);
  const R2 = DurationSign(0, 0, 0, 0, v2, C2, O2, b2, E2, M2);
  CompareISODate(d2, m2, c2, w2, D2, G2) === -R2 && ({ year: w2, month: D2, day: G2 } = BalanceISODate(w2, D2, G2 - R2), { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration(-R2, v2, C2, O2, b2, E2, M2, S2));
  const F2 = CreateTemporalDate(w2, D2, G2, I2), Y2 = CreateTemporalDate(d2, m2, c2, I2), P2 = LargerOfTwoTemporalUnits("day", S2), Z2 = CopyOptions(g2);
  Z2.largestUnit = P2;
  let { years: B2, months: N2, weeks: j2, days: $2 } = CalendarDateUntil(I2, F2, Y2, Z2);
  return { days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration($2, v2, C2, O2, b2, E2, M2, S2), {
    years: B2,
    months: N2,
    weeks: j2,
    days: $2,
    hours: v2,
    minutes: C2,
    seconds: O2,
    milliseconds: b2,
    microseconds: E2,
    nanoseconds: M2
  };
}
__name(DifferenceISODateTime, "DifferenceISODateTime");
function DifferenceZonedDateTime(t2, r2, o2, n2, a2, p2) {
  const f2 = import_jsbi.default.subtract(r2, t2);
  if (import_jsbi.default.equal(f2, Ie)) return {
    years: 0,
    months: 0,
    weeks: 0,
    days: 0,
    hours: 0,
    minutes: 0,
    seconds: 0,
    milliseconds: 0,
    microseconds: 0,
    nanoseconds: 0
  };
  const y2 = GetIntrinsic("%Temporal.Instant%"), I2 = new y2(t2), S2 = new y2(r2), g2 = GetPlainDateTimeFor(o2, I2, n2), w2 = GetPlainDateTimeFor(o2, S2, n2);
  let { years: D2, months: G2, weeks: v2, days: C2 } = DifferenceISODateTime(GetSlot(g2, i), GetSlot(g2, s), GetSlot(g2, l), GetSlot(g2, d), GetSlot(g2, m), GetSlot(g2, c), GetSlot(g2, h), GetSlot(g2, u), GetSlot(g2, T), GetSlot(w2, i), GetSlot(w2, s), GetSlot(w2, l), GetSlot(w2, d), GetSlot(w2, m), GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), n2, a2, p2);
  const O2 = AddZonedDateTime(I2, o2, n2, D2, G2, v2, 0, 0, 0, 0, 0, 0, 0);
  let b2 = import_jsbi.default.subtract(r2, O2);
  const E2 = CreateTemporalZonedDateTime(O2, o2, n2);
  ({ nanoseconds: b2, days: C2 } = NanosecondsToDays(b2, E2));
  const { hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(b2), "hour");
  return {
    years: D2,
    months: G2,
    weeks: v2,
    days: C2,
    hours: M2,
    minutes: R2,
    seconds: F2,
    milliseconds: Y2,
    microseconds: P2,
    nanoseconds: Z2
  };
}
__name(DifferenceZonedDateTime, "DifferenceZonedDateTime");
function GetDifferenceSettings(e2, t2, r2, o2, n2, a2) {
  const i2 = Ue.reduce((e3, t3) => {
    const n3 = t3[0], a3 = t3[1], i3 = t3[2];
    return "datetime" !== r2 && i3 !== r2 || o2.includes(a3) || e3.push(a3, n3), e3;
  }, []);
  let s2 = GetTemporalUnit(t2, "largestUnit", r2, "auto");
  if (o2.includes(s2)) throw new RangeError(`largestUnit must be one of ${i2.join(", ")}, not ${s2}`);
  const l2 = ToTemporalRoundingIncrement(t2);
  let d2 = ToTemporalRoundingMode(t2, "trunc");
  "since" === e2 && (d2 = (/* @__PURE__ */ __name(function NegateTemporalRoundingMode(e3) {
    switch (e3) {
      case "ceil":
        return "floor";
      case "floor":
        return "ceil";
      case "halfCeil":
        return "halfFloor";
      case "halfFloor":
        return "halfCeil";
      default:
        return e3;
    }
  }, "NegateTemporalRoundingMode"))(d2));
  const m2 = GetTemporalUnit(t2, "smallestUnit", r2, n2);
  if (o2.includes(m2)) throw new RangeError(`smallestUnit must be one of ${i2.join(", ")}, not ${m2}`);
  const c2 = LargerOfTwoTemporalUnits(a2, m2);
  if ("auto" === s2 && (s2 = c2), LargerOfTwoTemporalUnits(s2, m2) !== s2) throw new RangeError(`largestUnit ${s2} cannot be smaller than smallestUnit ${m2}`);
  const h2 = {
    hour: 24,
    minute: 60,
    second: 60,
    millisecond: 1e3,
    microsecond: 1e3,
    nanosecond: 1e3
  }[m2];
  return void 0 !== h2 && ValidateTemporalRoundingIncrement(l2, h2, false), {
    largestUnit: s2,
    roundingIncrement: l2,
    roundingMode: d2,
    smallestUnit: m2
  };
}
__name(GetDifferenceSettings, "GetDifferenceSettings");
function DifferenceTemporalInstant(e2, t2, r2, o2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalInstant(r2), s2 = GetDifferenceSettings(e2, CopyOptions(o2), "time", [], "nanosecond", "second"), l2 = GetSlot(t2, n), d2 = GetSlot(i2, n);
  let { hours: m2, minutes: c2, seconds: h2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = DifferenceInstant(l2, d2, s2.roundingIncrement, s2.smallestUnit, s2.largestUnit, s2.roundingMode);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, a2 * m2, a2 * c2, a2 * h2, a2 * u2, a2 * T2, a2 * p2);
}
__name(DifferenceTemporalInstant, "DifferenceTemporalInstant");
function DifferenceTemporalPlainDate(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDate(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between dates");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e2, s2, "date", [], "day", "day");
  s2.largestUnit = l2.largestUnit;
  let { years: d2, months: m2, weeks: c2, days: h2 } = CalendarDateUntil(i2, t2, a2, s2);
  "day" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: d2, months: m2, weeks: c2, days: h2 } = RoundDuration(d2, m2, c2, h2, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, t2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * d2, n2 * m2, n2 * c2, n2 * h2, 0, 0, 0, 0, 0, 0);
}
__name(DifferenceTemporalPlainDate, "DifferenceTemporalPlainDate");
function DifferenceTemporalPlainDateTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDateTime(r2), f2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(f2, GetSlot(a2, p), "compute difference between dates");
  const y2 = CopyOptions(o2), I2 = GetDifferenceSettings(e2, y2, "datetime", [], "nanosecond", "day");
  let { years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = DifferenceISODateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, i), GetSlot(a2, s), GetSlot(a2, l), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), f2, I2.largestUnit, y2);
  const M2 = TemporalDateTimeToDate(t2);
  ({ years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = RoundDuration(S2, g2, w2, D2, G2, v2, C2, O2, b2, E2, I2.roundingIncrement, I2.smallestUnit, I2.roundingMode, M2)), { days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = BalanceDuration(D2, G2, v2, C2, O2, b2, E2, I2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, n2 * C2, n2 * O2, n2 * b2, n2 * E2);
}
__name(DifferenceTemporalPlainDateTime, "DifferenceTemporalPlainDateTime");
function DifferenceTemporalPlainTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalTime(r2), i2 = GetDifferenceSettings(e2, CopyOptions(o2), "time", [], "nanosecond", "hour");
  let { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = DifferenceTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T));
  ({ hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = RoundDuration(0, 0, 0, 0, s2, l2, p2, f2, y2, I2, i2.roundingIncrement, i2.smallestUnit, i2.roundingMode)), { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = BalanceDuration(0, s2, l2, p2, f2, y2, I2, i2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n2 * s2, n2 * l2, n2 * p2, n2 * f2, n2 * y2, n2 * I2);
}
__name(DifferenceTemporalPlainTime, "DifferenceTemporalPlainTime");
function DifferenceTemporalPlainYearMonth(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalYearMonth(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between months");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e2, s2, "date", [
    "week",
    "day"
  ], "month", "year");
  s2.largestUnit = l2.largestUnit;
  const d2 = CalendarFields(i2, [
    "monthCode",
    "year"
  ]), m2 = PrepareTemporalFields(t2, d2, []);
  m2.day = 1;
  const c2 = CalendarDateFromFields(i2, m2), h2 = PrepareTemporalFields(a2, d2, []);
  h2.day = 1;
  const u2 = CalendarDateFromFields(i2, h2);
  let { years: T2, months: f2 } = CalendarDateUntil(i2, c2, u2, s2);
  "month" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: T2, months: f2 } = RoundDuration(T2, f2, 0, 0, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, c2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * T2, n2 * f2, 0, 0, 0, 0, 0, 0, 0, 0);
}
__name(DifferenceTemporalPlainYearMonth, "DifferenceTemporalPlainYearMonth");
function DifferenceTemporalZonedDateTime(e2, t2, r2, o2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalZonedDateTime(r2), s2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(s2, GetSlot(i2, p), "compute difference between dates");
  const l2 = CopyOptions(o2), d2 = GetDifferenceSettings(e2, l2, "datetime", [], "nanosecond", "hour");
  l2.largestUnit = d2.largestUnit;
  const m2 = GetSlot(t2, n), c2 = GetSlot(i2, n);
  let h2, u2, T2, f2, y2, I2, S2, w2, D2, G2;
  if ("year" !== d2.largestUnit && "month" !== d2.largestUnit && "week" !== d2.largestUnit && "day" !== d2.largestUnit) h2 = 0, u2 = 0, T2 = 0, f2 = 0, { hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceInstant(m2, c2, d2.roundingIncrement, d2.smallestUnit, d2.largestUnit, d2.roundingMode);
  else {
    const e3 = GetSlot(t2, g);
    if (!TimeZoneEquals(e3, GetSlot(i2, g))) throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
    ({ years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceZonedDateTime(m2, c2, e3, s2, d2.largestUnit, l2)), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = RoundDuration(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = AdjustRoundedDurationDays(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2);
  }
  return new (GetIntrinsic("%Temporal.Duration%"))(a2 * h2, a2 * u2, a2 * T2, a2 * f2, a2 * y2, a2 * I2, a2 * S2, a2 * w2, a2 * D2, a2 * G2);
}
__name(DifferenceTemporalZonedDateTime, "DifferenceTemporalZonedDateTime");
function AddISODate(e2, t2, r2, o2, n2, a2, i2, s2) {
  let l2 = e2, d2 = t2, m2 = r2, c2 = a2, h2 = i2;
  return l2 += o2, d2 += n2, { year: l2, month: d2 } = BalanceISOYearMonth(l2, d2), { year: l2, month: d2, day: m2 } = RegulateISODate(l2, d2, m2, s2), h2 += 7 * c2, m2 += h2, { year: l2, month: d2, day: m2 } = BalanceISODate(l2, d2, m2), {
    year: l2,
    month: d2,
    day: m2
  };
}
__name(AddISODate, "AddISODate");
function AddTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = e2, u2 = t2, T2 = r2, p2 = o2, f2 = n2, y2 = a2;
  h2 += i2, u2 += s2, T2 += l2, p2 += d2, f2 += m2, y2 += c2;
  let I2 = 0;
  return { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), {
    deltaDays: I2,
    hour: h2,
    minute: u2,
    second: T2,
    millisecond: p2,
    microsecond: f2,
    nanosecond: y2
  };
}
__name(AddTime, "AddTime");
function AddDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2, C2) {
  const O2 = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), DefaultTemporalLargestUnit(h2, u2, T2, f2, y2, I2, w2, D2, G2, v2));
  let b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2;
  if (C2) if (IsTemporalDate(C2)) {
    const n2 = GetIntrinsic("%Temporal.Duration%"), S2 = GetSlot(C2, p), g2 = new n2(t2, r2, o2, a2, 0, 0, 0, 0, 0, 0), j2 = new n2(h2, u2, T2, f2, 0, 0, 0, 0, 0, 0), $2 = "string" != typeof S2 ? GetMethod(S2, "dateAdd") : void 0, k2 = CalendarDateAdd(S2, C2, g2, void 0, $2), U2 = CalendarDateAdd(S2, k2, j2, void 0, $2), A2 = LargerOfTwoTemporalUnits("day", O2), L2 = Te(null);
    L2.largestUnit = A2, { years: b2, months: E2, weeks: M2, days: R2 } = CalendarDateUntil(S2, C2, U2, L2), { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(R2, import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(y2)), import_jsbi.default.add(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(I2)), import_jsbi.default.add(import_jsbi.default.BigInt(l2), import_jsbi.default.BigInt(w2)), import_jsbi.default.add(import_jsbi.default.BigInt(d2), import_jsbi.default.BigInt(D2)), import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.BigInt(G2)), import_jsbi.default.add(import_jsbi.default.BigInt(c2), import_jsbi.default.BigInt(v2)), O2);
  } else {
    const e2 = GetIntrinsic("%Temporal.Instant%"), j2 = GetSlot(C2, g), $2 = GetSlot(C2, p), k2 = AddZonedDateTime(GetSlot(C2, S), j2, $2, t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), U2 = AddZonedDateTime(new e2(k2), j2, $2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2);
    "year" !== O2 && "month" !== O2 && "week" !== O2 && "day" !== O2 ? (b2 = 0, E2 = 0, M2 = 0, R2 = 0, { hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceInstant(GetSlot(C2, n), U2, 1, "nanosecond", O2, "halfExpand")) : { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceZonedDateTime(GetSlot(C2, n), U2, j2, $2, O2, Te(null));
  }
  else {
    if ("year" === O2 || "month" === O2 || "week" === O2) throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
    b2 = E2 = M2 = 0, { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(a2 + f2, import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(y2)), import_jsbi.default.add(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(I2)), import_jsbi.default.add(import_jsbi.default.BigInt(l2), import_jsbi.default.BigInt(w2)), import_jsbi.default.add(import_jsbi.default.BigInt(d2), import_jsbi.default.BigInt(D2)), import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.BigInt(G2)), import_jsbi.default.add(import_jsbi.default.BigInt(c2), import_jsbi.default.BigInt(v2)), O2);
  }
  return RejectDuration(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2), {
    years: b2,
    months: E2,
    weeks: M2,
    days: R2,
    hours: F2,
    minutes: Y2,
    seconds: P2,
    milliseconds: Z2,
    microseconds: B2,
    nanoseconds: N2
  };
}
__name(AddDuration, "AddDuration");
function AddInstant(t2, r2, o2, n2, a2, i2, s2) {
  let l2 = Ie;
  l2 = import_jsbi.default.add(l2, import_jsbi.default.BigInt(s2)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(i2), De)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(a2), Ge)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(n2), ve)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(6e10))), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), import_jsbi.default.BigInt(36e11)));
  const d2 = import_jsbi.default.add(t2, l2);
  return ValidateEpochNanoseconds(d2), d2;
}
__name(AddInstant, "AddInstant");
function AddDateTime(e2, t2, r2, o2, n2, a2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  let v2 = f2, { deltaDays: C2, hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 } = AddTime(o2, n2, a2, d2, m2, c2, y2, I2, S2, g2, w2, D2);
  v2 += C2;
  const Y2 = GetIntrinsic("%Temporal.Duration%"), P2 = CalendarDateAdd(h2, CreateTemporalDate(e2, t2, r2, h2), new Y2(u2, T2, p2, v2, 0, 0, 0, 0, 0, 0), G2);
  return {
    year: GetSlot(P2, i),
    month: GetSlot(P2, s),
    day: GetSlot(P2, l),
    hour: O2,
    minute: b2,
    second: E2,
    millisecond: M2,
    microsecond: R2,
    nanosecond: F2
  };
}
__name(AddDateTime, "AddDateTime");
function AddZonedDateTime(e2, t2, r2, o2, a2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  const v2 = GetIntrinsic("%Temporal.Duration%");
  if (0 === DurationSign(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0)) return AddInstant(GetSlot(e2, n), y2, I2, S2, g2, w2, D2);
  const C2 = GetPlainDateTimeFor(t2, e2, r2), O2 = CalendarDateAdd(r2, CreateTemporalDate(GetSlot(C2, i), GetSlot(C2, s), GetSlot(C2, l), r2), new v2(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0), G2), b2 = CreateTemporalDateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(C2, d), GetSlot(C2, m), GetSlot(C2, c), GetSlot(C2, h), GetSlot(C2, u), GetSlot(C2, T), r2);
  return AddInstant(GetSlot(GetInstantFor(t2, b2, "compatible"), n), y2, I2, S2, g2, w2, D2);
}
__name(AddZonedDateTime, "AddZonedDateTime");
function AddDurationToOrSubtractDurationFromDuration(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1;
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2);
  const p2 = ToRelativeTemporalObject(GetOptionsObject(o2));
  ({ years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = AddDuration(GetSlot(t2, w), GetSlot(t2, D), GetSlot(t2, G), GetSlot(t2, v), GetSlot(t2, C), GetSlot(t2, O), GetSlot(t2, b), GetSlot(t2, E), GetSlot(t2, M), GetSlot(t2, R), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, p2));
  return new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, d2, m2, c2, h2, u2, T2);
}
__name(AddDurationToOrSubtractDurationFromDuration, "AddDurationToOrSubtractDurationFromDuration");
function AddDurationToOrSubtractDurationFromInstant(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = (/* @__PURE__ */ __name(function ToLimitedTemporalDuration(e3, t3) {
    let r3 = ToTemporalDurationRecord(e3);
    for (const e4 of t3) if (0 !== r3[e4]) throw new RangeError(`Duration field ${e4} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
    return r3;
  }, "ToLimitedTemporalDuration"))(r2, [
    "years",
    "months",
    "weeks",
    "days"
  ]), c2 = AddInstant(GetSlot(t2, n), o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * d2, o2 * m2);
  return new (GetIntrinsic("%Temporal.Instant%"))(c2);
}
__name(AddDurationToOrSubtractDurationFromInstant, "AddDurationToOrSubtractDurationFromInstant");
function AddDurationToOrSubtractDurationFromPlainDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: f2, weeks: y2, days: I2, hours: S2, minutes: g2, seconds: w2, milliseconds: D2, microseconds: G2, nanoseconds: v2 } = ToTemporalDurationRecord(r2), C2 = GetOptionsObject(o2), O2 = GetSlot(t2, p), { year: b2, month: E2, day: M2, hour: R2, minute: F2, second: Y2, millisecond: P2, microsecond: Z2, nanosecond: B2 } = AddDateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), O2, n2 * a2, n2 * f2, n2 * y2, n2 * I2, n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, C2);
  return CreateTemporalDateTime(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, O2);
}
__name(AddDurationToOrSubtractDurationFromPlainDateTime, "AddDurationToOrSubtractDurationFromPlainDateTime");
function AddDurationToOrSubtractDurationFromPlainTime(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: n2, minutes: a2, seconds: i2, milliseconds: s2, microseconds: l2, nanoseconds: p2 } = ToTemporalDurationRecord(r2);
  let { hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = AddTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), o2 * n2, o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * p2);
  ({ hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = RegulateTime(f2, y2, I2, S2, g2, w2, "reject"));
  return new (GetIntrinsic("%Temporal.PlainTime%"))(f2, y2, I2, S2, g2, w2);
}
__name(AddDurationToOrSubtractDurationFromPlainTime, "AddDurationToOrSubtractDurationFromPlainTime");
function AddDurationToOrSubtractDurationFromPlainYearMonth(e2, t2, r2, o2) {
  let n2 = ToTemporalDurationRecord(r2);
  "subtract" === e2 && (n2 = {
    years: -n2.years,
    months: -n2.months,
    weeks: -n2.weeks,
    days: -n2.days,
    hours: -n2.hours,
    minutes: -n2.minutes,
    seconds: -n2.seconds,
    milliseconds: -n2.milliseconds,
    microseconds: -n2.microseconds,
    nanoseconds: -n2.nanoseconds
  });
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = n2;
  ({ days: l2 } = BalanceDuration(l2, d2, m2, c2, h2, u2, T2, "day"));
  const f2 = GetOptionsObject(o2), y2 = GetSlot(t2, p), I2 = CalendarFields(y2, [
    "monthCode",
    "year"
  ]), S2 = PrepareTemporalFields(t2, I2, []), g2 = Te(null);
  CopyDataProperties(g2, S2, []), S2.day = 1;
  let w2 = CalendarDateFromFields(y2, S2);
  const D2 = DurationSign(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), G2 = GetMethod(y2, "dateAdd"), v2 = GetIntrinsic("%Temporal.Duration%");
  if (D2 < 0) {
    const e3 = CalendarDateAdd(y2, w2, new v2(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G2), t3 = CalendarDateAdd(y2, e3, new v2(0, 0, 0, -1, 0, 0, 0, 0, 0, 0), void 0, G2);
    g2.day = CalendarDay(y2, t3), w2 = CalendarDateFromFields(y2, g2);
  }
  const C2 = new v2(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), O2 = CopyOptions(f2);
  return CalendarYearMonthFromFields(y2, PrepareTemporalFields(CalendarDateAdd(y2, w2, C2, f2, G2), I2, []), O2);
}
__name(AddDurationToOrSubtractDurationFromPlainYearMonth, "AddDurationToOrSubtractDurationFromPlainYearMonth");
function AddDurationToOrSubtractDurationFromZonedDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2), f2 = GetOptionsObject(o2), y2 = GetSlot(t2, g), I2 = GetSlot(t2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t2, S), y2, I2, n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, f2), y2, I2);
}
__name(AddDurationToOrSubtractDurationFromZonedDateTime, "AddDurationToOrSubtractDurationFromZonedDateTime");
function RoundNumberToIncrement(t2, r2, o2) {
  if (import_jsbi.default.equal(r2, Se)) return t2;
  let { quotient: n2, remainder: a2 } = divmod(t2, r2);
  if (import_jsbi.default.equal(a2, Ie)) return t2;
  const i2 = import_jsbi.default.lessThan(a2, Ie) ? -1 : 1, s2 = abs(import_jsbi.default.multiply(a2, import_jsbi.default.BigInt(2))), l2 = import_jsbi.default.equal(s2, r2), d2 = import_jsbi.default.greaterThan(s2, r2);
  switch (o2) {
    case "ceil":
      i2 > 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "floor":
      i2 < 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "expand":
      n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2));
      break;
    case "trunc":
      break;
    case "halfCeil":
      (d2 || l2 && i2 > 0) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfFloor":
      (d2 || l2 && i2 < 0) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfExpand":
      (d2 || l2) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfTrunc":
      d2 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfEven":
      (d2 || l2 && 1 === import_jsbi.default.toNumber(import_jsbi.default.remainder(abs(n2), import_jsbi.default.BigInt(2)))) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
  }
  return import_jsbi.default.multiply(n2, r2);
}
__name(RoundNumberToIncrement, "RoundNumberToIncrement");
function RoundInstant(t2, r2, o2, n2) {
  let { remainder: a2 } = NonNegativeBigIntDivmod(t2, Ee);
  const i2 = import_jsbi.default.subtract(t2, a2), s2 = RoundNumberToIncrement(a2, import_jsbi.default.BigInt(_e[o2] * r2), n2);
  return import_jsbi.default.add(i2, s2);
}
__name(RoundInstant, "RoundInstant");
function RoundISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2 = 864e11) {
  const { deltaDays: u2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 } = RoundTime(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { year: g2, month: w2, day: D2 } = BalanceISODate(e2, t2, r2 + u2);
  return {
    year: g2,
    month: w2,
    day: D2,
    hour: T2,
    minute: p2,
    second: f2,
    millisecond: y2,
    microsecond: I2,
    nanosecond: S2
  };
}
__name(RoundISODateTime, "RoundISODateTime");
function RoundTime(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2 = 864e11) {
  let c2 = Ie;
  switch (l2) {
    case "day":
    case "hour":
      c2 = import_jsbi.default.BigInt(t2);
    case "minute":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, ge), import_jsbi.default.BigInt(r2));
    case "second":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, ge), import_jsbi.default.BigInt(o2));
    case "millisecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, De), import_jsbi.default.BigInt(n2));
    case "microsecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, De), import_jsbi.default.BigInt(a2));
    case "nanosecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, De), import_jsbi.default.BigInt(i2));
  }
  const h2 = "day" === l2 ? m2 : _e[l2], u2 = RoundNumberToIncrement(c2, import_jsbi.default.BigInt(h2 * s2), d2), T2 = import_jsbi.default.toNumber(import_jsbi.default.divide(u2, import_jsbi.default.BigInt(h2)));
  switch (l2) {
    case "day":
      return {
        deltaDays: T2,
        hour: 0,
        minute: 0,
        second: 0,
        millisecond: 0,
        microsecond: 0,
        nanosecond: 0
      };
    case "hour":
      return BalanceTime(T2, 0, 0, 0, 0, 0);
    case "minute":
      return BalanceTime(t2, T2, 0, 0, 0, 0);
    case "second":
      return BalanceTime(t2, r2, T2, 0, 0, 0);
    case "millisecond":
      return BalanceTime(t2, r2, o2, T2, 0, 0);
    case "microsecond":
      return BalanceTime(t2, r2, o2, n2, T2, 0);
    case "nanosecond":
      return BalanceTime(t2, r2, o2, n2, a2, T2);
    default:
      throw new Error(`Invalid unit ${l2}`);
  }
}
__name(RoundTime, "RoundTime");
function DaysUntil(e2, t2) {
  return DifferenceISODate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), "day").days;
}
__name(DaysUntil, "DaysUntil");
function MoveRelativeDate(e2, t2, r2, o2) {
  const n2 = CalendarDateAdd(e2, t2, r2, void 0, o2);
  return {
    relativeTo: n2,
    days: DaysUntil(t2, n2)
  };
}
__name(MoveRelativeDate, "MoveRelativeDate");
function MoveRelativeZonedDateTime(e2, t2, r2, o2, n2) {
  const a2 = GetSlot(e2, g), i2 = GetSlot(e2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e2, S), a2, i2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0), a2, i2);
}
__name(MoveRelativeZonedDateTime, "MoveRelativeZonedDateTime");
function AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, w2 = n2, D2 = a2, G2 = i2, v2 = s2, C2 = l2, O2 = d2, b2 = m2;
  if (!IsTemporalZonedDateTime(T2) || "year" === h2 || "month" === h2 || "week" === h2 || "day" === h2 || "nanosecond" === h2 && 1 === c2) return {
    years: f2,
    months: y2,
    weeks: I2,
    days: w2,
    hours: D2,
    minutes: G2,
    seconds: v2,
    milliseconds: C2,
    microseconds: O2,
    nanoseconds: b2
  };
  let E2 = TotalDurationNanoseconds(0, D2, G2, v2, C2, O2, b2, 0);
  const M2 = se(import_jsbi.default.toNumber(E2)), R2 = GetSlot(T2, g), F2 = GetSlot(T2, p), Y2 = AddZonedDateTime(GetSlot(T2, S), R2, F2, f2, y2, I2, w2, 0, 0, 0, 0, 0, 0), P2 = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(Y2), R2, F2, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0), Z2 = import_jsbi.default.subtract(P2, Y2);
  return import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(E2, Z2), import_jsbi.default.BigInt(M2)), Ie) && ({ years: f2, months: y2, weeks: I2, days: w2 } = AddDuration(f2, y2, I2, w2, 0, 0, 0, 0, 0, 0, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0, T2), E2 = RoundInstant(import_jsbi.default.subtract(E2, Z2), c2, h2, u2), { hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(E2), "hour")), {
    years: f2,
    months: y2,
    weeks: I2,
    days: w2,
    hours: D2,
    minutes: G2,
    seconds: v2,
    milliseconds: C2,
    microseconds: O2,
    nanoseconds: b2
  };
}
__name(AdjustRoundedDurationDays, "AdjustRoundedDurationDays");
function RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, S2 = n2, g2 = a2, w2 = i2, D2 = s2, G2 = l2, v2 = d2, C2 = import_jsbi.default.BigInt(m2);
  const O2 = GetIntrinsic("%Temporal.Duration%");
  let b2, E2, M2, R2, F2 = T2;
  if (F2) {
    if (IsTemporalZonedDateTime(F2)) E2 = F2, F2 = ToTemporalDate(F2);
    else if (!IsTemporalDate(F2)) throw new TypeError("starting point must be PlainDate or ZonedDateTime");
    b2 = GetSlot(F2, p);
  }
  if ("year" === h2 || "month" === h2 || "week" === h2 || "day" === h2) {
    let t3, r3, o3;
    C2 = TotalDurationNanoseconds(0, g2, w2, D2, G2, v2, m2, 0), E2 && (t3 = MoveRelativeZonedDateTime(E2, f2, y2, I2, S2)), { days: r3, nanoseconds: C2, dayLengthNs: o3 } = NanosecondsToDays(C2, t3), M2 = import_jsbi.default.BigInt(o3), S2 += r3, g2 = w2 = D2 = G2 = v2 = 0;
  }
  switch (h2) {
    case "year": {
      if (!b2) throw new RangeError("A starting point is required for years rounding");
      const t3 = new O2(f2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = CalendarDateAdd(b2, F2, new O2(0, 0, 0, S2), void 0, r3), i3 = Te(null);
      i3.largestUnit = "year";
      const s3 = CalendarDateUntil(b2, F2, a3, i3).years;
      f2 += s3;
      const l3 = F2;
      F2 = CalendarDateAdd(b2, F2, new O2(s3), void 0, r3);
      S2 -= DaysUntil(l3, F2);
      const d3 = new O2(S2 < 0 ? -1 : 1);
      let { days: m3 } = MoveRelativeDate(b2, F2, d3, r3);
      m3 = ae(m3);
      const h3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(m3), M2);
      C2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(f2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(S2), M2)), C2);
      const T3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, h3), f2 = import_jsbi.default.toNumber(import_jsbi.default.divide(T3, h3)), C2 = Ie, y2 = I2 = S2 = 0;
      break;
    }
    case "month": {
      if (!b2) throw new RangeError("A starting point is required for months rounding");
      const t3 = new O2(f2, y2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = se(S2), i3 = new O2(0, S2 < 0 ? -1 : 1);
      let s3;
      for ({ relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3); ae(S2) >= ae(s3); ) y2 += a3, S2 -= s3, { relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3);
      s3 = ae(s3);
      const l3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(s3), M2);
      C2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(y2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(S2), M2)), C2);
      const d3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, l3), y2 = import_jsbi.default.toNumber(import_jsbi.default.divide(d3, l3)), C2 = Ie, I2 = S2 = 0;
      break;
    }
    case "week": {
      if (!b2) throw new RangeError("A starting point is required for weeks rounding");
      const t3 = se(S2), r3 = new O2(0, 0, S2 < 0 ? -1 : 1), o3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0;
      let n3;
      for ({ relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3); ae(S2) >= ae(n3); ) I2 += t3, S2 -= n3, { relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3);
      n3 = ae(n3);
      const a3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(n3), M2);
      C2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(a3, import_jsbi.default.BigInt(I2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(S2), M2)), C2);
      const i3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(a3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, a3), I2 = import_jsbi.default.toNumber(import_jsbi.default.divide(i3, a3)), C2 = Ie, S2 = 0;
      break;
    }
    case "day": {
      const t3 = M2;
      C2 = import_jsbi.default.add(import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(S2)), C2);
      const r3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, t3), S2 = import_jsbi.default.toNumber(import_jsbi.default.divide(r3, t3)), C2 = Ie;
      break;
    }
    case "hour": {
      const t3 = 36e11;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(g2), import_jsbi.default.BigInt(36e11));
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), import_jsbi.default.BigInt(6e10))), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ve)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      g2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, w2 = D2 = G2 = v2 = 0;
      break;
    }
    case "minute": {
      const t3 = 6e10;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), import_jsbi.default.BigInt(6e10));
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ve)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      w2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, D2 = G2 = v2 = 0;
      break;
    }
    case "second": {
      const t3 = 1e9;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ve);
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      D2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, G2 = v2 = 0;
      break;
    }
    case "millisecond": {
      const t3 = 1e6;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge);
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      G2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, v2 = 0;
      break;
    }
    case "microsecond": {
      const t3 = 1e3;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De);
      r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      v2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie;
      break;
    }
    case "nanosecond":
      R2 = import_jsbi.default.toNumber(C2), C2 = RoundNumberToIncrement(import_jsbi.default.BigInt(C2), import_jsbi.default.BigInt(c2), u2);
  }
  return {
    years: f2,
    months: y2,
    weeks: I2,
    days: S2,
    hours: g2,
    minutes: w2,
    seconds: D2,
    milliseconds: G2,
    microseconds: v2,
    nanoseconds: import_jsbi.default.toNumber(C2),
    total: R2
  };
}
__name(RoundDuration, "RoundDuration");
function CompareISODate(e2, t2, r2, o2, n2, a2) {
  for (const [i2, s2] of [
    [
      e2,
      o2
    ],
    [
      t2,
      n2
    ],
    [
      r2,
      a2
    ]
  ]) if (i2 !== s2) return ComparisonResult(i2 - s2);
  return 0;
}
__name(CompareISODate, "CompareISODate");
function NonNegativeBigIntDivmod(t2, r2) {
  let { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return import_jsbi.default.lessThan(n2, Ie) && (o2 = import_jsbi.default.subtract(o2, Se), n2 = import_jsbi.default.add(n2, r2)), {
    quotient: o2,
    remainder: n2
  };
}
__name(NonNegativeBigIntDivmod, "NonNegativeBigIntDivmod");
function BigIntFloorDiv(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return isZero(n2) || !isNegativeJSBI(t2) == !isNegativeJSBI(r2) ? o2 : import_jsbi.default.subtract(o2, Se);
}
__name(BigIntFloorDiv, "BigIntFloorDiv");
function BigIntDivideToNumber(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return import_jsbi.default.toNumber(o2) + import_jsbi.default.toNumber(n2) / import_jsbi.default.toNumber(r2);
}
__name(BigIntDivideToNumber, "BigIntDivideToNumber");
function ToBigIntExternal(e2) {
  const t2 = ToBigInt(e2);
  return void 0 !== globalThis.BigInt ? globalThis.BigInt(t2.toString(10)) : t2;
}
__name(ToBigIntExternal, "ToBigIntExternal");
function ToBigInt(t2) {
  let r2 = t2;
  if ("object" == typeof t2) {
    const e2 = t2[Symbol.toPrimitive];
    e2 && "function" == typeof e2 && (r2 = fe(e2, t2, [
      "number"
    ]));
  }
  if ("number" == typeof r2) throw new TypeError("cannot convert number to bigint");
  return "bigint" == typeof r2 ? import_jsbi.default.BigInt(r2.toString(10)) : import_jsbi.default.BigInt(r2);
}
__name(ToBigInt, "ToBigInt");
var Ve = (() => {
  let t2 = import_jsbi.default.BigInt(Date.now() % 1e6);
  return () => {
    const r2 = import_jsbi.default.BigInt(Date.now()), o2 = import_jsbi.default.add(import_jsbi.default.multiply(r2, Ge), t2);
    return t2 = import_jsbi.default.remainder(r2, Ge), import_jsbi.default.greaterThan(o2, Re) ? Re : import_jsbi.default.lessThan(o2, Me) ? Me : o2;
  };
})();
function DefaultTimeZone() {
  return new re().resolvedOptions().timeZone;
}
__name(DefaultTimeZone, "DefaultTimeZone");
function ComparisonResult(e2) {
  return e2 < 0 ? -1 : e2 > 0 ? 1 : e2;
}
__name(ComparisonResult, "ComparisonResult");
function GetOptionsObject(e2) {
  if (void 0 === e2) return Te(null);
  if (IsObject(e2) && null !== e2) return e2;
  throw new TypeError("Options parameter must be an object, not " + (null === e2 ? "null" : typeof e2));
}
__name(GetOptionsObject, "GetOptionsObject");
function CreateOnePropObject(e2, t2) {
  const r2 = Te(null);
  return r2[e2] = t2, r2;
}
__name(CreateOnePropObject, "CreateOnePropObject");
function CopyOptions(e2) {
  const t2 = Te(null);
  return CopyDataProperties(t2, GetOptionsObject(e2), []), t2;
}
__name(CopyOptions, "CopyOptions");
function GetOption(e2, t2, r2, o2) {
  let n2 = e2[t2];
  if (void 0 !== n2) {
    if (n2 = ToString(n2), !r2.includes(n2)) throw new RangeError(`${t2} must be one of ${r2.join(", ")}, not ${n2}`);
    return n2;
  }
  return o2;
}
__name(GetOption, "GetOption");
function IsBuiltinCalendar(e2) {
  return je.includes(ASCIILowercase(e2));
}
__name(IsBuiltinCalendar, "IsBuiltinCalendar");
function ASCIILowercase(e2) {
  return e2.replace(/[A-Z]/g, (e3) => {
    const t2 = e3.charCodeAt(0);
    return String.fromCharCode(t2 + 32);
  });
}
__name(ASCIILowercase, "ASCIILowercase");
var ze = new RegExp(`^${W.source}$`);
function bisect(t2, r2, o2, n2 = t2(r2), a2 = t2(o2)) {
  let i2 = import_jsbi.default.BigInt(r2), s2 = import_jsbi.default.BigInt(o2), l2 = n2, d2 = a2;
  for (; import_jsbi.default.greaterThan(import_jsbi.default.subtract(s2, i2), Se); ) {
    const r3 = import_jsbi.default.divide(import_jsbi.default.add(i2, s2), import_jsbi.default.BigInt(2)), o3 = t2(r3);
    if (o3 === l2) i2 = r3, l2 = o3;
    else {
      if (o3 !== d2) throw new Error(`invalid state in bisection ${l2} - ${o3} - ${d2}`);
      s2 = r3, d2 = o3;
    }
  }
  return s2;
}
__name(bisect, "bisect");
var _e = {
  hour: 36e11,
  minute: 6e10,
  second: 1e9,
  millisecond: 1e6,
  microsecond: 1e3,
  nanosecond: 1
};
var Je = Symbol("date");
var Ke = Symbol("ym");
var Xe = Symbol("md");
var Qe = Symbol("time");
var et = Symbol("datetime");
var tt = Symbol("instant");
var rt = Symbol("original");
var ot = Symbol("timezone");
var nt = Symbol("calendar-id");
var at = Symbol("locale");
var it = Symbol("options");
var descriptor = /* @__PURE__ */ __name((e2) => ({
  value: e2,
  enumerable: true,
  writable: false,
  configurable: true
}), "descriptor");
var st = globalThis.Intl.DateTimeFormat;
var lt = Object.assign;
var dt = Object.prototype.hasOwnProperty;
var mt = Reflect.apply;
function getPropLazy(e2, t2) {
  let r2 = e2[t2];
  return "function" == typeof r2 && (r2 = new st(e2[at], r2(e2[it])), e2[t2] = r2), r2;
}
__name(getPropLazy, "getPropLazy");
function DateTimeFormatImpl(e2, t2 = {}) {
  if (!(this instanceof DateTimeFormatImpl)) return new DateTimeFormatImpl(e2, t2);
  const r2 = void 0 !== t2, o2 = r2 ? lt({}, t2) : {}, n2 = new st(e2, o2), a2 = n2.resolvedOptions();
  if (r2) {
    const e3 = lt({}, a2);
    for (const t3 in e3) mt(dt, o2, [
      t3
    ]) || delete e3[t3];
    this[it] = e3;
  } else this[it] = o2;
  this[at] = a2.locale, this[rt] = n2, this[ot] = a2.timeZone, this[nt] = a2.calendar, this[Je] = dateAmend, this[Ke] = yearMonthAmend, this[Xe] = monthDayAmend, this[Qe] = timeAmend, this[et] = datetimeAmend, this[tt] = instantAmend;
}
__name(DateTimeFormatImpl, "DateTimeFormatImpl");
Object.defineProperty(DateTimeFormatImpl, "name", {
  writable: true,
  value: "DateTimeFormat"
}), DateTimeFormatImpl.supportedLocalesOf = function(e2, t2) {
  return st.supportedLocalesOf(e2, t2);
};
var ct = {
  resolvedOptions: descriptor(/* @__PURE__ */ __name(function resolvedOptions() {
    return this[rt].resolvedOptions();
  }, "resolvedOptions")),
  format: descriptor(/* @__PURE__ */ __name(function format(e2, ...t2) {
    let { instant: r2, formatter: o2 } = extractOverrides(e2, this);
    if (r2 && o2) return o2.format(r2.epochMilliseconds);
    return this[rt].format(e2, ...t2);
  }, "format")),
  formatRange: descriptor(/* @__PURE__ */ __name(function formatRange(e2, t2) {
    if (isTemporalObject(e2) || isTemporalObject(t2)) {
      if (!sameTemporalType(e2, t2)) throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
      const { instant: r2, formatter: o2 } = extractOverrides(e2, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
      if (r2 && n2 && o2 && a2 && o2 === a2) return o2.formatRange(r2.epochMilliseconds, n2.epochMilliseconds);
    }
    return this[rt].formatRange(e2, t2);
  }, "formatRange"))
};
"formatToParts" in st.prototype && (ct.formatToParts = descriptor(/* @__PURE__ */ __name(function formatToParts(e2, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e2, this);
  if (r2 && o2) return o2.formatToParts(r2.epochMilliseconds);
  return this[rt].formatToParts(e2, ...t2);
}, "formatToParts"))), "formatRangeToParts" in st.prototype && (ct.formatRangeToParts = descriptor(/* @__PURE__ */ __name(function formatRangeToParts(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2)) throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e2, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2) return o2.formatRangeToParts(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRangeToParts(e2, t2);
}, "formatRangeToParts"))), DateTimeFormatImpl.prototype = Object.create(st.prototype, ct), Object.defineProperty(DateTimeFormatImpl, "prototype", {
  writable: false,
  enumerable: false,
  configurable: false
});
var ht = DateTimeFormatImpl;
function amend(e2 = {}, t2 = {}) {
  const r2 = lt({}, e2);
  for (const e3 of [
    "year",
    "month",
    "day",
    "hour",
    "minute",
    "second",
    "weekday",
    "dayPeriod",
    "timeZoneName",
    "dateStyle",
    "timeStyle"
  ]) r2[e3] = e3 in t2 ? t2[e3] : r2[e3], false !== r2[e3] && void 0 !== r2[e3] || delete r2[e3];
  return r2;
}
__name(amend, "amend");
function timeAmend(e2) {
  let t2 = amend(e2, {
    year: false,
    month: false,
    day: false,
    weekday: false,
    timeZoneName: false,
    dateStyle: false
  });
  return hasTimeOptions(t2) || (t2 = lt({}, t2, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  })), t2;
}
__name(timeAmend, "timeAmend");
function yearMonthAmend(e2) {
  let t2 = amend(e2, {
    day: false,
    hour: false,
    minute: false,
    second: false,
    weekday: false,
    dayPeriod: false,
    timeZoneName: false,
    dateStyle: false,
    timeStyle: false
  });
  return "year" in t2 || "month" in t2 || (t2 = lt(t2, {
    year: "numeric",
    month: "numeric"
  })), t2;
}
__name(yearMonthAmend, "yearMonthAmend");
function monthDayAmend(e2) {
  let t2 = amend(e2, {
    year: false,
    hour: false,
    minute: false,
    second: false,
    weekday: false,
    dayPeriod: false,
    timeZoneName: false,
    dateStyle: false,
    timeStyle: false
  });
  return "month" in t2 || "day" in t2 || (t2 = lt({}, t2, {
    month: "numeric",
    day: "numeric"
  })), t2;
}
__name(monthDayAmend, "monthDayAmend");
function dateAmend(e2) {
  let t2 = amend(e2, {
    hour: false,
    minute: false,
    second: false,
    dayPeriod: false,
    timeZoneName: false,
    timeStyle: false
  });
  return hasDateOptions(t2) || (t2 = lt({}, t2, {
    year: "numeric",
    month: "numeric",
    day: "numeric"
  })), t2;
}
__name(dateAmend, "dateAmend");
function datetimeAmend(e2) {
  let t2 = amend(e2, {
    timeZoneName: false
  });
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  })), t2;
}
__name(datetimeAmend, "datetimeAmend");
function instantAmend(e2) {
  let t2 = e2;
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  })), t2;
}
__name(instantAmend, "instantAmend");
function hasDateOptions(e2) {
  return "year" in e2 || "month" in e2 || "day" in e2 || "weekday" in e2 || "dateStyle" in e2;
}
__name(hasDateOptions, "hasDateOptions");
function hasTimeOptions(e2) {
  return "hour" in e2 || "minute" in e2 || "second" in e2 || "timeStyle" in e2 || "dayPeriod" in e2;
}
__name(hasTimeOptions, "hasTimeOptions");
function isTemporalObject(e2) {
  return IsTemporalDate(e2) || IsTemporalTime(e2) || IsTemporalDateTime(e2) || IsTemporalZonedDateTime(e2) || IsTemporalYearMonth(e2) || IsTemporalMonthDay(e2) || IsTemporalInstant(e2);
}
__name(isTemporalObject, "isTemporalObject");
function sameTemporalType(e2, t2) {
  return !(!isTemporalObject(e2) || !isTemporalObject(t2)) && !(IsTemporalTime(e2) && !IsTemporalTime(t2)) && !(IsTemporalDate(e2) && !IsTemporalDate(t2)) && !(IsTemporalDateTime(e2) && !IsTemporalDateTime(t2)) && !(IsTemporalZonedDateTime(e2) && !IsTemporalZonedDateTime(t2)) && !(IsTemporalYearMonth(e2) && !IsTemporalYearMonth(t2)) && !(IsTemporalMonthDay(e2) && !IsTemporalMonthDay(t2)) && !(IsTemporalInstant(e2) && !IsTemporalInstant(t2));
}
__name(sameTemporalType, "sameTemporalType");
function extractOverrides(e2, t2) {
  const r2 = GetIntrinsic("%Temporal.PlainDateTime%");
  if (IsTemporalTime(e2)) {
    const o2 = new r2(1970, 1, 1, GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T), t2[nt]);
    return {
      instant: GetInstantFor(t2[ot], o2, "compatible"),
      formatter: getPropLazy(t2, Qe)
    };
  }
  if (IsTemporalYearMonth(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if (d2 !== t2[nt]) throw new RangeError(`cannot format PlainYearMonth with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return {
      instant: GetInstantFor(t2[ot], m2, "compatible"),
      formatter: getPropLazy(t2, Ke)
    };
  }
  if (IsTemporalMonthDay(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if (d2 !== t2[nt]) throw new RangeError(`cannot format PlainMonthDay with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return {
      instant: GetInstantFor(t2[ot], m2, "compatible"),
      formatter: getPropLazy(t2, Xe)
    };
  }
  if (IsTemporalDate(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if ("iso8601" !== d2 && d2 !== t2[nt]) throw new RangeError(`cannot format PlainDate with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, t2[nt]);
    return {
      instant: GetInstantFor(t2[ot], m2, "compatible"),
      formatter: getPropLazy(t2, Je)
    };
  }
  if (IsTemporalDateTime(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), f2 = GetSlot(e2, d), y2 = GetSlot(e2, m), I2 = GetSlot(e2, c), S2 = GetSlot(e2, h), g2 = GetSlot(e2, u), w2 = GetSlot(e2, T), D2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if ("iso8601" !== D2 && D2 !== t2[nt]) throw new RangeError(`cannot format PlainDateTime with calendar ${D2} in locale with calendar ${t2[nt]}`);
    let G2 = e2;
    return "iso8601" === D2 && (G2 = new r2(o2, n2, a2, f2, y2, I2, S2, g2, w2, t2[nt])), {
      instant: GetInstantFor(t2[ot], G2, "compatible"),
      formatter: getPropLazy(t2, et)
    };
  }
  if (IsTemporalZonedDateTime(e2)) throw new TypeError("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
  return IsTemporalInstant(e2) ? {
    instant: e2,
    formatter: getPropLazy(t2, tt)
  } : {};
}
__name(extractOverrides, "extractOverrides");
var ut = Object.freeze({
  __proto__: null,
  DateTimeFormat: ht
});
var Instant = class _Instant {
  static {
    __name(this, "Instant");
  }
  constructor(e2) {
    if (arguments.length < 1) throw new TypeError("missing argument: epochNanoseconds is required");
    const t2 = ToBigInt(e2);
    ValidateEpochNanoseconds(t2), N(this), SetSlot(this, n, t2);
  }
  get epochSeconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = import_jsbi.default.BigInt(GetSlot(this, n));
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(import_jsbi.default.BigInt(GetSlot(this, n)), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(import_jsbi.default.BigInt(GetSlot(this, n)));
  }
  add(e2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    if (void 0 === e2) throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, {
      hour: 24,
      minute: 1440,
      second: 86400,
      millisecond: 864e5,
      microsecond: 864e8,
      nanosecond: 864e11
    }[a2], true);
    const i2 = RoundInstant(GetSlot(this, n), r2, a2, o2);
    return new _Instant(i2);
  }
  equals(t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalInstant(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return import_jsbi.default.equal(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(a2));
  }
  toString(e2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    let i2 = t2.timeZone;
    void 0 !== i2 && (i2 = ToTemporalTimeZoneSlotValue(i2));
    const { precision: s2, unit: l2, increment: d2 } = ToSecondsStringPrecisionRecord(a2, r2), m2 = RoundInstant(GetSlot(this, n), d2, l2, o2);
    return TemporalInstantToString(new _Instant(m2), i2, s2);
  }
  toJSON() {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return TemporalInstantToString(this, void 0, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.Instant");
  }
  toZonedDateTime(e2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument in toZonedDateTime");
    const t2 = e2.calendar;
    if (void 0 === t2) throw new TypeError("missing calendar property in toZonedDateTime");
    const r2 = ToTemporalCalendarSlotValue(t2), o2 = e2.timeZone;
    if (void 0 === o2) throw new TypeError("missing timeZone property in toZonedDateTime");
    const a2 = ToTemporalTimeZoneSlotValue(o2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), a2, r2);
  }
  toZonedDateTimeISO(e2) {
    if (!IsTemporalInstant(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, "iso8601");
  }
  static fromEpochSeconds(t2) {
    const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), ve);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMilliseconds(t2) {
    const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), Ge);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMicroseconds(t2) {
    const r2 = ToBigInt(t2), o2 = import_jsbi.default.multiply(r2, De);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochNanoseconds(e2) {
    const t2 = ToBigInt(e2);
    return ValidateEpochNanoseconds(t2), new _Instant(t2);
  }
  static from(e2) {
    return IsTemporalInstant(e2) ? new _Instant(GetSlot(e2, n)) : ToTemporalInstant(e2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalInstant(t2), a2 = ToTemporalInstant(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return import_jsbi.default.lessThan(i2, s2) ? -1 : import_jsbi.default.greaterThan(i2, s2) ? 1 : 0;
  }
};
MakeIntrinsicClass(Instant, "Temporal.Instant");
var Tt = Array.prototype.includes;
var pt = Array.prototype.push;
var ft = globalThis.Intl.DateTimeFormat;
var yt = Array.prototype.sort;
var It = Math.abs;
var St = Math.floor;
var gt = Object.create;
var wt = Object.entries;
var Dt = Set;
var Gt = Reflect.ownKeys;
var vt = Set.prototype.add;
var Ct = Set.prototype.values;
var Ot = {};
var Calendar = class {
  static {
    __name(this, "Calendar");
  }
  constructor(e2) {
    if (arguments.length < 1) throw new RangeError("missing argument: id is required");
    const t2 = ToString(e2);
    if (!IsBuiltinCalendar(t2)) throw new RangeError(`invalid calendar identifier ${t2}`);
    N(this), SetSlot(this, F, ASCIILowercase(t2));
  }
  get id() {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  dateFromFields(e2, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].dateFromFields(e2, r2, o2);
  }
  yearMonthFromFields(e2, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].yearMonthFromFields(e2, r2, o2);
  }
  monthDayFromFields(e2, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].monthDayFromFields(e2, r2, o2);
  }
  fields(e2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = [], r2 = /* @__PURE__ */ new Set([
      "year",
      "month",
      "monthCode",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond",
      "microsecond",
      "nanosecond"
    ]);
    for (const o2 of e2) {
      if ("string" != typeof o2) throw new TypeError("invalid fields");
      if (!r2.has(o2)) throw new RangeError(`invalid field name ${o2}`);
      r2.delete(o2), pt.call(t2, o2);
    }
    return Ot[GetSlot(this, F)].fields(t2);
  }
  mergeFields(e2, t2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const r2 = ToObject(e2), o2 = gt(null);
    CopyDataProperties(o2, r2, [], [
      void 0
    ]);
    const n2 = ToObject(t2), a2 = gt(null);
    CopyDataProperties(a2, n2, [], [
      void 0
    ]);
    const i2 = Gt(a2), s2 = Ot[GetSlot(this, F)].fieldKeysToIgnore(i2), l2 = gt(null), d2 = Gt(o2);
    for (const e3 of d2) {
      let t3;
      t3 = Call(Tt, s2, [
        e3
      ]) ? a2[e3] : o2[e3], void 0 !== t3 && (l2[e3] = t3);
    }
    return CopyDataProperties(l2, a2, []), l2;
  }
  dateAdd(e2, t2, r2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDuration(t2), a2 = ToTemporalOverflow(GetOptionsObject(r2)), { days: i2 } = BalanceDuration(GetSlot(n2, v), GetSlot(n2, C), GetSlot(n2, O), GetSlot(n2, b), GetSlot(n2, E), GetSlot(n2, M), GetSlot(n2, R), "day"), s2 = GetSlot(this, F);
    return Ot[s2].dateAdd(o2, GetSlot(n2, w), GetSlot(n2, D), GetSlot(n2, G), i2, a2, s2);
  }
  dateUntil(e2, t2, r2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDate(t2);
    let a2 = GetTemporalUnit(GetOptionsObject(r2), "largestUnit", "date", "auto");
    "auto" === a2 && (a2 = "day");
    const { years: i2, months: s2, weeks: l2, days: d2 } = Ot[GetSlot(this, F)].dateUntil(o2, n2, a2);
    return new (GetIntrinsic("%Temporal.Duration%"))(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
  }
  year(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].year(t2);
  }
  month(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    if (IsTemporalMonthDay(t2)) throw new TypeError("use monthCode on PlainMonthDay instead");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].month(t2);
  }
  monthCode(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthCode(t2);
  }
  day(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].day(t2);
  }
  era(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].era(t2);
  }
  eraYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].eraYear(t2);
  }
  dayOfWeek(e2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].dayOfWeek(t2);
  }
  dayOfYear(e2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].dayOfYear(t2);
  }
  weekOfYear(e2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].weekOfYear(t2);
  }
  yearOfWeek(e2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].yearOfWeek(t2);
  }
  daysInWeek(e2) {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].daysInWeek(t2);
  }
  daysInMonth(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInMonth(t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInYear(t2);
  }
  monthsInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthsInYear(t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].inLeapYear(t2);
  }
  toString() {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  toJSON() {
    if (!IsTemporalCalendar(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  static from(e2) {
    return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e2));
  }
};
function monthCodeNumberPart(e2) {
  if (!e2.startsWith("M")) throw new RangeError(`Invalid month code: ${e2}.  Month codes must start with M.`);
  const t2 = +e2.slice(1);
  if (isNaN(t2)) throw new RangeError(`Invalid month code: ${e2}`);
  return t2;
}
__name(monthCodeNumberPart, "monthCodeNumberPart");
function buildMonthCode(e2, t2 = false) {
  return `M${e2.toString().padStart(2, "0")}${t2 ? "L" : ""}`;
}
__name(buildMonthCode, "buildMonthCode");
function resolveNonLunisolarMonth(e2, t2, r2 = 12) {
  let { month: o2, monthCode: n2 } = e2;
  if (void 0 === n2) {
    if (void 0 === o2) throw new TypeError("Either month or monthCode are required");
    "reject" === t2 && RejectToRange(o2, 1, r2), "constrain" === t2 && (o2 = ConstrainToRange(o2, 1, r2)), n2 = buildMonthCode(o2);
  } else {
    const e3 = monthCodeNumberPart(n2);
    if (void 0 !== o2 && o2 !== e3) throw new RangeError(`monthCode ${n2} and month ${o2} must match if both are present`);
    if (n2 !== buildMonthCode(e3)) throw new RangeError(`Invalid month code: ${n2}`);
    if (o2 = e3, o2 < 1 || o2 > r2) throw new RangeError(`Invalid monthCode: ${n2}`);
  }
  return {
    ...e2,
    month: o2,
    monthCode: n2
  };
}
__name(resolveNonLunisolarMonth, "resolveNonLunisolarMonth");
MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), DefineIntrinsic("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd), DefineIntrinsic("Temporal.Calendar.prototype.dateFromFields", Calendar.prototype.dateFromFields), DefineIntrinsic("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil), DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day), DefineIntrinsic("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek), DefineIntrinsic("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear), DefineIntrinsic("Temporal.Calendar.prototype.daysInMonth", Calendar.prototype.daysInMonth), DefineIntrinsic("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek), DefineIntrinsic("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear), DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era), DefineIntrinsic("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear), DefineIntrinsic("Temporal.Calendar.prototype.fields", Calendar.prototype.fields), DefineIntrinsic("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear), DefineIntrinsic("Temporal.Calendar.prototype.mergeFields", Calendar.prototype.mergeFields), DefineIntrinsic("Temporal.Calendar.prototype.month", Calendar.prototype.month), DefineIntrinsic("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode), DefineIntrinsic("Temporal.Calendar.prototype.monthDayFromFields", Calendar.prototype.monthDayFromFields), DefineIntrinsic("Temporal.Calendar.prototype.monthsInYear", Calendar.prototype.monthsInYear), DefineIntrinsic("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear), DefineIntrinsic("Temporal.Calendar.prototype.year", Calendar.prototype.year), DefineIntrinsic("Temporal.Calendar.prototype.yearMonthFromFields", Calendar.prototype.yearMonthFromFields), DefineIntrinsic("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek), Ot.iso8601 = {
  dateFromFields(e2, t2, r2) {
    let o2 = PrepareTemporalFields(e2, [
      "day",
      "month",
      "monthCode",
      "year"
    ], [
      "year",
      "day"
    ]);
    const n2 = ToTemporalOverflow(t2);
    o2 = resolveNonLunisolarMonth(o2);
    let { year: a2, month: i2, day: s2 } = o2;
    return { year: a2, month: i2, day: s2 } = RegulateISODate(a2, i2, s2, n2), CreateTemporalDate(a2, i2, s2, r2);
  },
  yearMonthFromFields(e2, t2, r2) {
    let o2 = PrepareTemporalFields(e2, [
      "month",
      "monthCode",
      "year"
    ], [
      "year"
    ]);
    const n2 = ToTemporalOverflow(t2);
    o2 = resolveNonLunisolarMonth(o2);
    let { year: a2, month: i2 } = o2;
    return { year: a2, month: i2 } = (/* @__PURE__ */ __name(function RegulateISOYearMonth(e3, t3, r3) {
      let o3 = e3, n3 = t3;
      switch (r3) {
        case "reject":
          RejectISODate(o3, n3, 1);
          break;
        case "constrain":
          ({ year: o3, month: n3 } = ConstrainISODate(o3, n3));
      }
      return {
        year: o3,
        month: n3
      };
    }, "RegulateISOYearMonth"))(a2, i2, n2), CreateTemporalYearMonth(a2, i2, r2, 1);
  },
  monthDayFromFields(e2, t2, r2) {
    let o2 = PrepareTemporalFields(e2, [
      "day",
      "month",
      "monthCode",
      "year"
    ], [
      "day"
    ]);
    const n2 = ToTemporalOverflow(t2);
    if (void 0 !== o2.month && void 0 === o2.year && void 0 === o2.monthCode) throw new TypeError("either year or monthCode required with month");
    const a2 = void 0 === o2.monthCode;
    o2 = resolveNonLunisolarMonth(o2);
    let { month: i2, day: s2, year: l2 } = o2;
    return { month: i2, day: s2 } = RegulateISODate(a2 ? l2 : 1972, i2, s2, n2), CreateTemporalMonthDay(i2, s2, r2, 1972);
  },
  fields: /* @__PURE__ */ __name((e2) => e2, "fields"),
  fieldKeysToIgnore(e2) {
    const t2 = new Dt();
    for (let r2 = 0; r2 < e2.length; r2++) {
      const o2 = e2[r2];
      Call(vt, t2, [
        o2
      ]), "month" === o2 ? Call(vt, t2, [
        "monthCode"
      ]) : "monthCode" === o2 && Call(vt, t2, [
        "month"
      ]);
    }
    return [
      ...Call(Ct, t2, [])
    ];
  },
  dateAdd(e2, t2, r2, o2, n2, a2, d2) {
    let m2 = GetSlot(e2, i), c2 = GetSlot(e2, s), h2 = GetSlot(e2, l);
    return { year: m2, month: c2, day: h2 } = AddISODate(m2, c2, h2, t2, r2, o2, n2, a2), CreateTemporalDate(m2, c2, h2, d2);
  },
  dateUntil: /* @__PURE__ */ __name((e2, t2, r2) => DifferenceISODate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), r2), "dateUntil"),
  year: /* @__PURE__ */ __name((e2) => GetSlot(e2, i), "year"),
  era() {
  },
  eraYear() {
  },
  month: /* @__PURE__ */ __name((e2) => GetSlot(e2, s), "month"),
  monthCode: /* @__PURE__ */ __name((e2) => buildMonthCode(GetSlot(e2, s)), "monthCode"),
  day: /* @__PURE__ */ __name((e2) => GetSlot(e2, l), "day"),
  dayOfWeek: /* @__PURE__ */ __name((e2) => DayOfWeek(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)), "dayOfWeek"),
  dayOfYear: /* @__PURE__ */ __name((e2) => DayOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)), "dayOfYear"),
  weekOfYear: /* @__PURE__ */ __name((e2) => WeekOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)).week, "weekOfYear"),
  yearOfWeek: /* @__PURE__ */ __name((e2) => WeekOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)).year, "yearOfWeek"),
  daysInWeek: /* @__PURE__ */ __name(() => 7, "daysInWeek"),
  daysInMonth: /* @__PURE__ */ __name((e2) => ISODaysInMonth(GetSlot(e2, i), GetSlot(e2, s)), "daysInMonth"),
  daysInYear(e2) {
    let t2 = e2;
    return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i)) ? 366 : 365;
  },
  monthsInYear: /* @__PURE__ */ __name(() => 12, "monthsInYear"),
  inLeapYear(e2) {
    let t2 = e2;
    return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i));
  }
};
var OneObjectCache = class _OneObjectCache {
  static {
    __name(this, "OneObjectCache");
  }
  constructor(e2) {
    if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e2) {
      let t2 = 0;
      for (const r2 of e2.map.entries()) {
        if (++t2 > _OneObjectCache.MAX_CACHE_ENTRIES) break;
        this.map.set(...r2);
      }
    }
  }
  get(e2) {
    const t2 = this.map.get(e2);
    return t2 && (this.hits++, this.report()), this.calls++, t2;
  }
  set(e2, t2) {
    this.map.set(e2, t2), this.misses++, this.report();
  }
  report() {
  }
  setObject(e2) {
    if (_OneObjectCache.objectMap.get(e2)) throw new RangeError("object already cached");
    _OneObjectCache.objectMap.set(e2, this), this.report();
  }
  static getCacheForObject(e2) {
    let t2 = _OneObjectCache.objectMap.get(e2);
    return t2 || (t2 = new _OneObjectCache(), _OneObjectCache.objectMap.set(e2, t2)), t2;
  }
};
function toUtcIsoDateString({ isoYear: e2, isoMonth: t2, isoDay: r2 }) {
  return `${ISOYearString(e2)}-${ISODateTimePartString(t2)}-${ISODateTimePartString(r2)}T00:00Z`;
}
__name(toUtcIsoDateString, "toUtcIsoDateString");
function simpleDateDiff(e2, t2) {
  return {
    years: e2.year - t2.year,
    months: e2.month - t2.month,
    days: e2.day - t2.day
  };
}
__name(simpleDateDiff, "simpleDateDiff");
OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
var HelperBase = class {
  static {
    __name(this, "HelperBase");
  }
  constructor() {
    this.eraLength = "short", this.hasEra = true, this.erasBeginMidYear = false;
  }
  getFormatter() {
    return void 0 === this.formatter && (this.formatter = new ft(`en-US-u-ca-${this.id}`, {
      day: "numeric",
      month: "numeric",
      year: "numeric",
      era: this.eraLength,
      timeZone: "UTC"
    })), this.formatter;
  }
  isoToCalendarDate(e2, t2) {
    const { year: r2, month: o2, day: n2 } = e2, a2 = JSON.stringify({
      func: "isoToCalendarDate",
      isoYear: r2,
      isoMonth: o2,
      isoDay: n2,
      id: this.id
    }), i2 = t2.get(a2);
    if (i2) return i2;
    const s2 = this.getFormatter();
    let l2, d2;
    try {
      d2 = toUtcIsoDateString({
        isoYear: r2,
        isoMonth: o2,
        isoDay: n2
      }), l2 = s2.formatToParts(new Date(d2));
    } catch (e3) {
      throw new RangeError(`Invalid ISO date: ${JSON.stringify({
        isoYear: r2,
        isoMonth: o2,
        isoDay: n2
      })}`);
    }
    const m2 = {};
    for (let { type: e3, value: t3 } of l2) {
      if ("year" === e3 && (m2.eraYear = +t3), "relatedYear" === e3 && (m2.eraYear = +t3), "month" === e3) {
        const e4 = /^([0-9]*)(.*?)$/.exec(t3);
        if (!e4 || 3 != e4.length || !e4[1] && !e4[2]) throw new RangeError(`Unexpected month: ${t3}`);
        if (m2.month = e4[1] ? +e4[1] : 1, m2.month < 1) throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
        if (m2.month > 13) throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
        e4[2] && (m2.monthExtra = e4[2]);
      }
      "day" === e3 && (m2.day = +t3), this.hasEra && "era" === e3 && null != t3 && "" !== t3 && (t3 = t3.split(" (")[0], m2.era = t3.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
    }
    if (void 0 === m2.eraYear) throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
    if (this.reviseIntlEra) {
      const { era: t3, eraYear: r3 } = this.reviseIntlEra(m2, e2);
      m2.era = t3, m2.eraYear = r3;
    }
    this.checkIcuBugs && this.checkIcuBugs(e2);
    const c2 = this.adjustCalendarDate(m2, t2, "constrain", true);
    if (void 0 === c2.year) throw new RangeError(`Missing year converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.month) throw new RangeError(`Missing month converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.day) throw new RangeError(`Missing day converting ${JSON.stringify(e2)}`);
    return t2.set(a2, c2), [
      "constrain",
      "reject"
    ].forEach((r3) => {
      const o3 = JSON.stringify({
        func: "calendarToIsoDate",
        year: c2.year,
        month: c2.month,
        day: c2.day,
        overflow: r3,
        id: this.id
      });
      t2.set(o3, e2);
    }), c2;
  }
  validateCalendarDate(e2) {
    const { era: t2, month: r2, year: o2, day: n2, eraYear: a2, monthCode: i2, monthExtra: s2 } = e2;
    if (void 0 !== s2) throw new RangeError("Unexpected `monthExtra` value");
    if (void 0 === o2 && void 0 === a2) throw new TypeError("year or eraYear is required");
    if (void 0 === r2 && void 0 === i2) throw new TypeError("month or monthCode is required");
    if (void 0 === n2) throw new RangeError("Missing day");
    if (void 0 !== i2) {
      if ("string" != typeof i2) throw new RangeError("monthCode must be a string, not " + typeof i2);
      if (!/^M([01]?\d)(L?)$/.test(i2)) throw new RangeError(`Invalid monthCode: ${i2}`);
    }
    if (this.constantEra) {
      if (void 0 !== t2 && t2 !== this.constantEra) throw new RangeError(`era must be ${this.constantEra}, not ${t2}`);
      if (void 0 !== a2 && void 0 !== o2 && a2 !== o2) throw new RangeError(`eraYear ${a2} does not match year ${o2}`);
    }
    if (this.hasEra && void 0 === e2.era != (void 0 === e2.eraYear)) throw new RangeError("properties 'era' and 'eraYear' must be provided together");
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    if ("lunisolar" === this.calendarType) throw new RangeError("Override required for lunisolar calendars");
    let n2 = e2;
    if (this.validateCalendarDate(n2), this.constantEra) {
      const { year: e3, eraYear: t3 } = n2;
      n2 = {
        ...n2,
        era: this.constantEra,
        year: void 0 !== e3 ? e3 : t3,
        eraYear: void 0 !== t3 ? t3 : e3
      };
    }
    const a2 = this.monthsInYear(n2, t2);
    let { month: i2, monthCode: s2 } = n2;
    return { month: i2, monthCode: s2 } = resolveNonLunisolarMonth(n2, r2, a2), {
      ...n2,
      month: i2,
      monthCode: s2
    };
  }
  regulateMonthDayNaive(e2, t2, r2) {
    const o2 = this.monthsInYear(e2, r2);
    let { month: n2, day: a2 } = e2;
    return "reject" === t2 ? (RejectToRange(n2, 1, o2), RejectToRange(a2, 1, this.maximumMonthLength(e2))) : (n2 = ConstrainToRange(n2, 1, o2), a2 = ConstrainToRange(a2, 1, this.maximumMonthLength({
      ...e2,
      month: n2
    }))), {
      ...e2,
      month: n2,
      day: a2
    };
  }
  calendarToIsoDate(e2, t2 = "constrain", r2) {
    const o2 = e2;
    let n2 = this.adjustCalendarDate(e2, r2, t2, false);
    n2 = this.regulateMonthDayNaive(n2, t2, r2);
    const { year: a2, month: i2, day: s2 } = n2, l2 = JSON.stringify({
      func: "calendarToIsoDate",
      year: a2,
      month: i2,
      day: s2,
      overflow: t2,
      id: this.id
    });
    let d2, m2 = r2.get(l2);
    if (m2) return m2;
    if (void 0 !== o2.year && void 0 !== o2.month && void 0 !== o2.day && (o2.year !== n2.year || o2.month !== n2.month || o2.day !== n2.day) && (d2 = JSON.stringify({
      func: "calendarToIsoDate",
      year: o2.year,
      month: o2.month,
      day: o2.day,
      overflow: t2,
      id: this.id
    }), m2 = r2.get(d2), m2)) return m2;
    let c2 = this.estimateIsoDate({
      year: a2,
      month: i2,
      day: s2
    });
    const calculateSameMonthResult = /* @__PURE__ */ __name((e3) => {
      let o3 = this.addDaysIso(c2, e3);
      if (n2.day > this.minimumMonthLength(n2)) {
        let e4 = this.isoToCalendarDate(o3, r2);
        for (; e4.month !== i2 || e4.year !== a2; ) {
          if ("reject" === t2) throw new RangeError(`day ${s2} does not exist in month ${i2} of year ${a2}`);
          o3 = this.addDaysIso(o3, -1), e4 = this.isoToCalendarDate(o3, r2);
        }
      }
      return o3;
    }, "calculateSameMonthResult");
    let h2 = 0, u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2);
    if (0 !== T2.years || 0 !== T2.months || 0 !== T2.days) {
      const e3 = 365 * T2.years + 30 * T2.months + T2.days;
      c2 = this.addDaysIso(c2, e3), u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months ? c2 = calculateSameMonthResult(T2.days) : h2 = this.compareCalendarDates(n2, u2);
    }
    let p2 = 8;
    for (; h2; ) {
      c2 = this.addDaysIso(c2, h2 * p2);
      const e3 = u2;
      u2 = this.isoToCalendarDate(c2, r2);
      const a3 = h2;
      if (h2 = this.compareCalendarDates(n2, u2), h2) {
        if (T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months) c2 = calculateSameMonthResult(T2.days), h2 = 0;
        else if (a3 && h2 !== a3) if (p2 > 1) p2 /= 2;
        else {
          if ("reject" === t2) throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({
            ...o2
          })}`);
          this.compareCalendarDates(u2, e3) > 0 && (c2 = this.addDaysIso(c2, -1)), h2 = 0;
        }
      }
    }
    if (r2.set(l2, c2), d2 && r2.set(d2, c2), void 0 === n2.year || void 0 === n2.month || void 0 === n2.day || void 0 === n2.monthCode || this.hasEra && (void 0 === n2.era || void 0 === n2.eraYear)) throw new RangeError("Unexpected missing property");
    return c2;
  }
  temporalToCalendarDate(e2, t2) {
    const r2 = {
      year: GetSlot(e2, i),
      month: GetSlot(e2, s),
      day: GetSlot(e2, l)
    };
    return this.isoToCalendarDate(r2, t2);
  }
  compareCalendarDates(e2, t2) {
    const r2 = PrepareTemporalFields(e2, [
      "day",
      "month",
      "year"
    ], [
      "day",
      "month",
      "year"
    ]), o2 = PrepareTemporalFields(t2, [
      "day",
      "month",
      "year"
    ], [
      "day",
      "month",
      "year"
    ]);
    return r2.year !== o2.year ? ComparisonResult(r2.year - o2.year) : r2.month !== o2.month ? ComparisonResult(r2.month - o2.month) : r2.day !== o2.day ? ComparisonResult(r2.day - o2.day) : 0;
  }
  regulateDate(e2, t2 = "constrain", r2) {
    const o2 = this.calendarToIsoDate(e2, t2, r2);
    return this.isoToCalendarDate(o2, r2);
  }
  addDaysIso(e2, t2) {
    return AddISODate(e2.year, e2.month, e2.day, 0, 0, 0, t2, "constrain");
  }
  addDaysCalendar(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.addDaysIso(o2, t2);
    return this.isoToCalendarDate(n2, r2);
  }
  addMonthsCalendar(e2, t2, r2, o2) {
    let n2 = e2;
    const { day: a2 } = n2;
    for (let e3 = 0, r3 = It(t2); e3 < r3; e3++) {
      const { month: e4 } = n2, r4 = n2, i2 = t2 < 0 ? -Math.max(a2, this.daysInPreviousMonth(n2, o2)) : this.daysInMonth(n2, o2), s2 = this.calendarToIsoDate(n2, "constrain", o2);
      let l2 = this.addDaysIso(s2, i2);
      if (n2 = this.isoToCalendarDate(l2, o2), t2 > 0) {
        const t3 = this.monthsInYear(r4, o2);
        for (; n2.month - 1 != e4 % t3; ) l2 = this.addDaysIso(l2, -1), n2 = this.isoToCalendarDate(l2, o2);
      }
      n2.day !== a2 && (n2 = this.regulateDate({
        ...n2,
        day: a2
      }, "constrain", o2));
    }
    if ("reject" === r2 && n2.day !== a2) throw new RangeError(`Day ${a2} does not exist in resulting calendar month`);
    return n2;
  }
  addCalendar(e2, { years: t2 = 0, months: r2 = 0, weeks: o2 = 0, days: n2 = 0 }, a2, i2) {
    const { year: s2, day: l2, monthCode: d2 } = e2, m2 = this.adjustCalendarDate({
      year: s2 + t2,
      monthCode: d2,
      day: l2
    }, i2), c2 = this.addMonthsCalendar(m2, r2, a2, i2), h2 = n2 + 7 * o2;
    return this.addDaysCalendar(c2, h2, i2);
  }
  untilCalendar(e2, t2, r2, o2) {
    let n2 = 0, a2 = 0, i2 = 0, s2 = 0;
    switch (r2) {
      case "day":
        n2 = this.calendarDaysUntil(e2, t2, o2);
        break;
      case "week": {
        const r3 = this.calendarDaysUntil(e2, t2, o2);
        n2 = r3 % 7, a2 = (r3 - n2) / 7;
        break;
      }
      case "month":
      case "year": {
        const a3 = this.compareCalendarDates(t2, e2);
        if (!a3) return {
          years: 0,
          months: 0,
          weeks: 0,
          days: 0
        };
        const l2 = t2.year - e2.year, d2 = t2.day - e2.day;
        if ("year" === r2 && l2) {
          let r3 = 0;
          t2.monthCode > e2.monthCode && (r3 = 1), t2.monthCode < e2.monthCode && (r3 = -1), r3 || (r3 = Math.sign(d2));
          s2 = r3 * a3 < 0 ? l2 - a3 : l2;
        }
        let m2, c2 = s2 ? this.addCalendar(e2, {
          years: s2
        }, "constrain", o2) : e2;
        do {
          i2 += a3, m2 = c2, c2 = this.addMonthsCalendar(m2, a3, "constrain", o2), c2.day !== e2.day && (c2 = this.regulateDate({
            ...c2,
            day: e2.day
          }, "constrain", o2));
        } while (this.compareCalendarDates(t2, c2) * a3 >= 0);
        i2 -= a3;
        n2 = this.calendarDaysUntil(m2, t2, o2);
        break;
      }
    }
    return {
      years: s2,
      months: i2,
      weeks: a2,
      days: n2
    };
  }
  daysInMonth(e2, t2) {
    const { day: r2 } = e2, o2 = this.maximumMonthLength(e2), n2 = this.minimumMonthLength(e2);
    if (n2 === o2) return n2;
    const a2 = r2 <= o2 - n2 ? o2 : n2, i2 = this.calendarToIsoDate(e2, "constrain", t2), s2 = this.addDaysIso(i2, a2), l2 = this.isoToCalendarDate(s2, t2), d2 = this.addDaysIso(s2, -l2.day);
    return this.isoToCalendarDate(d2, t2).day;
  }
  daysInPreviousMonth(e2, t2) {
    const { day: r2, month: o2, year: n2 } = e2;
    let a2 = {
      year: o2 > 1 ? n2 : n2 - 1,
      month: o2,
      day: 1
    };
    const i2 = o2 > 1 ? o2 - 1 : this.monthsInYear(a2, t2);
    a2 = {
      ...a2,
      month: i2
    };
    const s2 = this.minimumMonthLength(a2), l2 = this.maximumMonthLength(a2);
    if (s2 === l2) return l2;
    const d2 = this.calendarToIsoDate(e2, "constrain", t2), m2 = this.addDaysIso(d2, -r2);
    return this.isoToCalendarDate(m2, t2).day;
  }
  startOfCalendarYear(e2) {
    return {
      year: e2.year,
      month: 1,
      monthCode: "M01",
      day: 1
    };
  }
  startOfCalendarMonth(e2) {
    return {
      year: e2.year,
      month: e2.month,
      day: 1
    };
  }
  calendarDaysUntil(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.calendarToIsoDate(t2, "constrain", r2);
    return this.isoDaysUntil(o2, n2);
  }
  isoDaysUntil(e2, t2) {
    return DifferenceISODate(e2.year, e2.month, e2.day, t2.year, t2.month, t2.day, "day").days;
  }
  monthDayFromFields(e2, t2, r2) {
    let o2, n2, a2, i2, s2, { monthCode: l2, day: d2 } = e2;
    if (void 0 === l2) {
      let { year: o3, era: n3, eraYear: a3 } = e2;
      if (void 0 === o3 && (void 0 === n3 || void 0 === a3)) throw new TypeError("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
      ({ monthCode: l2, day: d2 } = this.isoToCalendarDate(this.calendarToIsoDate(e2, t2, r2), r2));
    }
    const m2 = this.isoToCalendarDate({
      year: 1972,
      month: 12,
      day: 31
    }, r2), c2 = m2.monthCode > l2 || m2.monthCode === l2 && m2.day >= d2 ? m2.year : m2.year - 1;
    for (let e3 = 0; e3 < 100; e3++) {
      const m3 = this.adjustCalendarDate({
        day: d2,
        monthCode: l2,
        year: c2 - e3
      }, r2), h2 = this.calendarToIsoDate(m3, "constrain", r2), u2 = this.isoToCalendarDate(h2, r2);
      if ({ year: o2, month: n2, day: a2 } = h2, u2.monthCode === l2 && u2.day === d2) return {
        month: n2,
        day: a2,
        year: o2
      };
      "constrain" === t2 && (void 0 === i2 || u2.monthCode === i2.monthCode && u2.day > i2.day) && (i2 = u2, s2 = h2);
    }
    if ("constrain" === t2 && void 0 !== s2) return s2;
    throw new RangeError(`No recent ${this.id} year with monthCode ${l2} and day ${d2}`);
  }
};
var HebrewHelper = class extends HelperBase {
  static {
    __name(this, "HebrewHelper");
  }
  constructor() {
    super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = {
      Tishri: {
        leap: 1,
        regular: 1,
        monthCode: "M01",
        days: 30
      },
      Heshvan: {
        leap: 2,
        regular: 2,
        monthCode: "M02",
        days: {
          min: 29,
          max: 30
        }
      },
      Kislev: {
        leap: 3,
        regular: 3,
        monthCode: "M03",
        days: {
          min: 29,
          max: 30
        }
      },
      Tevet: {
        leap: 4,
        regular: 4,
        monthCode: "M04",
        days: 29
      },
      Shevat: {
        leap: 5,
        regular: 5,
        monthCode: "M05",
        days: 30
      },
      Adar: {
        leap: void 0,
        regular: 6,
        monthCode: "M06",
        days: 29
      },
      "Adar I": {
        leap: 6,
        regular: void 0,
        monthCode: "M05L",
        days: 30
      },
      "Adar II": {
        leap: 7,
        regular: void 0,
        monthCode: "M06",
        days: 29
      },
      Nisan: {
        leap: 8,
        regular: 7,
        monthCode: "M07",
        days: 30
      },
      Iyar: {
        leap: 9,
        regular: 8,
        monthCode: "M08",
        days: 29
      },
      Sivan: {
        leap: 10,
        regular: 9,
        monthCode: "M09",
        days: 30
      },
      Tamuz: {
        leap: 11,
        regular: 10,
        monthCode: "M10",
        days: 29
      },
      Av: {
        leap: 12,
        regular: 11,
        monthCode: "M11",
        days: 30
      },
      Elul: {
        leap: 13,
        regular: 12,
        monthCode: "M12",
        days: 29
      }
    }, this.hasEra = false;
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (7 * t2 + 1) % 19 < 7;
  }
  monthsInYear(e2) {
    return this.inLeapYear(e2) ? 13 : 12;
  }
  minimumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "min");
  }
  maximumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "max");
  }
  minMaxMonthLength(e2, t2) {
    const { month: r2, year: o2 } = e2, n2 = this.getMonthCode(o2, r2), a2 = wt(this.months).find((e3) => e3[1].monthCode === n2);
    if (void 0 === a2) throw new RangeError(`unmatched Hebrew month: ${r2}`);
    const i2 = a2[1].days;
    return "number" == typeof i2 ? i2 : i2[t2];
  }
  estimateIsoDate(e2) {
    const { year: t2 } = e2;
    return {
      year: t2 - 3760,
      month: 1,
      day: 1
    };
  }
  getMonthCode(e2, t2) {
    return this.inLeapYear({
      year: e2
    }) ? 6 === t2 ? buildMonthCode(5, true) : buildMonthCode(t2 < 6 ? t2 : t2 - 1) : buildMonthCode(t2);
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, eraYear: a2, month: i2, monthCode: s2, day: l2, monthExtra: d2 } = e2;
    if (void 0 === n2 && void 0 !== a2 && (n2 = a2), void 0 === a2 && void 0 !== n2 && (a2 = n2), o2) {
      if (d2) {
        const e3 = this.months[d2];
        if (!e3) throw new RangeError(`Unrecognized month from formatToParts: ${d2}`);
        i2 = this.inLeapYear({
          year: n2
        }) ? e3.leap : e3.regular;
      }
      s2 = this.getMonthCode(n2, i2);
      return {
        year: n2,
        month: i2,
        day: l2,
        era: void 0,
        eraYear: a2,
        monthCode: s2
      };
    }
    if (this.validateCalendarDate(e2), void 0 === i2) if (s2.endsWith("L")) {
      if ("M05L" !== s2) throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s2}`);
      if (i2 = 6, !this.inLeapYear({
        year: n2
      })) {
        if ("reject" === r2) throw new RangeError(`Hebrew monthCode M05L is invalid in year ${n2} which is not a leap year`);
        i2 = 6, s2 = "M06";
      }
    } else {
      i2 = monthCodeNumberPart(s2), this.inLeapYear({
        year: n2
      }) && i2 >= 6 && i2++;
      const e3 = this.monthsInYear({
        year: n2
      });
      if (i2 < 1 || i2 > e3) throw new RangeError(`Invalid monthCode: ${s2}`);
    }
    else if ("reject" === r2 ? (RejectToRange(i2, 1, this.monthsInYear({
      year: n2
    })), RejectToRange(l2, 1, this.maximumMonthLength({
      year: n2,
      month: i2
    }))) : (i2 = ConstrainToRange(i2, 1, this.monthsInYear({
      year: n2
    })), l2 = ConstrainToRange(l2, 1, this.maximumMonthLength({
      year: n2,
      month: i2
    }))), void 0 === s2) s2 = this.getMonthCode(n2, i2);
    else {
      if (this.getMonthCode(n2, i2) !== s2) throw new RangeError(`monthCode ${s2} doesn't correspond to month ${i2} in Hebrew year ${n2}`);
    }
    return {
      ...e2,
      day: l2,
      month: i2,
      monthCode: s2,
      year: n2,
      eraYear: a2
    };
  }
};
var IslamicBaseHelper = class extends HelperBase {
  static {
    __name(this, "IslamicBaseHelper");
  }
  constructor() {
    super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
  }
  inLeapYear(e2, t2) {
    return 30 === this.daysInMonth({
      year: e2.year,
      month: 12,
      day: 1
    }, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return {
      year: St(t2 * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622,
      month: 1,
      day: 1
    };
  }
};
var IslamicHelper = class extends IslamicBaseHelper {
  static {
    __name(this, "IslamicHelper");
  }
  constructor() {
    super(...arguments), this.id = "islamic";
  }
};
var IslamicUmalquraHelper = class extends IslamicBaseHelper {
  static {
    __name(this, "IslamicUmalquraHelper");
  }
  constructor() {
    super(...arguments), this.id = "islamic-umalqura";
  }
};
var IslamicTblaHelper = class extends IslamicBaseHelper {
  static {
    __name(this, "IslamicTblaHelper");
  }
  constructor() {
    super(...arguments), this.id = "islamic-tbla";
  }
};
var IslamicCivilHelper = class extends IslamicBaseHelper {
  static {
    __name(this, "IslamicCivilHelper");
  }
  constructor() {
    super(...arguments), this.id = "islamic-civil";
  }
};
var IslamicRgsaHelper = class extends IslamicBaseHelper {
  static {
    __name(this, "IslamicRgsaHelper");
  }
  constructor() {
    super(...arguments), this.id = "islamic-rgsa";
  }
};
var IslamicCcHelper = class extends IslamicBaseHelper {
  static {
    __name(this, "IslamicCcHelper");
  }
  constructor() {
    super(...arguments), this.id = "islamicc";
  }
};
var PersianHelper = class extends HelperBase {
  static {
    __name(this, "PersianHelper");
  }
  constructor() {
    super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
  }
  inLeapYear(e2, t2) {
    return IslamicHelper.prototype.inLeapYear.call(this, e2, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 29 : t2 <= 6 ? 31 : 30;
  }
  maximumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 30 : t2 <= 6 ? 31 : 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return {
      year: t2 + 621,
      month: 1,
      day: 1
    };
  }
};
var IndianHelper = class extends HelperBase {
  static {
    __name(this, "IndianHelper");
  }
  constructor() {
    super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = {
      1: {
        length: 30,
        month: 3,
        day: 22,
        leap: {
          length: 31,
          month: 3,
          day: 21
        }
      },
      2: {
        length: 31,
        month: 4,
        day: 21
      },
      3: {
        length: 31,
        month: 5,
        day: 22
      },
      4: {
        length: 31,
        month: 6,
        day: 22
      },
      5: {
        length: 31,
        month: 7,
        day: 23
      },
      6: {
        length: 31,
        month: 8,
        day: 23
      },
      7: {
        length: 30,
        month: 9,
        day: 23
      },
      8: {
        length: 30,
        month: 10,
        day: 23
      },
      9: {
        length: 30,
        month: 11,
        day: 22
      },
      10: {
        length: 30,
        month: 12,
        day: 22
      },
      11: {
        length: 30,
        month: 1,
        nextYear: true,
        day: 21
      },
      12: {
        length: 30,
        month: 2,
        nextYear: true,
        day: 20
      }
    }, this.vulnerableToBceBug = "10/11/-79 Saka" !== (/* @__PURE__ */ new Date("0000-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-indian", {
      timeZone: "UTC"
    });
  }
  inLeapYear(e2) {
    return isGregorianLeapYear(e2.year + 78);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  maximumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  getMonthInfo(e2) {
    const { month: t2 } = e2;
    let r2 = this.months[t2];
    if (void 0 === r2) throw new RangeError(`Invalid month: ${t2}`);
    return this.inLeapYear(e2) && r2.leap && (r2 = r2.leap), r2;
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), r2 = this.getMonthInfo(t2);
    return AddISODate(t2.year + 78 + (r2.nextYear ? 1 : 0), r2.month, r2.day, 0, 0, 0, t2.day - 1, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.vulnerableToBceBug && e2.year < 1) throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
  }
};
function isGregorianLeapYear(e2) {
  return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
}
__name(isGregorianLeapYear, "isGregorianLeapYear");
var GregorianBaseHelper = class extends HelperBase {
  static {
    __name(this, "GregorianBaseHelper");
  }
  constructor(e2, t2) {
    super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = (/* @__PURE__ */ new Date("+001001-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-japanese", {
      timeZone: "UTC"
    }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e2;
    const { eras: r2, anchorEra: o2 } = (/* @__PURE__ */ __name(function adjustEras(e3) {
      let t3, r3 = e3;
      if (0 === r3.length) throw new RangeError("Invalid era data: eras are required");
      if (1 === r3.length && r3[0].reverseOf) throw new RangeError("Invalid era data: anchor era cannot count years backwards");
      if (1 === r3.length && !r3[0].name) throw new RangeError("Invalid era data: at least one named era is required");
      if (r3.filter((e4) => null != e4.reverseOf).length > 1) throw new RangeError("Invalid era data: only one era can count years backwards");
      r3.forEach((e4) => {
        if (e4.isAnchor || !e4.anchorEpoch && !e4.reverseOf) {
          if (t3) throw new RangeError("Invalid era data: cannot have multiple anchor eras");
          t3 = e4, e4.anchorEpoch = {
            year: e4.hasYearZero ? 0 : 1
          };
        } else if (!e4.name) throw new RangeError("If era name is blank, it must be the anchor era");
      }), r3 = r3.filter((e4) => e4.name), r3.forEach((e4) => {
        const { reverseOf: t4 } = e4;
        if (t4) {
          const o4 = r3.find((e5) => e5.name === t4);
          if (void 0 === o4) throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t4}`);
          e4.reverseOf = o4, e4.anchorEpoch = o4.anchorEpoch, e4.isoEpoch = o4.isoEpoch;
        }
        void 0 === e4.anchorEpoch.month && (e4.anchorEpoch.month = 1), void 0 === e4.anchorEpoch.day && (e4.anchorEpoch.day = 1);
      }), yt.call(r3, (e4, t4) => {
        if (e4.reverseOf) return 1;
        if (t4.reverseOf) return -1;
        if (!e4.isoEpoch || !t4.isoEpoch) throw new RangeError("Invalid era data: missing ISO epoch");
        return t4.isoEpoch.year - e4.isoEpoch.year;
      });
      const o3 = r3[r3.length - 1].reverseOf;
      if (o3 && o3 !== r3[r3.length - 2]) throw new RangeError("Invalid era data: invalid reverse-sign era");
      return r3.forEach((e4, t4) => {
        e4.genericName = "era" + (r3.length - 1 - t4);
      }), {
        eras: r3,
        anchorEra: t3 || r3[0]
      };
    }, "adjustEras"))(t2);
    this.anchorEra = o2, this.eras = r2;
  }
  inLeapYear(e2) {
    const { year: t2 } = this.estimateIsoDate({
      month: 1,
      day: 1,
      year: e2.year
    });
    return isGregorianLeapYear(t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 2 === t2 ? this.inLeapYear(e2) ? 29 : 28 : [
      4,
      6,
      9,
      11
    ].indexOf(t2) >= 0 ? 30 : 31;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
  completeEraYear(e2) {
    const checkField = /* @__PURE__ */ __name((t3, r3) => {
      const o3 = e2[t3];
      if (null != o3 && o3 != r3) throw new RangeError(`Input ${t3} ${o3} doesn't match calculated value ${r3}`);
    }, "checkField"), eraFromYear = /* @__PURE__ */ __name((t3) => {
      let r3;
      const o3 = {
        ...e2,
        year: t3
      }, n2 = this.eras.find((e3, n3) => {
        if (n3 === this.eras.length - 1) {
          if (e3.reverseOf) {
            if (t3 > 0) throw new RangeError(`Signed year ${t3} is invalid for era ${e3.name}`);
            return r3 = e3.anchorEpoch.year - t3, true;
          }
          return r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true;
        }
        return this.compareCalendarDates(o3, e3.anchorEpoch) >= 0 && (r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true);
      });
      if (!n2) throw new RangeError(`Year ${t3} was not matched by any era`);
      return {
        eraYear: r3,
        era: n2.name
      };
    }, "eraFromYear");
    let { year: t2, eraYear: r2, era: o2 } = e2;
    if (null != t2) ({ eraYear: r2, era: o2 } = eraFromYear(t2)), checkField("era", o2), checkField("eraYear", r2);
    else {
      if (null == r2) throw new RangeError("Either `year` or `eraYear` and `era` are required");
      {
        const e3 = void 0 === o2 ? void 0 : this.eras.find((e4) => e4.name === o2 || e4.genericName === o2);
        if (!e3) throw new RangeError(`Era ${o2} (ISO year ${r2}) was not matched by any era`);
        if (r2 < 1 && e3.reverseOf) throw new RangeError(`Years in ${o2} era must be positive, not ${t2}`);
        t2 = e3.reverseOf ? e3.anchorEpoch.year - r2 : r2 + e3.anchorEpoch.year - (e3.hasYearZero ? 0 : 1), checkField("year", t2), { eraYear: r2, era: o2 } = eraFromYear(t2);
      }
    }
    return {
      ...e2,
      year: t2,
      eraYear: r2,
      era: o2
    };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain") {
    let o2 = e2;
    const { month: n2, monthCode: a2 } = o2;
    return void 0 === n2 && (o2 = {
      ...o2,
      month: monthCodeNumberPart(a2)
    }), this.validateCalendarDate(o2), o2 = this.completeEraYear(o2), super.adjustCalendarDate(o2, t2, r2);
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), { year: r2, month: o2, day: n2 } = t2, { anchorEra: a2 } = this;
    return RegulateISODate(r2 + a2.isoEpoch.year - (a2.hasYearZero ? 0 : 1), o2, n2, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
      if (CompareISODate(e2.year, e2.month, e2.day, 1582, 10, 15) < 0) throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
    }
  }
};
var OrthodoxBaseHelper = class extends GregorianBaseHelper {
  static {
    __name(this, "OrthodoxBaseHelper");
  }
  constructor(e2, t2) {
    super(e2, t2);
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (t2 + 1) % 4 == 0;
  }
  monthsInYear() {
    return 13;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 13 === t2 ? this.inLeapYear(e2) ? 6 : 5 : 30;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
};
var EthioaaHelper = class extends OrthodoxBaseHelper {
  static {
    __name(this, "EthioaaHelper");
  }
  constructor() {
    super("ethioaa", [
      {
        name: "era0",
        isoEpoch: {
          year: -5492,
          month: 7,
          day: 17
        }
      }
    ]);
  }
};
var CopticHelper = class extends OrthodoxBaseHelper {
  static {
    __name(this, "CopticHelper");
  }
  constructor() {
    super("coptic", [
      {
        name: "era1",
        isoEpoch: {
          year: 284,
          month: 8,
          day: 29
        }
      },
      {
        name: "era0",
        reverseOf: "era1"
      }
    ]);
  }
};
var EthiopicHelper = class extends OrthodoxBaseHelper {
  static {
    __name(this, "EthiopicHelper");
  }
  constructor() {
    super("ethiopic", [
      {
        name: "era0",
        isoEpoch: {
          year: -5492,
          month: 7,
          day: 17
        }
      },
      {
        name: "era1",
        isoEpoch: {
          year: 8,
          month: 8,
          day: 27
        },
        anchorEpoch: {
          year: 5501
        }
      }
    ]);
  }
};
var RocHelper = class extends GregorianBaseHelper {
  static {
    __name(this, "RocHelper");
  }
  constructor() {
    super("roc", [
      {
        name: "minguo",
        isoEpoch: {
          year: 1912,
          month: 1,
          day: 1
        }
      },
      {
        name: "before-roc",
        reverseOf: "minguo"
      }
    ]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var BuddhistHelper = class extends GregorianBaseHelper {
  static {
    __name(this, "BuddhistHelper");
  }
  constructor() {
    super("buddhist", [
      {
        name: "be",
        hasYearZero: true,
        isoEpoch: {
          year: -543,
          month: 1,
          day: 1
        }
      }
    ]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var GregoryHelper = class extends GregorianBaseHelper {
  static {
    __name(this, "GregoryHelper");
  }
  constructor() {
    super("gregory", [
      {
        name: "ce",
        isoEpoch: {
          year: 1,
          month: 1,
          day: 1
        }
      },
      {
        name: "bce",
        reverseOf: "ce"
      }
    ]);
  }
  reviseIntlEra(e2) {
    let { era: t2, eraYear: r2 } = e2;
    return "bc" !== t2 && "b" !== t2 || (t2 = "bce"), "ad" !== t2 && "a" !== t2 || (t2 = "ce"), {
      era: t2,
      eraYear: r2
    };
  }
};
var JapaneseHelper = class extends GregorianBaseHelper {
  static {
    __name(this, "JapaneseHelper");
  }
  constructor() {
    super("japanese", [
      {
        name: "reiwa",
        isoEpoch: {
          year: 2019,
          month: 5,
          day: 1
        },
        anchorEpoch: {
          year: 2019,
          month: 5,
          day: 1
        }
      },
      {
        name: "heisei",
        isoEpoch: {
          year: 1989,
          month: 1,
          day: 8
        },
        anchorEpoch: {
          year: 1989,
          month: 1,
          day: 8
        }
      },
      {
        name: "showa",
        isoEpoch: {
          year: 1926,
          month: 12,
          day: 25
        },
        anchorEpoch: {
          year: 1926,
          month: 12,
          day: 25
        }
      },
      {
        name: "taisho",
        isoEpoch: {
          year: 1912,
          month: 7,
          day: 30
        },
        anchorEpoch: {
          year: 1912,
          month: 7,
          day: 30
        }
      },
      {
        name: "meiji",
        isoEpoch: {
          year: 1868,
          month: 9,
          day: 8
        },
        anchorEpoch: {
          year: 1868,
          month: 9,
          day: 8
        }
      },
      {
        name: "ce",
        isoEpoch: {
          year: 1,
          month: 1,
          day: 1
        }
      },
      {
        name: "bce",
        reverseOf: "ce"
      }
    ]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long", this.erasBeginMidYear = true;
  }
  reviseIntlEra(e2, t2) {
    const { era: r2, eraYear: o2 } = e2, { year: n2 } = t2;
    return this.eras.find((e3) => e3.name === r2) ? {
      era: r2,
      eraYear: o2
    } : n2 < 1 ? {
      era: "bce",
      eraYear: 1 - n2
    } : {
      era: "ce",
      eraYear: n2
    };
  }
};
var ChineseBaseHelper = class extends HelperBase {
  static {
    __name(this, "ChineseBaseHelper");
  }
  constructor() {
    super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
  }
  inLeapYear(e2, t2) {
    const r2 = this.getMonthList(e2.year, t2);
    return 13 === wt(r2).length;
  }
  monthsInYear(e2, t2) {
    return this.inLeapYear(e2, t2) ? 13 : 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  getMonthList(e2, t2) {
    if (void 0 === e2) throw new TypeError("Missing year");
    const r2 = JSON.stringify({
      func: "getMonthList",
      calendarYear: e2,
      id: this.id
    }), o2 = t2.get(r2);
    if (o2) return o2;
    const n2 = this.getFormatter(), getCalendarDate = /* @__PURE__ */ __name((e3, t3) => {
      const r3 = toUtcIsoDateString({
        isoYear: e3,
        isoMonth: 2,
        isoDay: 1
      }), o3 = new Date(r3);
      o3.setUTCDate(t3 + 1);
      const a3 = n2.formatToParts(o3), i3 = a3.find((e4) => "month" === e4.type).value, s3 = +a3.find((e4) => "day" === e4.type).value;
      let l3 = a3.find((e4) => "relatedYear" === e4.type);
      if (void 0 === l3) throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      return l3 = +l3.value, {
        calendarMonthString: i3,
        calendarDay: s3,
        calendarYearToVerify: l3
      };
    }, "getCalendarDate");
    let a2 = 17, { calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2);
    "1" !== i2 && (a2 += 29, { calendarMonthString: i2, calendarDay: s2 } = getCalendarDate(e2, a2)), a2 -= s2 - 5;
    const d2 = {};
    let m2, c2, h2 = 1, u2 = false;
    do {
      ({ calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2)), m2 && (d2[c2].daysInMonth = m2 + 30 - s2), l2 !== e2 ? u2 = true : (d2[i2] = {
        monthIndex: h2++
      }, a2 += 30), m2 = s2, c2 = i2;
    } while (!u2);
    return d2[c2].daysInMonth = m2 + 30 - s2, t2.set(r2, d2), d2;
  }
  estimateIsoDate(e2) {
    const { year: t2, month: r2 } = e2;
    return {
      year: t2,
      month: r2 >= 12 ? 12 : r2 + 1,
      day: 1
    };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, month: a2, monthExtra: i2, day: s2, monthCode: l2, eraYear: d2 } = e2;
    if (o2) {
      if (n2 = d2, i2 && "bis" !== i2) throw new RangeError(`Unexpected leap month suffix: ${i2}`);
      const e3 = buildMonthCode(a2, void 0 !== i2), r3 = `${a2}${i2 || ""}`, o3 = this.getMonthList(n2, t2)[r3];
      if (void 0 === o3) throw new RangeError(`Unmatched month ${r3} in Chinese year ${n2}`);
      return a2 = o3.monthIndex, {
        year: n2,
        month: a2,
        day: s2,
        era: void 0,
        eraYear: d2,
        monthCode: e3
      };
    }
    if (this.validateCalendarDate(e2), void 0 === n2 && (n2 = d2), void 0 === d2 && (d2 = n2), void 0 === a2) {
      const e3 = this.getMonthList(n2, t2);
      let o3 = l2.replace("L", "bis").slice(1);
      "0" === o3[0] && (o3 = o3.slice(1));
      let i3 = e3[o3];
      if (a2 = i3 && i3.monthIndex, void 0 === a2 && l2.endsWith("L") && "M13L" != l2 && "constrain" === r2) {
        let t3 = l2.slice(1, -1);
        "0" === t3[0] && (t3 = t3.slice(1)), i3 = e3[t3], i3 && (a2 = i3.monthIndex, l2 = buildMonthCode(t3));
      }
      if (void 0 === a2) throw new RangeError(`Unmatched month ${l2} in Chinese year ${n2}`);
    } else if (void 0 === l2) {
      const e3 = this.getMonthList(n2, t2), o3 = wt(e3), i3 = o3.length;
      "reject" === r2 ? (RejectToRange(a2, 1, i3), RejectToRange(s2, 1, this.maximumMonthLength())) : (a2 = ConstrainToRange(a2, 1, i3), s2 = ConstrainToRange(s2, 1, this.maximumMonthLength()));
      const d3 = o3.find(([, e4]) => e4.monthIndex === a2);
      if (void 0 === d3) throw new RangeError(`Invalid month ${a2} in Chinese year ${n2}`);
      l2 = buildMonthCode(d3[0].replace("bis", ""), -1 !== d3[0].indexOf("bis"));
    } else {
      const e3 = this.getMonthList(n2, t2);
      let r3 = l2.replace("L", "bis").slice(1);
      "0" === r3[0] && (r3 = r3.slice(1));
      const o3 = e3[r3];
      if (!o3) throw new RangeError(`Unmatched monthCode ${l2} in Chinese year ${n2}`);
      if (a2 !== o3.monthIndex) throw new RangeError(`monthCode ${l2} doesn't correspond to month ${a2} in Chinese year ${n2}`);
    }
    return {
      ...e2,
      year: n2,
      eraYear: d2,
      month: a2,
      monthCode: l2,
      day: s2
    };
  }
};
var ChineseHelper = class extends ChineseBaseHelper {
  static {
    __name(this, "ChineseHelper");
  }
  constructor() {
    super(...arguments), this.id = "chinese";
  }
};
var DangiHelper = class extends ChineseBaseHelper {
  static {
    __name(this, "DangiHelper");
  }
  constructor() {
    super(...arguments), this.id = "dangi";
  }
};
var NonIsoCalendar = class {
  static {
    __name(this, "NonIsoCalendar");
  }
  constructor(e2) {
    this.helper = e2;
  }
  dateFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields([
      "day",
      "month",
      "monthCode",
      "year"
    ]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate(n2, a2, o2), d2 = CreateTemporalDate(i2, s2, l2, r2);
    return o2.setObject(d2), d2;
  }
  yearMonthFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields([
      "month",
      "monthCode",
      "year"
    ]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate({
      ...n2,
      day: 1
    }, a2, o2), d2 = CreateTemporalYearMonth(i2, s2, r2, l2);
    return o2.setObject(d2), d2;
  }
  monthDayFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields([
      "day",
      "month",
      "monthCode",
      "year"
    ]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.monthDayFromFields(n2, a2, o2), d2 = CreateTemporalMonthDay(s2, l2, r2, i2);
    return o2.setObject(d2), d2;
  }
  fields(e2) {
    let t2 = e2;
    return Tt.call(t2, "year") && (t2 = [
      ...t2,
      "era",
      "eraYear"
    ]), t2;
  }
  fieldKeysToIgnore(e2) {
    const t2 = new Dt();
    for (let r2 = 0; r2 < e2.length; r2++) {
      const o2 = e2[r2];
      switch (Call(vt, t2, [
        o2
      ]), o2) {
        case "era":
          Call(vt, t2, [
            "eraYear"
          ]), Call(vt, t2, [
            "year"
          ]);
          break;
        case "eraYear":
          Call(vt, t2, [
            "era"
          ]), Call(vt, t2, [
            "year"
          ]);
          break;
        case "year":
          Call(vt, t2, [
            "era"
          ]), Call(vt, t2, [
            "eraYear"
          ]);
          break;
        case "month":
          Call(vt, t2, [
            "monthCode"
          ]), this.helper.erasBeginMidYear && (Call(vt, t2, [
            "era"
          ]), Call(vt, t2, [
            "eraYear"
          ]));
          break;
        case "monthCode":
          Call(vt, t2, [
            "month"
          ]), this.helper.erasBeginMidYear && (Call(vt, t2, [
            "era"
          ]), Call(vt, t2, [
            "eraYear"
          ]));
          break;
        case "day":
          this.helper.erasBeginMidYear && (Call(vt, t2, [
            "era"
          ]), Call(vt, t2, [
            "eraYear"
          ]));
      }
    }
    return [
      ...Call(Ct, t2, [])
    ];
  }
  dateAdd(e2, t2, r2, o2, n2, a2, i2) {
    const s2 = OneObjectCache.getCacheForObject(e2), l2 = this.helper.temporalToCalendarDate(e2, s2), d2 = this.helper.addCalendar(l2, {
      years: t2,
      months: r2,
      weeks: o2,
      days: n2
    }, a2, s2), m2 = this.helper.calendarToIsoDate(d2, "constrain", s2), { year: c2, month: h2, day: u2 } = m2, T2 = CreateTemporalDate(c2, h2, u2, i2);
    return new OneObjectCache(s2).setObject(T2), T2;
  }
  dateUntil(e2, t2, r2) {
    const o2 = OneObjectCache.getCacheForObject(e2), n2 = OneObjectCache.getCacheForObject(t2), a2 = this.helper.temporalToCalendarDate(e2, o2), i2 = this.helper.temporalToCalendarDate(t2, n2);
    return this.helper.untilCalendar(a2, i2, r2, o2);
  }
  year(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).year;
  }
  month(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).month;
  }
  day(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).day;
  }
  era(e2) {
    if (!this.helper.hasEra) return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).era;
  }
  eraYear(e2) {
    if (!this.helper.hasEra) return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).eraYear;
  }
  monthCode(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).monthCode;
  }
  dayOfWeek(e2) {
    return Ot.iso8601.dayOfWeek(e2);
  }
  dayOfYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.isoToCalendarDate(e2, t2), o2 = this.helper.startOfCalendarYear(r2);
    return this.helper.calendarDaysUntil(o2, r2, t2) + 1;
  }
  weekOfYear(e2) {
    return Ot.iso8601.weekOfYear(e2);
  }
  yearOfWeek(e2) {
    return Ot.iso8601.yearOfWeek(e2);
  }
  daysInWeek(e2) {
    return Ot.iso8601.daysInWeek(e2);
  }
  daysInMonth(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2), o2 = this.helper.maximumMonthLength(r2);
    if (o2 === this.helper.minimumMonthLength(r2)) return o2;
    const n2 = this.helper.startOfCalendarMonth(r2), a2 = this.helper.addMonthsCalendar(n2, 1, "constrain", t2);
    return this.helper.calendarDaysUntil(n2, a2, t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2), n2 = this.helper.startOfCalendarYear(o2), a2 = this.helper.addCalendar(n2, {
      years: 1
    }, "constrain", r2);
    return this.helper.calendarDaysUntil(n2, a2, r2);
  }
  monthsInYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2);
    return this.helper.monthsInYear(r2, t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2);
    return this.helper.inLeapYear(o2, r2);
  }
};
for (const e2 of [
  HebrewHelper,
  PersianHelper,
  EthiopicHelper,
  EthioaaHelper,
  CopticHelper,
  ChineseHelper,
  DangiHelper,
  RocHelper,
  IndianHelper,
  BuddhistHelper,
  GregoryHelper,
  JapaneseHelper,
  IslamicHelper,
  IslamicUmalquraHelper,
  IslamicTblaHelper,
  IslamicCivilHelper,
  IslamicRgsaHelper,
  IslamicCcHelper
]) {
  const t2 = new e2();
  Ot[t2.id] = new NonIsoCalendar(t2);
}
var PlainDate = class _PlainDate {
  static {
    __name(this, "PlainDate");
  }
  constructor(e2, t2, r2, o2 = "iso8601") {
    CreateTemporalDateSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), ToTemporalCalendarSlotValue(o2));
  }
  get calendarId() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get year() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, [
      "day",
      "month",
      "monthCode",
      "year"
    ]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarDateFromFields(o2, a2, r2);
  }
  withCalendar(e2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return new _PlainDate(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalDuration(e2), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const r2 = CreateNegatedTemporalDuration(ToTemporalDuration(e2)), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  until(e2, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    for (const e3 of [
      i,
      s,
      l
    ]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return TemporalDateToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return TemporalDateToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e2) return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    let t2, r2;
    if (IsObject(e2)) if (IsTemporalTimeZone(e2)) t2 = e2;
    else {
      const o3 = e2.timeZone;
      void 0 === o3 ? t2 = ToTemporalTimeZoneSlotValue(e2) : (t2 = ToTemporalTimeZoneSlotValue(o3), r2 = e2.plainTime);
    }
    else t2 = ToTemporalTimeZoneSlotValue(e2);
    const o2 = GetSlot(this, i), a2 = GetSlot(this, s), f2 = GetSlot(this, l), y2 = GetSlot(this, p);
    let I2 = 0, S2 = 0, g2 = 0, w2 = 0, D2 = 0, G2 = 0;
    void 0 !== r2 && (r2 = ToTemporalTime(r2), I2 = GetSlot(r2, d), S2 = GetSlot(r2, m), g2 = GetSlot(r2, c), w2 = GetSlot(r2, h), D2 = GetSlot(r2, u), G2 = GetSlot(r2, T));
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(t2, CreateTemporalDateTime(o2, a2, f2, I2, S2, g2, w2, D2, G2, y2), "compatible"), n), t2, y2);
  }
  toPlainYearMonth() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, [
      "monthCode",
      "year"
    ]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, [
      "day",
      "monthCode"
    ]), []));
  }
  getISOFields() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return {
      calendar: GetSlot(this, p),
      isoDay: GetSlot(this, l),
      isoMonth: GetSlot(this, s),
      isoYear: GetSlot(this, i)
    };
  }
  getCalendar() {
    if (!IsTemporalDate(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDate(e2) ? (ToTemporalOverflow(r2), CreateTemporalDate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p))) : ToTemporalDate(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDate(e2), o2 = ToTemporalDate(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
var PlainDateTime = class _PlainDateTime {
  static {
    __name(this, "PlainDateTime");
  }
  constructor(e2, t2, r2, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = "iso8601") {
    CreateTemporalDateTimeSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), void 0 === a2 ? 0 : ToIntegerWithTruncation(a2), void 0 === i2 ? 0 : ToIntegerWithTruncation(i2), void 0 === s2 ? 0 : ToIntegerWithTruncation(s2), void 0 === l2 ? 0 : ToIntegerWithTruncation(l2), ToTemporalCalendarSlotValue(d2));
  }
  get calendarId() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get year() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get hour() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  get era() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    let a2 = PrepareTemporalFields(this, n2, []);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []);
    const { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    return CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, o2);
  }
  withPlainTime(e2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e2) return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  withPlainDate(e2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l);
    let a2 = GetSlot(t2, p);
    const f2 = GetSlot(this, d), y2 = GetSlot(this, m), I2 = GetSlot(this, c), S2 = GetSlot(this, h), g2 = GetSlot(this, u), w2 = GetSlot(this, T);
    return a2 = ConsolidateCalendars(GetSlot(this, p), a2), CreateTemporalDateTime(r2, o2, n2, f2, y2, I2, S2, g2, w2, a2);
  }
  withCalendar(e2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return new _PlainDateTime(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    if (void 0 === e2) throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He, [
      "day"
    ]), a2 = {
      day: 1,
      hour: 24,
      minute: 60,
      second: 60,
      millisecond: 1e3,
      microsecond: 1e3,
      nanosecond: 1e3
    }[n2];
    ValidateTemporalRoundingIncrement(r2, a2, 1 === a2);
    let f2 = GetSlot(this, i), y2 = GetSlot(this, s), I2 = GetSlot(this, l), S2 = GetSlot(this, d), g2 = GetSlot(this, m), w2 = GetSlot(this, c), D2 = GetSlot(this, h), G2 = GetSlot(this, u), v2 = GetSlot(this, T);
    return { year: f2, month: y2, day: I2, hour: S2, minute: g2, second: w2, millisecond: D2, microsecond: G2, nanosecond: v2 } = RoundISODateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, r2, n2, o2), CreateTemporalDateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, GetSlot(this, p));
  }
  equals(e2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDateTime(e2);
    for (const e3 of [
      i,
      s,
      l,
      d,
      m,
      c,
      h,
      u,
      T
    ]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: i2, unit: s2, increment: l2 } = ToSecondsStringPrecisionRecord(a2, o2);
    return TemporalDateTimeToString(this, i2, r2, {
      unit: s2,
      increment: l2,
      roundingMode: n2
    });
  }
  toJSON() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
  }
  toZonedDateTime(e2, t2) {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(r2, this, ToTemporalDisambiguation(GetOptionsObject(t2))), n), r2, GetSlot(this, p));
  }
  toPlainDate() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, [
      "monthCode",
      "year"
    ]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, [
      "day",
      "monthCode"
    ]), []));
  }
  toPlainTime() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(this);
  }
  getISOFields() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return {
      calendar: GetSlot(this, p),
      isoDay: GetSlot(this, l),
      isoHour: GetSlot(this, d),
      isoMicrosecond: GetSlot(this, u),
      isoMillisecond: GetSlot(this, h),
      isoMinute: GetSlot(this, m),
      isoMonth: GetSlot(this, s),
      isoNanosecond: GetSlot(this, T),
      isoSecond: GetSlot(this, c),
      isoYear: GetSlot(this, i)
    };
  }
  getCalendar() {
    if (!IsTemporalDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDateTime(e2) ? (ToTemporalOverflow(r2), CreateTemporalDateTime(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T), GetSlot(e2, p))) : ToTemporalDateTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDateTime(e2), o2 = ToTemporalDateTime(t2);
    for (const e3 of [
      i,
      s,
      l,
      d,
      m,
      c,
      h,
      u,
      T
    ]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2) return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
var Duration = class _Duration {
  static {
    __name(this, "Duration");
  }
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = 0) {
    const m2 = void 0 === e2 ? 0 : ToIntegerIfIntegral(e2), c2 = void 0 === t2 ? 0 : ToIntegerIfIntegral(t2), h2 = void 0 === r2 ? 0 : ToIntegerIfIntegral(r2), u2 = void 0 === o2 ? 0 : ToIntegerIfIntegral(o2), T2 = void 0 === n2 ? 0 : ToIntegerIfIntegral(n2), p2 = void 0 === a2 ? 0 : ToIntegerIfIntegral(a2), f2 = void 0 === i2 ? 0 : ToIntegerIfIntegral(i2), y2 = void 0 === s2 ? 0 : ToIntegerIfIntegral(s2), I2 = void 0 === l2 ? 0 : ToIntegerIfIntegral(l2), S2 = void 0 === d2 ? 0 : ToIntegerIfIntegral(d2);
    RejectDuration(m2, c2, h2, u2, T2, p2, f2, y2, I2, S2), N(this), SetSlot(this, w, m2), SetSlot(this, D, c2), SetSlot(this, G, h2), SetSlot(this, v, u2), SetSlot(this, C, T2), SetSlot(this, O, p2), SetSlot(this, b, f2), SetSlot(this, E, y2), SetSlot(this, M, I2), SetSlot(this, R, S2);
  }
  get years() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, w);
  }
  get months() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, D);
  }
  get weeks() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, G);
  }
  get days() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, v);
  }
  get hours() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, C);
  }
  get minutes() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, O);
  }
  get seconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, b);
  }
  get milliseconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, E);
  }
  get microseconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, M);
  }
  get nanoseconds() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, R);
  }
  get sign() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  get blank() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return 0 === DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  with(e2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    const t2 = PrepareTemporalFields(e2, [
      "days",
      "hours",
      "microseconds",
      "milliseconds",
      "minutes",
      "months",
      "nanoseconds",
      "seconds",
      "weeks",
      "years"
    ], "partial"), { years: r2 = GetSlot(this, w), months: o2 = GetSlot(this, D), weeks: n2 = GetSlot(this, G), days: a2 = GetSlot(this, v), hours: i2 = GetSlot(this, C), minutes: s2 = GetSlot(this, O), seconds: l2 = GetSlot(this, b), milliseconds: d2 = GetSlot(this, E), microseconds: m2 = GetSlot(this, M), nanoseconds: c2 = GetSlot(this, R) } = t2;
    return new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  negated() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return CreateNegatedTemporalDuration(this);
  }
  abs() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return new _Duration(Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, C)), Math.abs(GetSlot(this, O)), Math.abs(GetSlot(this, b)), Math.abs(GetSlot(this, E)), Math.abs(GetSlot(this, M)), Math.abs(GetSlot(this, R)));
  }
  add(e2, t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("subtract", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    if (void 0 === t2) throw new TypeError("options parameter is required");
    let r2 = GetSlot(this, w), o2 = GetSlot(this, D), n2 = GetSlot(this, G), a2 = GetSlot(this, v), i2 = GetSlot(this, C), s2 = GetSlot(this, O), l2 = GetSlot(this, b), d2 = GetSlot(this, E), m2 = GetSlot(this, M), c2 = GetSlot(this, R), h2 = DefaultTemporalLargestUnit(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
    const u2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2);
    let T2 = GetTemporalUnit(u2, "largestUnit", "datetime", void 0, [
      "auto"
    ]), f2 = ToRelativeTemporalObject(u2);
    const y2 = ToTemporalRoundingIncrement(u2), I2 = ToTemporalRoundingMode(u2, "halfExpand");
    let S2 = GetTemporalUnit(u2, "smallestUnit", "datetime", void 0), g2 = true;
    S2 || (g2 = false, S2 = "nanosecond"), h2 = LargerOfTwoTemporalUnits(h2, S2);
    let F2 = true;
    if (T2 || (F2 = false, T2 = h2), "auto" === T2 && (T2 = h2), !g2 && !F2) throw new RangeError("at least one of smallestUnit or largestUnit is required");
    if (LargerOfTwoTemporalUnits(T2, S2) !== T2) throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${S2}`);
    const Y2 = {
      hour: 24,
      minute: 60,
      second: 60,
      millisecond: 1e3,
      microsecond: 1e3,
      nanosecond: 1e3
    }[S2];
    return void 0 !== Y2 && ValidateTemporalRoundingIncrement(y2, Y2, false), { years: r2, months: o2, weeks: n2, days: a2 } = UnbalanceDurationRelative(r2, o2, n2, a2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = RoundDuration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = AdjustRoundedDurationDays(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = BalanceDuration(a2, i2, s2, l2, d2, m2, c2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2 } = (/* @__PURE__ */ __name(function BalanceDurationRelative(t3, r3, o3, n3, a3, i3) {
      const s3 = GetIntrinsic("%Temporal.Duration%"), l3 = DurationSign(t3, r3, o3, n3, 0, 0, 0, 0, 0, 0);
      if (0 === l3) return {
        years: t3,
        months: r3,
        weeks: o3,
        days: n3
      };
      const d3 = import_jsbi.default.BigInt(l3);
      let m3, c3, h3 = import_jsbi.default.BigInt(t3), u3 = import_jsbi.default.BigInt(r3), T3 = import_jsbi.default.BigInt(o3), f3 = import_jsbi.default.BigInt(n3);
      i3 && (c3 = ToTemporalDate(i3), m3 = GetSlot(c3, p));
      const y3 = new s3(l3), I3 = new s3(0, l3), S3 = new s3(0, 0, l3);
      switch (a3) {
        case "year": {
          if (!m3) throw new RangeError("a starting point is required for years balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4, n4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(o4))); ) f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(o4)), h3 = import_jsbi.default.add(h3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4);
          for ({ relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(n4))); ) f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(n4)), u3 = import_jsbi.default.add(u3, d3), c3 = r4, { relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4);
          r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
          const a4 = "string" != typeof m3 ? GetMethod(m3, "dateUntil") : void 0, i4 = Te(null);
          i4.largestUnit = "month";
          let s4 = CalendarDateUntil(m3, c3, r4, i4, a4), l4 = GetSlot(s4, D);
          for (; import_jsbi.default.greaterThanOrEqual(abs(u3), import_jsbi.default.BigInt(ae(l4))); ) {
            u3 = import_jsbi.default.subtract(u3, import_jsbi.default.BigInt(l4)), h3 = import_jsbi.default.add(h3, d3), c3 = r4, r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
            const o5 = Te(null);
            o5.largestUnit = "month", s4 = CalendarDateUntil(m3, c3, r4, o5, a4), l4 = GetSlot(s4, D);
          }
          break;
        }
        case "month": {
          if (!m3) throw new RangeError("a starting point is required for months balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(o4))); ) f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(o4)), u3 = import_jsbi.default.add(u3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4);
          break;
        }
        case "week": {
          if (!m3) throw new RangeError("a starting point is required for weeks balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(o4))); ) f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(o4)), T3 = import_jsbi.default.add(T3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4);
          break;
        }
      }
      return {
        years: import_jsbi.default.toNumber(h3),
        months: import_jsbi.default.toNumber(u3),
        weeks: import_jsbi.default.toNumber(T3),
        days: import_jsbi.default.toNumber(f3)
      };
    }, "BalanceDurationRelative"))(r2, o2, n2, a2, T2, f2), new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  total(e2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    let t2 = GetSlot(this, w), r2 = GetSlot(this, D), o2 = GetSlot(this, G), n2 = GetSlot(this, v), a2 = GetSlot(this, C), i2 = GetSlot(this, O), s2 = GetSlot(this, b), l2 = GetSlot(this, E), d2 = GetSlot(this, M), m2 = GetSlot(this, R);
    if (void 0 === e2) throw new TypeError("options argument is required");
    const c2 = "string" == typeof e2 ? CreateOnePropObject("unit", e2) : GetOptionsObject(e2), h2 = ToRelativeTemporalObject(c2), u2 = GetTemporalUnit(c2, "unit", "datetime", He);
    let T2;
    ({ years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, u2, h2)), IsTemporalZonedDateTime(h2) && (T2 = MoveRelativeZonedDateTime(h2, t2, r2, o2, 0));
    let p2 = BalancePossiblyInfiniteDuration(n2, a2, i2, s2, l2, d2, m2, u2, T2);
    if ("positive overflow" === p2) return 1 / 0;
    if ("negative overflow" === p2) return -1 / 0;
    ({ days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = p2);
    const { total: f2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, 1, u2, "trunc", h2);
    return f2;
  }
  toString(e2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2 || "minute" === n2) throw new RangeError('smallestUnit must be a time unit other than "hours" or "minutes"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalDurationToString(this, a2, {
      unit: i2,
      increment: s2,
      roundingMode: o2
    });
  }
  toJSON() {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return TemporalDurationToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDuration(this)) throw new TypeError("invalid receiver");
    return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e2, t2).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
  }
  valueOf() {
    throw new TypeError("use compare() to compare Temporal.Duration");
  }
  static from(e2) {
    return IsTemporalDuration(e2) ? new _Duration(GetSlot(e2, w), GetSlot(e2, D), GetSlot(e2, G), GetSlot(e2, v), GetSlot(e2, C), GetSlot(e2, O), GetSlot(e2, b), GetSlot(e2, E), GetSlot(e2, M), GetSlot(e2, R)) : ToTemporalDuration(e2);
  }
  static compare(t2, r2, o2) {
    const n2 = ToTemporalDuration(t2), a2 = ToTemporalDuration(r2), i2 = ToRelativeTemporalObject(GetOptionsObject(o2)), s2 = GetSlot(n2, w), l2 = GetSlot(n2, D), d2 = GetSlot(n2, G);
    let m2 = GetSlot(n2, v);
    const c2 = GetSlot(n2, C), h2 = GetSlot(n2, O), u2 = GetSlot(n2, b), T2 = GetSlot(n2, E), p2 = GetSlot(n2, M);
    let f2 = GetSlot(n2, R);
    const y2 = GetSlot(a2, w), I2 = GetSlot(a2, D), S2 = GetSlot(a2, G);
    let g2 = GetSlot(a2, v);
    const F2 = GetSlot(a2, C), Y2 = GetSlot(a2, O), P2 = GetSlot(a2, b), Z2 = GetSlot(a2, E), B2 = GetSlot(a2, M);
    let N2 = GetSlot(a2, R);
    const j2 = CalculateOffsetShift(i2, s2, l2, d2, m2), $2 = CalculateOffsetShift(i2, y2, I2, S2, g2);
    0 === s2 && 0 === y2 && 0 === l2 && 0 === I2 && 0 === d2 && 0 === S2 || ({ days: m2 } = UnbalanceDurationRelative(s2, l2, d2, m2, "day", i2), { days: g2 } = UnbalanceDurationRelative(y2, I2, S2, g2, "day", i2));
    const k2 = TotalDurationNanoseconds(m2, c2, h2, u2, T2, p2, f2, j2), U2 = TotalDurationNanoseconds(g2, F2, Y2, P2, Z2, B2, N2, $2);
    return ComparisonResult(import_jsbi.default.toNumber(import_jsbi.default.subtract(k2, U2)));
  }
};
MakeIntrinsicClass(Duration, "Temporal.Duration");
var bt = Object.create;
var PlainMonthDay = class {
  static {
    __name(this, "PlainMonthDay");
  }
  constructor(e2, t2, r2 = "iso8601", o2 = 1972) {
    CreateTemporalMonthDaySlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get monthCode() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  with(e2, t2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, [
      "day",
      "month",
      "monthCode",
      "year"
    ]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarMonthDayFromFields(o2, a2, r2);
  }
  equals(e2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalMonthDay(e2);
    for (const e3 of [
      s,
      l,
      i
    ]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
  }
  toPlainDate(e2) {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, [
      "day",
      "monthCode"
    ]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, [
      "year"
    ]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [
      .../* @__PURE__ */ new Set([
        ...r2,
        ...n2
      ])
    ], []);
    const i2 = bt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return {
      calendar: GetSlot(this, p),
      isoDay: GetSlot(this, l),
      isoMonth: GetSlot(this, s),
      isoYear: GetSlot(this, i)
    };
  }
  getCalendar() {
    if (!IsTemporalMonthDay(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalMonthDay(e2) ? (ToTemporalOverflow(r2), CreateTemporalMonthDay(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p), GetSlot(e2, i))) : ToTemporalMonthDay(e2, r2);
  }
};
MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
var instant = /* @__PURE__ */ __name(() => new (GetIntrinsic("%Temporal.Instant%"))(Ve()), "instant");
var plainDateTime = /* @__PURE__ */ __name((e2, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e2);
  return GetPlainDateTimeFor(r2, instant(), o2);
}, "plainDateTime");
var plainDateTimeISO = /* @__PURE__ */ __name((e2 = DefaultTimeZone()) => GetPlainDateTimeFor(ToTemporalTimeZoneSlotValue(e2), instant(), "iso8601"), "plainDateTimeISO");
var zonedDateTime = /* @__PURE__ */ __name((e2, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e2);
  return CreateTemporalZonedDateTime(Ve(), r2, o2);
}, "zonedDateTime");
var Et = {
  instant,
  plainDateTime,
  plainDateTimeISO,
  plainDate: /* @__PURE__ */ __name((e2, t2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTime(e2, t2)), "plainDate"),
  plainDateISO: /* @__PURE__ */ __name((e2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTimeISO(e2)), "plainDateISO"),
  plainTimeISO: /* @__PURE__ */ __name((e2 = DefaultTimeZone()) => TemporalDateTimeToTime(plainDateTimeISO(e2)), "plainTimeISO"),
  timeZoneId: /* @__PURE__ */ __name(() => DefaultTimeZone(), "timeZoneId"),
  zonedDateTime,
  zonedDateTimeISO: /* @__PURE__ */ __name((e2 = DefaultTimeZone()) => zonedDateTime("iso8601", e2), "zonedDateTimeISO"),
  [Symbol.toStringTag]: "Temporal.Now"
};
Object.defineProperty(Et, Symbol.toStringTag, {
  value: "Temporal.Now",
  writable: false,
  enumerable: false,
  configurable: true
});
var Mt = Object.assign;
function TemporalTimeToString(e2, t2, r2) {
  let o2 = GetSlot(e2, d), n2 = GetSlot(e2, m), a2 = GetSlot(e2, c), i2 = GetSlot(e2, h), s2 = GetSlot(e2, u), l2 = GetSlot(e2, T);
  if (r2) {
    const { unit: e3, increment: t3, roundingMode: d2 } = r2;
    ({ hour: o2, minute: n2, second: a2, millisecond: i2, microsecond: s2, nanosecond: l2 } = RoundTime(o2, n2, a2, i2, s2, l2, t3, e3, d2));
  }
  return `${ISODateTimePartString(o2)}:${ISODateTimePartString(n2)}${FormatSecondsStringPart(a2, i2, s2, l2, t2)}`;
}
__name(TemporalTimeToString, "TemporalTimeToString");
var PlainTime = class _PlainTime {
  static {
    __name(this, "PlainTime");
  }
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0) {
    const i2 = void 0 === e2 ? 0 : ToIntegerWithTruncation(e2), s2 = void 0 === t2 ? 0 : ToIntegerWithTruncation(t2), l2 = void 0 === r2 ? 0 : ToIntegerWithTruncation(r2), p2 = void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), f2 = void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), y2 = void 0 === a2 ? 0 : ToIntegerWithTruncation(a2);
    RejectTime(i2, s2, l2, p2, f2, y2), N(this), SetSlot(this, d, i2), SetSlot(this, m, s2), SetSlot(this, c, l2), SetSlot(this, h, p2), SetSlot(this, u, f2), SetSlot(this, T, y2);
  }
  get hour() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  with(e2, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = ToTemporalOverflow(GetOptionsObject(t2)), o2 = ToTemporalTimeRecord(e2, "partial"), n2 = ToTemporalTimeRecord(this);
    let { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = Mt(n2, o2);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = RegulateTime(a2, i2, s2, l2, d2, m2, r2), new _PlainTime(a2, i2, s2, l2, d2, m2);
  }
  add(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    if (void 0 === e2) throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, {
      hour: 24,
      minute: 60,
      second: 60,
      millisecond: 1e3,
      microsecond: 1e3,
      nanosecond: 1e3
    }[n2], false);
    let a2 = GetSlot(this, d), i2 = GetSlot(this, m), s2 = GetSlot(this, c), l2 = GetSlot(this, h), p2 = GetSlot(this, u), f2 = GetSlot(this, T);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: p2, nanosecond: f2 } = RoundTime(a2, i2, s2, l2, p2, f2, r2, n2, o2), new _PlainTime(a2, i2, s2, l2, p2, f2);
  }
  equals(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalTime(e2);
    for (const e3 of [
      d,
      m,
      c,
      h,
      u,
      T
    ]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3)) return false;
    }
    return true;
  }
  toString(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalTimeToString(this, a2, {
      unit: i2,
      increment: s2,
      roundingMode: o2
    });
  }
  toJSON() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return TemporalTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l), a2 = GetSlot(t2, p);
    return CreateTemporalDateTime(r2, o2, n2, GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), a2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument");
    const t2 = e2.plainDate;
    if (void 0 === t2) throw new TypeError("missing date property");
    const r2 = ToTemporalDate(t2), o2 = e2.timeZone;
    if (void 0 === o2) throw new TypeError("missing timeZone property");
    const a2 = ToTemporalTimeZoneSlotValue(o2), f2 = GetSlot(r2, i), y2 = GetSlot(r2, s), I2 = GetSlot(r2, l), S2 = GetSlot(r2, p), g2 = GetSlot(this, d), w2 = GetSlot(this, m), D2 = GetSlot(this, c), G2 = GetSlot(this, h), v2 = GetSlot(this, u), C2 = GetSlot(this, T);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, I2, g2, w2, D2, G2, v2, C2, S2), "compatible"), n), a2, S2);
  }
  getISOFields() {
    if (!IsTemporalTime(this)) throw new TypeError("invalid receiver");
    return {
      isoHour: GetSlot(this, d),
      isoMicrosecond: GetSlot(this, u),
      isoMillisecond: GetSlot(this, h),
      isoMinute: GetSlot(this, m),
      isoNanosecond: GetSlot(this, T),
      isoSecond: GetSlot(this, c)
    };
  }
  static from(e2, t2) {
    const r2 = ToTemporalOverflow(GetOptionsObject(t2));
    return IsTemporalTime(e2) ? new _PlainTime(GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T)) : ToTemporalTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalTime(e2), o2 = ToTemporalTime(t2);
    for (const e3 of [
      d,
      m,
      c,
      h,
      u,
      T
    ]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2) return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
var TimeZone = class {
  static {
    __name(this, "TimeZone");
  }
  constructor(e2) {
    if (arguments.length < 1) throw new RangeError("missing argument: identifier is required");
    const t2 = GetCanonicalTimeZoneIdentifier(e2);
    N(this), SetSlot(this, a, t2);
  }
  get id() {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  getOffsetNanosecondsFor(e2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    return IsTimeZoneOffsetString(r2) ? ParseTimeZoneOffsetString(r2) : GetNamedTimeZoneOffsetNanoseconds(r2, GetSlot(t2, n));
  }
  getOffsetStringFor(e2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetOffsetStringFor(this, ToTemporalInstant(e2));
  }
  getPlainDateTimeFor(e2, t2 = "iso8601") {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetPlainDateTimeFor(this, ToTemporalInstant(e2), ToTemporalCalendarSlotValue(t2));
  }
  getInstantFor(e2, t2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetInstantFor(this, ToTemporalDateTime(e2), ToTemporalDisambiguation(GetOptionsObject(t2)));
  }
  getPossibleInstantsFor(t2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalDateTime(t2), o2 = GetIntrinsic("%Temporal.Instant%"), n2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(n2)) {
      const t3 = GetUTCEpochNanoseconds(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
      if (null === t3) throw new RangeError("DateTime outside of supported range");
      const a2 = ParseTimeZoneOffsetString(n2);
      return [
        new o2(import_jsbi.default.subtract(t3, import_jsbi.default.BigInt(a2)))
      ];
    }
    const p2 = (/* @__PURE__ */ __name(function GetNamedTimeZoneEpochNanoseconds(t3, r3, o3, n3, a2, i2, s2, l2, d2, m2) {
      const c2 = GetUTCEpochNanoseconds(r3, o3, n3, a2, i2, s2, l2, d2, m2);
      if (null === c2) throw new RangeError("DateTime outside of supported range");
      let h2 = import_jsbi.default.subtract(c2, Ee);
      import_jsbi.default.lessThan(h2, Me) && (h2 = c2);
      let u2 = import_jsbi.default.add(c2, Ee);
      import_jsbi.default.greaterThan(u2, Re) && (u2 = c2);
      const T2 = GetNamedTimeZoneOffsetNanoseconds(t3, h2), p3 = GetNamedTimeZoneOffsetNanoseconds(t3, u2);
      return (T2 === p3 ? [
        T2
      ] : [
        T2,
        p3
      ]).map((h3) => {
        const u3 = import_jsbi.default.subtract(c2, import_jsbi.default.BigInt(h3)), T3 = GetNamedTimeZoneDateTimeParts(t3, u3);
        if (r3 === T3.year && o3 === T3.month && n3 === T3.day && a2 === T3.hour && i2 === T3.minute && s2 === T3.second && l2 === T3.millisecond && d2 === T3.microsecond && m2 === T3.nanosecond) return u3;
      }).filter((e2) => void 0 !== e2);
    }, "GetNamedTimeZoneEpochNanoseconds"))(n2, GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
    return p2.map((e2) => new o2(e2));
  }
  getNextTransition(e2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2) return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZoneNextTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  getPreviousTransition(e2) {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2) return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZonePreviousTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  toString() {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  toJSON() {
    if (!IsTemporalTimeZone(this)) throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  static from(e2) {
    return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e2));
  }
};
MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"), DefineIntrinsic("Temporal.TimeZone.prototype.getOffsetNanosecondsFor", TimeZone.prototype.getOffsetNanosecondsFor), DefineIntrinsic("Temporal.TimeZone.prototype.getPossibleInstantsFor", TimeZone.prototype.getPossibleInstantsFor);
var Rt = Object.create;
var PlainYearMonth = class {
  static {
    __name(this, "PlainYearMonth");
  }
  constructor(e2, t2, r2 = "iso8601", o2 = 1) {
    CreateTemporalYearMonthSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get year() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, [
      "month",
      "monthCode",
      "year"
    ]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarYearMonthFromFields(o2, a2, r2);
  }
  add(e2, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalYearMonth(e2);
    for (const e3 of [
      i,
      s,
      l
    ]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3)) return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
  }
  toPlainDate(e2) {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, [
      "monthCode",
      "year"
    ]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, [
      "day"
    ]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [
      .../* @__PURE__ */ new Set([
        ...r2,
        ...n2
      ])
    ], []);
    const i2 = Rt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return {
      calendar: GetSlot(this, p),
      isoDay: GetSlot(this, l),
      isoMonth: GetSlot(this, s),
      isoYear: GetSlot(this, i)
    };
  }
  getCalendar() {
    if (!IsTemporalYearMonth(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalYearMonth(e2) ? (ToTemporalOverflow(r2), CreateTemporalYearMonth(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, p), GetSlot(e2, l))) : ToTemporalYearMonth(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalYearMonth(e2), o2 = ToTemporalYearMonth(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
var Ft = ht.prototype.resolvedOptions;
var Yt = Object.create;
var ZonedDateTime = class {
  static {
    __name(this, "ZonedDateTime");
  }
  constructor(e2, t2, r2 = "iso8601") {
    if (arguments.length < 1) throw new TypeError("missing argument: epochNanoseconds is required");
    CreateTemporalZonedDateTimeSlots(this, ToBigInt(e2), ToTemporalTimeZoneSlotValue(t2), ToTemporalCalendarSlotValue(r2));
  }
  get calendarId() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get timeZoneId() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
  }
  get year() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), dateTime(this));
  }
  get month() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), dateTime(this));
  }
  get monthCode() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), dateTime(this));
  }
  get day() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), dateTime(this));
  }
  get hour() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), d);
  }
  get minute() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), m);
  }
  get second() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), c);
  }
  get millisecond() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), h);
  }
  get microsecond() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), u);
  }
  get nanosecond() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), T);
  }
  get era() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), dateTime(this));
  }
  get eraYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), dateTime(this));
  }
  get epochSeconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToBigIntExternal(GetSlot(this, n));
  }
  get dayOfWeek() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
  }
  get dayOfYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
  }
  get weekOfYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
  }
  get yearOfWeek() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
  }
  get hoursInDay() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = dateTime(this), r2 = GetIntrinsic("%Temporal.PlainDateTime%"), o2 = GetSlot(t2, i), a2 = GetSlot(t2, s), d2 = GetSlot(t2, l), m2 = new r2(o2, a2, d2, 0, 0, 0, 0, 0, 0), c2 = AddISODate(o2, a2, d2, 0, 0, 0, 1, "reject"), h2 = new r2(c2.year, c2.month, c2.day, 0, 0, 0, 0, 0, 0), u2 = GetSlot(this, g), T2 = GetSlot(GetInstantFor(u2, m2, "compatible"), n), p2 = GetSlot(GetInstantFor(u2, h2, "compatible"), n);
    return BigIntDivideToNumber(import_jsbi.default.subtract(p2, T2), Oe);
  }
  get daysInWeek() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
  }
  get daysInMonth() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
  }
  get daysInYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
  }
  get monthsInYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
  }
  get inLeapYear() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
  }
  get offset() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
  }
  get offsetNanoseconds() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return GetOffsetNanosecondsFor(GetSlot(this, g), GetSlot(this, S));
  }
  with(e2, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    if (!IsObject(e2)) throw new TypeError("invalid zoned-date-time-like");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p);
    let n2 = CalendarFields(o2, [
      "day",
      "hour",
      "microsecond",
      "millisecond",
      "minute",
      "month",
      "monthCode",
      "nanosecond",
      "second",
      "year"
    ]);
    n2.push("offset");
    let a2 = PrepareTemporalFields(this, n2, [
      "offset"
    ]);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, [
      "offset"
    ]);
    const i2 = ToTemporalDisambiguation(r2), s2 = ToTemporalOffset(r2, "prefer");
    let { year: l2, month: d2, day: m2, hour: c2, minute: h2, second: u2, millisecond: T2, microsecond: f2, nanosecond: y2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    const I2 = ParseTimeZoneOffsetString(a2.offset), S2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(l2, d2, m2, c2, h2, u2, T2, f2, y2, "option", I2, S2, i2, s2, false), S2, o2);
  }
  withPlainDate(e2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), a2 = GetSlot(t2, l);
    let f2 = GetSlot(t2, p);
    const y2 = dateTime(this), I2 = GetSlot(y2, d), S2 = GetSlot(y2, m), w2 = GetSlot(y2, c), D2 = GetSlot(y2, h), G2 = GetSlot(y2, u), v2 = GetSlot(y2, T);
    f2 = ConsolidateCalendars(GetSlot(this, p), f2);
    const C2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(C2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(r2, o2, a2, I2, S2, w2, D2, G2, v2, f2), "compatible"), n), C2, f2);
  }
  withPlainTime(e2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetIntrinsic("%Temporal.PlainTime%"), r2 = void 0 === e2 ? new t2() : ToTemporalTime(e2), o2 = dateTime(this), a2 = GetSlot(o2, i), f2 = GetSlot(o2, s), y2 = GetSlot(o2, l), I2 = GetSlot(this, p), S2 = GetSlot(r2, d), w2 = GetSlot(r2, m), D2 = GetSlot(r2, c), G2 = GetSlot(r2, h), v2 = GetSlot(r2, u), C2 = GetSlot(r2, T), O2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(O2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(a2, f2, y2, S2, w2, D2, G2, v2, C2, I2), "compatible"), n), O2, I2);
  }
  withTimeZone(e2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, GetSlot(this, p));
  }
  withCalendar(e2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), GetSlot(this, g), t2);
  }
  add(e2, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("since", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    if (void 0 === t2) throw new TypeError("options parameter is required");
    const r2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2), o2 = ToTemporalRoundingIncrement(r2), a2 = ToTemporalRoundingMode(r2, "halfExpand"), f2 = GetTemporalUnit(r2, "smallestUnit", "time", He, [
      "day"
    ]), y2 = {
      day: 1,
      hour: 24,
      minute: 60,
      second: 60,
      millisecond: 1e3,
      microsecond: 1e3,
      nanosecond: 1e3
    }[f2];
    ValidateTemporalRoundingIncrement(o2, y2, 1 === y2);
    const I2 = dateTime(this);
    let w2 = GetSlot(I2, i), D2 = GetSlot(I2, s), G2 = GetSlot(I2, l), v2 = GetSlot(I2, d), C2 = GetSlot(I2, m), O2 = GetSlot(I2, c), b2 = GetSlot(I2, h), E2 = GetSlot(I2, u), M2 = GetSlot(I2, T);
    const R2 = GetIntrinsic("%Temporal.PlainDateTime%"), F2 = GetSlot(this, g), Y2 = GetSlot(this, p), P2 = GetInstantFor(F2, new R2(GetSlot(I2, i), GetSlot(I2, s), GetSlot(I2, l), 0, 0, 0, 0, 0, 0), "compatible"), Z2 = AddZonedDateTime(P2, F2, Y2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), B2 = import_jsbi.default.subtract(Z2, import_jsbi.default.BigInt(GetSlot(P2, n)));
    if (import_jsbi.default.lessThanOrEqual(B2, Ie)) throw new RangeError("cannot round a ZonedDateTime in a calendar with zero or negative length days");
    ({ year: w2, month: D2, day: G2, hour: v2, minute: C2, second: O2, millisecond: b2, microsecond: E2, nanosecond: M2 } = RoundISODateTime(w2, D2, G2, v2, C2, O2, b2, E2, M2, o2, f2, a2, import_jsbi.default.toNumber(B2)));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(w2, D2, G2, v2, C2, O2, b2, E2, M2, "option", GetOffsetNanosecondsFor(F2, GetSlot(this, S)), F2, "compatible", "prefer", false), F2, GetSlot(this, p));
  }
  equals(t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const r2 = ToTemporalZonedDateTime(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return !!import_jsbi.default.equal(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(a2)) && !!TimeZoneEquals(GetSlot(this, g), GetSlot(r2, g)) && CalendarEquals(GetSlot(this, p), GetSlot(r2, p));
  }
  toString(e2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = (/* @__PURE__ */ __name(function ToShowOffsetOption(e3) {
      return GetOption(e3, "offset", [
        "auto",
        "never"
      ], "auto");
    }, "ToShowOffsetOption"))(t2), a2 = ToTemporalRoundingMode(t2, "trunc"), i2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === i2) throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const s2 = (/* @__PURE__ */ __name(function ToTimeZoneNameOption(e3) {
      return GetOption(e3, "timeZoneName", [
        "auto",
        "never",
        "critical"
      ], "auto");
    }, "ToTimeZoneNameOption"))(t2), { precision: l2, unit: d2, increment: m2 } = ToSecondsStringPrecisionRecord(i2, o2);
    return TemporalZonedDateTimeToString(this, l2, r2, s2, n2, {
      unit: d2,
      increment: m2,
      roundingMode: a2
    });
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const r2 = GetOptionsObject(t2), o2 = Yt(null);
    if (CopyDataProperties(o2, r2, [
      "timeZone"
    ]), void 0 !== r2.timeZone) throw new TypeError("ZonedDateTime toLocaleString does not accept a timeZone option");
    void 0 === o2.year && void 0 === o2.month && void 0 === o2.day && void 0 === o2.weekday && void 0 === o2.dateStyle && void 0 === o2.hour && void 0 === o2.minute && void 0 === o2.second && void 0 === o2.timeStyle && void 0 === o2.dayPeriod && void 0 === o2.timeZoneName && (o2.timeZoneName = "short");
    let n2 = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
    if (IsTimeZoneOffsetString(n2)) throw new RangeError("toLocaleString does not support offset string time zones");
    n2 = GetCanonicalTimeZoneIdentifier(n2), o2.timeZone = n2;
    const a2 = new ht(e2, o2), i2 = Call(Ft, a2, []).calendar, s2 = ToTemporalCalendarIdentifier(GetSlot(this, p));
    if ("iso8601" !== s2 && "iso8601" !== i2 && i2 !== s2) throw new RangeError(`cannot format ZonedDateTime with calendar ${s2} in locale with calendar ${i2}`);
    return a2.format(GetSlot(this, S));
  }
  toJSON() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalZonedDateTimeToString(this, "auto");
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
  }
  startOfDay() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetIntrinsic("%Temporal.PlainDateTime%"), r2 = GetSlot(this, p), o2 = new t2(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), 0, 0, 0, 0, 0, 0, r2), a2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, o2, "compatible"), n), a2, r2);
  }
  toInstant() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
  }
  toPlainDate() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(dateTime(this));
  }
  toPlainTime() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(dateTime(this));
  }
  toPlainDateTime() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return dateTime(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, [
      "monthCode",
      "year"
    ]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, [
      "day",
      "monthCode"
    ]), []));
  }
  getISOFields() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetSlot(this, g);
    return {
      calendar: GetSlot(this, p),
      isoDay: GetSlot(e2, l),
      isoHour: GetSlot(e2, d),
      isoMicrosecond: GetSlot(e2, u),
      isoMillisecond: GetSlot(e2, h),
      isoMinute: GetSlot(e2, m),
      isoMonth: GetSlot(e2, s),
      isoNanosecond: GetSlot(e2, T),
      isoSecond: GetSlot(e2, c),
      isoYear: GetSlot(e2, i),
      offset: GetOffsetStringFor(t2, GetSlot(this, S)),
      timeZone: t2
    };
  }
  getCalendar() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  getTimeZone() {
    if (!IsTemporalZonedDateTime(this)) throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneObject(GetSlot(this, g));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalZonedDateTime(e2) ? (ToTemporalDisambiguation(r2), ToTemporalOffset(r2, "reject"), ToTemporalOverflow(r2), CreateTemporalZonedDateTime(GetSlot(e2, n), GetSlot(e2, g), GetSlot(e2, p))) : ToTemporalZonedDateTime(e2, r2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalZonedDateTime(t2), a2 = ToTemporalZonedDateTime(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return import_jsbi.default.lessThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? -1 : import_jsbi.default.greaterThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? 1 : 0;
  }
};
function dateTime(e2) {
  return GetPlainDateTimeFor(GetSlot(e2, g), GetSlot(e2, S), GetSlot(e2, p));
}
__name(dateTime, "dateTime");
MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
var Pt = Object.freeze({
  __proto__: null,
  Calendar,
  Duration,
  Instant,
  Now: Et,
  PlainDate,
  PlainDateTime,
  PlainMonthDay,
  PlainTime,
  PlainYearMonth,
  TimeZone,
  ZonedDateTime
});
var Zt = [
  Instant,
  Calendar,
  PlainDate,
  PlainDateTime,
  Duration,
  PlainMonthDay,
  PlainTime,
  TimeZone,
  PlainYearMonth,
  ZonedDateTime
];
for (const e2 of Zt) {
  const t2 = Object.getOwnPropertyDescriptor(e2, "prototype");
  (t2.configurable || t2.enumerable || t2.writable) && (t2.configurable = false, t2.enumerable = false, t2.writable = false, Object.defineProperty(e2, "prototype", t2));
}

// workflows/daily-standup.ts
var DEFAULT_SUMMARY_INSTRUCTIONS = `Summarize the user's GitHub pull request activity into a standup update.
- Output between 2 and 10 bullet points.
- Use declarative, concise phrasing with specific impact.
- Do not use emojis or decorative characters.
- Prefer grouping related work into a single bullet.
- If there is no activity, output a single bullet that explains that fact.
`;
async function collectGithubActivityStep(params) {
  const { username, hours } = params;
  const token = process.env.GITHUB_TOKEN;
  if (!token) {
    throw new Error("Missing GITHUB_TOKEN environment variable for GitHub access.");
  }
  const { Octokit: Octokit3 } = await Promise.resolve().then(() => (init_dist_src5(), dist_src_exports));
  const octokit = new Octokit3({
    auth: token
  });
  const since = new Date(Date.now() - hours * 60 * 60 * 1e3).toISOString();
  const activityMap = /* @__PURE__ */ new Map();
  const addItems = /* @__PURE__ */ __name((items2) => {
    for (const item of items2) {
      activityMap.set(item.url, item);
    }
  }, "addItems");
  const searchMerged = await octokit.paginate(octokit.rest.search.issuesAndPullRequests, {
    q: `is:pr author:${username} merged:>=${since} sort:updated-desc`,
    per_page: 50
  });
  addItems(searchMerged.filter((item) => item.pull_request?.html_url).map((item) => ({
    title: item.title,
    repository: item.repository_url?.split("/").slice(-2).join("/") ?? "unknown",
    url: item.pull_request?.html_url ?? item.html_url,
    state: "merged",
    mergedAt: item.closed_at,
    updatedAt: item.updated_at ?? item.closed_at ?? since
  })));
  const searchUpdated = await octokit.paginate(octokit.rest.search.issuesAndPullRequests, {
    q: `is:pr author:${username} updated:>=${since} sort:updated-desc`,
    per_page: 50
  });
  addItems(searchUpdated.filter((item) => item.pull_request?.html_url).map((item) => {
    const isMerged = Boolean(item.pull_request?.merged_at);
    const state = isMerged ? "merged" : item.state;
    return {
      title: item.title,
      repository: item.repository_url?.split("/").slice(-2).join("/") ?? "unknown",
      url: item.pull_request?.html_url ?? item.html_url,
      state,
      mergedAt: item.pull_request?.merged_at ?? null,
      updatedAt: item.updated_at ?? since
    };
  }));
  const items = Array.from(activityMap.values()).sort((a2, b2) => a2.updatedAt < b2.updatedAt ? 1 : -1);
  return items;
}
__name(collectGithubActivityStep, "collectGithubActivityStep");
async function summarizeWithClaudeStep(params) {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) {
    throw new Error("Missing ANTHROPIC_API_KEY environment variable for Claude access.");
  }
  const claudeModel = params.claudeModel ?? process.env.ANTHROPIC_MODEL ?? "claude-3-5-sonnet-20241022";
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const rawBullets = params.activity.length ? params.activity.map((item) => {
    const stateTag = item.state === "merged" ? ":pr-merged:" : item.state === "open" ? ":pr-open:" : ":pr-closed:";
    return `- ${stateTag} ${item.title} [${item.repository}] (${item.url})`;
  }) : [
    "- No GitHub PR activity recorded in this window."
  ];
  const prompt = `${DEFAULT_SUMMARY_INSTRUCTIONS}
Current date/time: ${now}
GitHub username: ${params.username}
Lookback hours: ${params.hours}
Raw entries:
${rawBullets.join("\n")}`;
  const response = await fetch("https://api.anthropic.com/v1/messages", {
    method: "POST",
    headers: {
      "content-type": "application/json",
      "x-api-key": apiKey,
      "anthropic-version": "2023-06-01"
    },
    body: JSON.stringify({
      model: claudeModel,
      max_tokens: 600,
      temperature: 0.4,
      system: "You are an assistant that condenses GitHub pull request updates into crisp standup notes.",
      messages: [
        {
          role: "user",
          content: prompt
        }
      ]
    })
  });
  if (response.status === 429) {
    const retryAfter = parseInt(response.headers.get("retry-after") ?? "60", 10);
    throw new RetryableError("Claude rate limit hit. Retrying later.", {
      retryAfter: Number.isFinite(retryAfter) ? retryAfter : 60
    });
  }
  if (!response.ok) {
    const errorBody = await response.text();
    throw new Error(`Claude request failed (${response.status}): ${errorBody}`);
  }
  const data = await response.json();
  const textContent = data.content?.map((chunk) => chunk.text ?? "").join("\n").trim() ?? "";
  const summaryBullets = textContent.split(/\r?\n/).map((line) => line.trim()).filter((line) => Boolean(line)).map((line) => line.startsWith("-") ? line : `- ${line}`);
  return {
    rawBullets,
    summaryBullets: summaryBullets.length ? summaryBullets : [
      "- No notable updates to report."
    ]
  };
}
__name(summarizeWithClaudeStep, "summarizeWithClaudeStep");
async function persistStandupStep(params) {
  const path4 = await import("node:path");
  const fs2 = await import("node:fs/promises");
  const storageDir = params.storageDirEnv ?? process.env.STANDUP_STORAGE_DIR ?? path4.join(process.cwd(), "standup-data");
  await fs2.mkdir(storageDir, {
    recursive: true
  });
  const payload = {
    generatedAt: params.generatedAt,
    dateKey: params.dateKey,
    username: params.username,
    hours: params.hours,
    rawBullets: params.rawBullets,
    summaryBullets: params.summaryBullets,
    activity: params.activity
  };
  const serialized = JSON.stringify(payload, null, 2);
  const dateFile = path4.join(storageDir, `${payload.dateKey}.json`);
  await fs2.writeFile(dateFile, serialized, "utf8");
  const latestPath = path4.join(storageDir, "latest.json");
  await fs2.writeFile(latestPath, serialized, "utf8");
}
__name(persistStandupStep, "persistStandupStep");
registerStepFunction("step//workflows/daily-standup.ts//collectGithubActivityStep", collectGithubActivityStep);
registerStepFunction("step//workflows/daily-standup.ts//summarizeWithClaudeStep", summarizeWithClaudeStep);
registerStepFunction("step//workflows/daily-standup.ts//persistStandupStep", persistStandupStep);

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/runtime.js
var import_functions3 = __toESM(require_functions(), 1);

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/logger.js
var import_debug = __toESM(require_src2(), 1);
function createLogger2(namespace) {
  const baseDebug = (0, import_debug.default)(`workflow:${namespace}`);
  const logger = /* @__PURE__ */ __name((level) => {
    const levelDebug = baseDebug.extend(level);
    return (message, metadata) => {
      levelDebug(message, metadata);
      if (levelDebug.enabled) {
        getActiveSpan().then((span) => {
          span?.addEvent(`${level}.${namespace}`, {
            message,
            ...metadata
          });
        }).catch(() => {
        });
      }
    };
  }, "logger");
  return {
    debug: logger("debug"),
    info: logger("info"),
    warn: logger("warn"),
    error: logger("error")
  };
}
__name(createLogger2, "createLogger");
var stepLogger = createLogger2("step");
var runtimeLogger = createLogger2("runtime");
var webhookLogger = createLogger2("webhook");
var eventsLogger = createLogger2("events");
var adapterLogger = createLogger2("adapter");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/schemas.js
var TraceCarrierSchema2 = external_exports.record(external_exports.string(), external_exports.string());
var WorkflowInvokePayloadSchema2 = external_exports.object({
  runId: external_exports.string(),
  traceCarrier: TraceCarrierSchema2.optional()
});
var StepInvokePayloadSchema2 = external_exports.object({
  workflowName: external_exports.string(),
  workflowRunId: external_exports.string(),
  workflowStartedAt: external_exports.number(),
  stepId: external_exports.string(),
  traceCarrier: TraceCarrierSchema2.optional()
});

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/types.js
var import_node_util = require("node:util");
function getConstructorName(obj) {
  if (obj === null || obj === void 0) {
    return null;
  }
  const ctor = obj.constructor;
  if (!ctor || ctor.name === "Object") {
    return null;
  }
  return ctor.name;
}
__name(getConstructorName, "getConstructorName");
function getConstructorNames(obj) {
  const proto = Object.getPrototypeOf(obj);
  const name = getConstructorName(proto);
  if (name === null) {
    return [];
  }
  return [
    name,
    ...getConstructorNames(proto)
  ];
}
__name(getConstructorNames, "getConstructorNames");
function isInstanceOf(v2, ctor) {
  return getConstructorNames(v2).includes(ctor.name);
}
__name(isInstanceOf, "isInstanceOf");
function getErrorName(v2) {
  if (import_node_util.types.isNativeError(v2)) {
    return v2.name;
  }
  return "Error";
}
__name(getErrorName, "getErrorName");
function getErrorStack(v2) {
  if (import_node_util.types.isNativeError(v2)) {
    return v2.stack ?? "";
  }
  return "";
}
__name(getErrorStack, "getErrorStack");

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/events-consumer.js
var EventConsumerResult;
(function(EventConsumerResult2) {
  EventConsumerResult2[EventConsumerResult2["Consumed"] = 0] = "Consumed";
  EventConsumerResult2[EventConsumerResult2["NotConsumed"] = 1] = "NotConsumed";
  EventConsumerResult2[EventConsumerResult2["Finished"] = 2] = "Finished";
})(EventConsumerResult || (EventConsumerResult = {}));

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/vm/index.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/runtime/start.js
var import_functions2 = __toESM(require_functions(), 1);

// node_modules/.pnpm/@workflow+core@4.0.1-beta.3_@aws-sdk+client-sts@3.917.0/node_modules/@workflow/core/dist/runtime.js
var stepEntrypoint = /* @__PURE__ */ getWorldHandlers().createQueueHandler("__wkf_step_", async (message_, metadata) => {
  const { workflowName, workflowRunId, workflowStartedAt, stepId, traceCarrier: traceContext } = StepInvokePayloadSchema2.parse(message_);
  return await withTraceContext(traceContext, async () => {
    const stepName = metadata.queueName.slice("__wkf_step_".length);
    const world = getWorld();
    return trace(`STEP ${stepName}`, async (span) => {
      span?.setAttributes({
        ...StepName(stepName),
        ...StepAttempt(metadata.attempt),
        ...QueueName(metadata.queueName)
      });
      const stepFn = getStepFunction(stepName);
      if (!stepFn) {
        throw new Error(`Step "${stepName}" not found`);
      }
      if (typeof stepFn !== "function") {
        throw new Error(`Step "${stepName}" is not a function (got ${typeof stepFn})`);
      }
      span?.setAttributes({
        ...WorkflowName(workflowName),
        ...WorkflowRunId(workflowRunId),
        ...StepId(stepId),
        ...StepMaxRetries(stepFn.maxRetries ?? 3),
        ...StepTracePropagated(!!traceContext)
      });
      let step = await world.steps.get(workflowRunId, stepId);
      runtimeLogger.debug("Step execution details", {
        stepName,
        stepId: step.stepId,
        status: step.status,
        attempt: step.attempt
      });
      span?.setAttributes({
        ...StepStatus(step.status)
      });
      let result;
      const attempt = step.attempt + 1;
      try {
        if (step.status !== "pending") {
          console.error(`[Workflows] "${workflowRunId}" - Step invoked erroneously, expected status "pending", got "${step.status}" instead, skipping execution`);
          span?.setAttributes({
            ...StepSkipped(true),
            ...StepSkipReason(step.status)
          });
          return;
        }
        await world.events.create(workflowRunId, {
          eventType: "step_started",
          correlationId: stepId
        });
        step = await world.steps.update(workflowRunId, stepId, {
          attempt,
          status: "running"
        });
        if (!step.startedAt) {
          throw new WorkflowRuntimeError(`Step "${stepId}" has no "startedAt" timestamp`);
        }
        const ops = [];
        const args = hydrateStepArguments(step.input, ops);
        span?.setAttributes({
          ...StepArgumentsCount(args.length)
        });
        result = await contextStorage.run({
          stepMetadata: {
            stepId,
            stepStartedAt: /* @__PURE__ */ new Date(+step.startedAt),
            attempt
          },
          workflowMetadata: {
            workflowRunId,
            workflowStartedAt: /* @__PURE__ */ new Date(+workflowStartedAt),
            // TODO: there should be a getUrl method on the world interface itself. This
            // solution only works for vercel + embedded worlds.
            url: process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : `http://localhost:${process.env.PORT || 3e3}`
          }
        }, () => stepFn(...args));
        result = dehydrateStepReturnValue(result, ops);
        (0, import_functions3.waitUntil)(Promise.all(ops));
        await world.events.create(workflowRunId, {
          eventType: "step_completed",
          correlationId: stepId,
          eventData: {
            result
          }
        });
        await world.steps.update(workflowRunId, stepId, {
          status: "completed",
          output: result
        });
        span?.setAttributes({
          ...StepStatus("completed"),
          ...StepResultType(typeof result)
        });
      } catch (err) {
        span?.setAttributes({
          ...StepErrorName(getErrorName(err)),
          ...StepErrorMessage(String(err))
        });
        if (isInstanceOf(err, WorkflowAPIError)) {
          if (err.status === 410) {
            console.warn(`Workflow run "${workflowRunId}" has already completed, skipping step "${stepId}": ${err.message}`);
            return;
          }
        }
        if (isInstanceOf(err, FatalError)) {
          const stackLines = getErrorStack(err).split("\n").slice(0, 4);
          console.error(`[Workflows] "${workflowRunId}" - Encountered \`FatalError\` while executing step "${stepName}":
  > ${stackLines.join("\n    > ")}

Bubbling up error to parent workflow`);
          await world.events.create(workflowRunId, {
            eventType: "step_failed",
            correlationId: stepId,
            eventData: {
              error: String(err),
              stack: err.stack,
              fatal: true
            }
          });
          await world.steps.update(workflowRunId, stepId, {
            status: "failed",
            error: String(err)
          });
          span?.setAttributes({
            ...StepStatus("failed"),
            ...StepFatalError(true)
          });
        } else {
          const maxRetries = stepFn.maxRetries ?? 3;
          span?.setAttributes({
            ...StepAttempt(attempt),
            ...StepMaxRetries(maxRetries)
          });
          if (attempt >= maxRetries) {
            const stackLines = getErrorStack(err).split("\n").slice(0, 4);
            console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):
  > ${stackLines.join("\n    > ")}

  Max retries reached
  Bubbling error to parent workflow`);
            const errorMessage = `Step "${stepName}" failed after max retries: ${String(err)}`;
            await world.events.create(workflowRunId, {
              eventType: "step_failed",
              correlationId: stepId,
              eventData: {
                error: errorMessage,
                stack: getErrorStack(err),
                fatal: true
              }
            });
            await world.steps.update(workflowRunId, stepId, {
              status: "failed",
              error: errorMessage
            });
            span?.setAttributes({
              ...StepStatus("failed"),
              ...StepRetryExhausted(true)
            });
          } else {
            if (isInstanceOf(err, RetryableError)) {
              console.warn(`[Workflows] "${workflowRunId}" - Encountered \`RetryableError\` while executing step "${stepName}" (attempt ${attempt}):
  > ${String(err.message)}

  This step has failed but will be retried`);
            } else {
              const stackLines = getErrorStack(err).split("\n").slice(0, 4);
              console.error(`[Workflows] "${workflowRunId}" - Encountered \`Error\` while executing step "${stepName}" (attempt ${attempt}):
  > ${stackLines.join("\n    > ")}

  This step has failed but will be retried`);
            }
            await world.events.create(workflowRunId, {
              eventType: "step_failed",
              correlationId: stepId,
              eventData: {
                error: String(err),
                stack: getErrorStack(err)
              }
            });
            await world.steps.update(workflowRunId, stepId, {
              status: "pending"
            });
            const timeoutSeconds = Math.max(1, isInstanceOf(err, RetryableError) ? Math.floor((+err.retryAfter.getTime() - Date.now()) / 1e3) : 1);
            span?.setAttributes({
              ...StepRetryTimeoutSeconds(timeoutSeconds),
              ...StepRetryWillRetry(true)
            });
            return {
              timeoutSeconds
            };
          }
        }
      }
      await world.queue(`__wkf_workflow_${workflowName}`, {
        runId: workflowRunId,
        traceCarrier: await serializeTraceCarrier()
      });
    });
  });
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  POST
});
